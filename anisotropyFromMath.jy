
# ############################################################################################ 


def field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds ):
    """Routine used to define field-aligned coordinate system by smoothing over given magnetic field data.
	
	Parameters:
	    Bx = rank1 X component of magnetic field
		By = rank1 Y component of magnetic field
		Bz = rank1 Z component of magnetic field
		TEMP_Rx = rank1 X component of radial s/c position (in same coord system as B)
		TEMP_Ry = rank1 Y component of radial s/c position (in same coord system as B)
		TEMP_Rz = rank1 Z component of radial s/c position (in same coord system as B)
		trend_seconds = rank0 number of seconds over which to average B to define as background
		
    Returns:
	    (Bn , Bp , Bq) = rank1 collection of Magnetic Field components in field-aligned system.
		(Nx , Ny , Nz) = rank1 collection of Magnetic Field direction components in original coord system.
		(Px , Py , Pz) = rank1 collection of Quasi-Radial direction components in original coord system.
		(Qx , Qy , Qz) = rank1 collection of Quasi-Azimuthal direction components in original coord system.
	
	"""
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_smooth = smooth(Bx,smooth_points)
    By_smooth = smooth(By,smooth_points)
    Bz_smooth = smooth(Bz,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_smooth / Btotal_smooth
    Ny = By_smooth / Btotal_smooth
    Nz = Bz_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    
    ephem_time = TEMP_Rx.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    TEMP_Rx = interpolate( TEMP_Rx, ephem_to_mag_ratio )
    TEMP_Ry = interpolate( TEMP_Ry , ephem_to_mag_ratio )
    TEMP_Rz = interpolate( TEMP_Rz , ephem_to_mag_ratio )
    
    TEMP_Rmag = sqrt(TEMP_Rx**2 + TEMP_Ry**2 + TEMP_Rz**2)
    
    Rx = -(TEMP_Rx/TEMP_Rmag) #Negate R so that NxR is westwards (need this for right-handedness)
    Ry = -(TEMP_Ry/TEMP_Rmag) 
    Rz = -(TEMP_Rz/TEMP_Rmag) 
    
    TEMP_Px = ( Ny * Rz ) - ( Nz * Ry )
    TEMP_Py = ( Nz * Rx ) - ( Nx * Rz )
    TEMP_Pz = ( Nx * Ry ) - ( Ny * Rx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # N x P ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx * Nx) + (By * Ny) + (Bz * Nz)
    Bp = (Bx * Px) + (By * Py) + (Bz * Pz)
    Bq = (Bx * Qx) + (By * Qy) + (Bz * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
#    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
#    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
#    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
#    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;x!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;x!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;y!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;y!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )
    
    



############################################################################
############################################################################
############################################################################
############################################################################

timerange = getParam('timerange','2018-10-01 to 2019-05-01','Iteration Timerange')
#timerange = getParam('timerange','2018-11-04 5:00 to 5:10','Iteration Timerange')
version = getParam('version','0.4.1','Version number to be appended to filenames')

separatePeaksWithL3Values = False
writeStuff = True
useVDFFluxForWeights = True

#output_folder = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
output_folder = 'C:/Users/kpaulson/Google Drive/Research/PSP/SPC/SPC Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
#output_folder = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_Files/TEMP/'
#output_folder = 'D:/Research/ParkerProbe/SWEAP/SPC/Anisotropy/Anisotropy_Files/L0/v%s/'%(version)

m_p                  = 1.6726231E-24
q                    = 1.6022E-12
#trend_seconds        = 30     # Number of seconds over which to average magField to determine background field direction
trend_seconds        = getParam('Bfield_window' , 30 , 'Number of seconds over which to average magField to determine background field direction' )
#minFluxValueForFit   = 0.5    # Throw out/Don't fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])
minFluxValueForFit   = getParam('Minimum_VDF' , 0.5 , 'Throw out/Don\'t fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])' )
#fitSeconds           = 5     # Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)
fitSeconds           = getParam('fit_window' , 5 , 'Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)')
modFits              = getParam('mod_number' , 50 , 'Number of fits performed before updating plot/time reporting')

cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'
        
    
############################################################################
############################################################################
############################################################################
############################################################################

import java
time_begin = TimeUtil.now()    

plotFitsAndPauseALot_yn = getParam('FitPlots','F', 'Run the script while pausing and plotting each fit for test purposes?',['T','F'])
if plotFitsAndPauseALot_yn == 'T':
    plotFitsAndPauseALot = True
elif plotFitsAndPauseALot_yn == 'F':
    plotFitsAndPauseALot = False
    
        
#####
##########
#################
#anisotropy_deltaPlusMinusFile = 'file:/home/kpaulson/Research/PSP/Anisotropy/TEMP_Anisotropy_DELTA_PLUS-MINUS copy.cdf'
try:
    anisotropy_deltaPlus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_PLUS')
    anisotropy_deltaMinus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_MINUS')
except:
    anisotropy_deltaPlusMinusFile = 'file:/C:/Users/kpaulson/Google Drive/Research/PSP/SPC/SPC Anisotropy/Anisotropy_DELTA_PLUS-MINUS.cdf'
    anisotropy_deltaPlus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_PLUS')
    anisotropy_deltaMinus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_MINUS')
    
#plot(anisotropy_deltaPlus)
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
#################
##########
#####
        

monitor.started()
trs= generateTimeRanges('$Y-$m-$d',timerange)
for tr in trs:
    time_begin_tr = TimeUtil.now()     
    
    if lt(datumRange(timerange).width(), datumRange(tr).width()):
        tr = timerange
        
    try:

        #tr = '2018-11-03 18:33 to 18:39'
        #tr = '2018-11-02 16:45 to 17:20'
        #tr = '2019-04-01 07:00 to 10:00'
        #tr = '2019-04-05 17:30 to 22:30'
        #tr = '2019-04-05 18:30 to 18:40'
        #tr = '2018-11-12'
        #tr = '2018-11-04 04:58 to 06:20'
        #tr = '2019-04-01 08:00 to 08:15'
        #tr = '2018-10-30 16:10 to 20:40'
        #tr = '2018-11-02 1:19 to 1:58'
        
        monitor.setProgressMessage(tr)
        
        
        try:
            spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
            spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
            spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
            spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)
            
            mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
            mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)
        except:
            noSPCData = None
            raise java.io.FileNotFoundException
            
        print 'Downloading SPC L2 data took:',TimeUtil.now()-time_begin_tr
        time_last = TimeUtil.now()
        #spc_list = [spc_a,spc_b,spc_c,spc_d]
        
        spc_a = trim(spc_a,tr)
        spc_b = trim(spc_b,tr)
        spc_c = trim(spc_c,tr)
        spc_d = trim(spc_d,tr)
        
        mv_lo = trim(mv_lo,tr)
        mv_hi = trim(mv_hi,tr)
        #print spc_a
        
        
        #spc_a = putProperty(spc_a/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        #spc_b = putProperty(spc_b/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        #spc_c = putProperty(spc_c/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        #spc_d = putProperty(spc_d/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        spc_list = [spc_a,spc_b,spc_c,spc_d]
        del(spc_a,spc_b,spc_c,spc_d)
        
        totalFlux = sum(spc_list)
        #totalFlux = totalFlux/((mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo))
        
        fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
        fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])
        
        U = (fluxDifference_scy/totalFlux)/0.035
        V = (fluxDifference_scx/totalFlux)/0.035
        
        U.putProperty(QDataSet.VALID_MIN,None)
        V.putProperty(QDataSet.VALID_MIN,None)
        U.putProperty(QDataSet.VALID_MAX,None)
        V.putProperty(QDataSet.VALID_MAX,None)
        

        # This part is in there to match Mike's measurement of Bulk Flow Directions, 
        # but we should pull it out for our fitting, right?
#        for j in xrange(len(U[0,:])):
#            try:
#                U[:,j] = medianFilter(U[:,j],3)
#            except:
#                continue
#            try:
#                V[:,j] = medianFilter(V[:,j],3)
#            except:
#                continue
        
        U.putProperty(QDataSet.UNITS,Units.degrees)
        V.putProperty(QDataSet.UNITS,Units.degrees)
        
        #plot(0,totalFlux)
        #plot(1,U)
        #plot(2,V)
        
        
        #Are you measuring the slope near the peak in current or near the peak in the velocity distribution function? 
        #(the VDF goes like current divided by speed time window width in speed units)
        
        print 'Calculating Flow Angles took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        v_z = sqrt( (2./m_p) * q*(mv_lo + (mv_hi-mv_lo)/2.) ) / 1.E5   # in km/s
        windowWidths = sqrt( (2./m_p) * q*(mv_hi-mv_lo)/2.) / 1.E5
        vdf = totalFlux/(v_z*windowWidths)*1.66667E3 #This factor seems arbitrary, but is necessary to line up with Mike's L3 values.
        vdf.putProperty(QDataSet.DEPEND_1,v_z)
        del(windowWidths,mv_hi)
        
        #totalFlux = totalFlux / (mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo)
        #totalFlux = totalFlux/( (mv_hi-mv_lo))
        totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
        #peaks = reduceMax(totalFlux,1)
        #r = where(eq(totalFlux,peaks))
        peaks = reduceMax(vdf,1)
        r = where(eq(vdf,peaks))
        
        print 'Defining VDF took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        # If we want to use the peaks as weights in fitting, import L3 data and build model distributions
        if separatePeaksWithL3Values == True:
            sweap_spc_file = 'http://sweap.cfa.harvard.edu/data/sci/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf'

            np_fit = getDataSet(sweap_spc_file+'?np_fit',tr)
            wp_fit = getDataSet(sweap_spc_file+'?wp_fit',tr)
            vp_fit_SC = getDataSet(sweap_spc_file+'?vp_fit_SC',tr)
            vp_fit = magnitude(vp_fit_SC)
            spc_time = np_fit.property(QDataSet.DEPEND_0)
            
            np1_fit = getDataSet(sweap_spc_file+'?np1_fit',tr)
            wp1_fit = getDataSet(sweap_spc_file+'?wp1_fit',tr)
            vp1_fit_SC = getDataSet(sweap_spc_file+'?vp1_fit_SC',tr)
            vp1_fit = magnitude(vp1_fit_SC)
            
            na_fit = getDataSet(sweap_spc_file+'?na_fit',tr)
            wa_fit = getDataSet(sweap_spc_file+'?wa_fit',tr)
            va_fit_SC = getDataSet(sweap_spc_file+'?va_fit_SC',tr)
            va_fit = magnitude(va_fit_SC)
            
            # Define Gaussian parameters
            cp = wp_fit            
            ap = np_fit / (cp*sqrt(PI))         
            bp = vp_fit
            
            cp1 = wp1_fit     
            ap1 = np1_fit / (cp1*sqrt(PI))                
            bp1 = vp1_fit
            
            ca = wa_fit    
            aa = (na_fit/2.) / (ca*sqrt(PI))                 
            ba = va_fit * sqrt(2.)
            
            (ap,bp,cp) = synchronize(v_z,[ap,bp,cp])
            (ap1,bp1,cp1) = synchronize(v_z,[ap1,bp1,cp1])
            (aa,ba,ca) = synchronize(v_z,[aa,ba,ca])
            
            
            v_space = copy(v_z)
            v_space_time = v_space.property(QDataSet.DEPEND_0)
            peak_p  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            peak_p1 = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            peak_a  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            v_index = 0
            for v_index in xrange(len(v_space[0,:])):
                
                #peak_p[:,v_index]  = ap*exp(-((v_space[:,v_index] - bp)**2 / (2*cp**2)))
                #peak_p1[:,v_index] = ap1*exp(-((v_space[:,v_index] - bp1)**2 / (2*cp1**2)))
                #peak_a[:,v_index]  = aa*exp(-((v_space_a[:,v_index] - ba)**2 / (2*ca**2)))
                
                peak_p[:,v_index]  = ap *exp(-((v_space[:,v_index]   - bp )**2 / (cp**2)))
                peak_p1[:,v_index] = ap1*exp(-((v_space[:,v_index]   - bp1)**2 / (cp1**2)))
                peak_a[:,v_index]  = aa *exp(-((v_space[:,v_index] - ba )**2 / (ca**2)))
                #v_index+=1
            
            peak_p.putProperty(QDataSet.DEPEND_0,v_space_time)
            peak_p.putProperty(QDataSet.DEPEND_1,v_space)
            peak_p.putProperty(QDataSet.VALID_MIN,1E-10)
            peak_p.putProperty(QDataSet.VALID_MAX,1E10)
            
            peak_p1.putProperty(QDataSet.DEPEND_0,v_space_time)
            peak_p1.putProperty(QDataSet.DEPEND_1,v_space)
            peak_p1.putProperty(QDataSet.VALID_MIN,1E-10)
            peak_p1.putProperty(QDataSet.VALID_MAX,1E10)
            
            peak_a.putProperty(QDataSet.DEPEND_0,v_space_time)
            peak_a.putProperty(QDataSet.DEPEND_1,v_space)
            peak_a.putProperty(QDataSet.VALID_MIN,0)
            peak_a.putProperty(QDataSet.VALID_MAX,1E20)
            
            print 'Building Peaks took:',TimeUtil.now()-time_last
            time_last = TimeUtil.now()
        

        
        vz_tanTheta = v_z * tan(toRadians(V))     # Vx
        vz_tanPhi   = v_z * tan(toRadians(U))     # Vy
        #plot(vz_tanPhi)
        #stop
        
        
        
        
        setLayoutOverplot(4) 
        
        #plot(0,totalFlux)
        plot(0,vdf,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle='vdf',zlog=True)
        plot(1,v_z[r])
        #stop
        
        
        from org.apache.commons.math.optimization.fitting import CurveFitter
        from org.apache.commons.math.optimization.fitting import ParametricRealFunction
        from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer
        from org.apache.commons.math.stat.regression      import SimpleRegression
        
        class LinFit(ParametricRealFunction):
            def value(self, x, params):
                a = params[0]
                b = params[1]
                return (a*x + b)
            def gradient(self, x, params):
                a = params[0]
                b = params[1]
                return [x,1]
        
        #####
        ##########
        #################
        mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
        mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
        
        #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
        mag = trim(mag,tr)
        
        mag_time = mag.property(QDataSet.DEPEND_0)
        
        pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
        pos_time = pos.property(QDataSet.DEPEND_0)
        
        Bx = mag[:,0]
        By = mag[:,1]
        Bz = mag[:,2]
        Btotal = magnitude(mag)
        
        TEMP_Rx = putProperty(ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Ry = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Rz = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        
        
        ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
        
        (Nx_temp,Ny_temp,Nz_temp) = synchronize(totalFlux,[Nx,Ny,Nz])
        #################
        ##########
        #####
        
        print 'Downloading MAG Data took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        inputGuessParams = [float(rand(1)[0]),float(rand(1)[0])]            
        chiline                = None
        psiline                = None
        epsilonEpoch           = None
        chiSquaredReduced_chi  = None
        chiSquaredReduced_psi  = None
        rSquared_chi           = None
        rSquared_psi           = None
        slopeError_chi         = None
        slopeError_psi         = None
        if separatePeaksWithL3Values == True:          
            chiline_p1                = None
            psiline_p1                = None
            epsilonEpoch_p1           = None
            chiSquaredReduced_chi_p1  = None
            chiSquaredReduced_psi_p1  = None
            rSquared_chi_p1           = None
            rSquared_psi_p1           = None
            slopeError_chi_p1         = None
            slopeError_psi_p1         = None          
            chiline_a                = None
            psiline_a                = None
            epsilonEpoch_a           = None
            chiSquaredReduced_chi_a  = None
            chiSquaredReduced_psi_a  = None
            rSquared_chi_a           = None
            rSquared_psi_a           = None
            slopeError_chi_a         = None
            slopeError_psi_a         = None
        
        if ge(fitSeconds,1.):
            dds= generateTimeRanges('$Y-$m-$d $H:$M:$(S,span=%s)'%(fitSeconds),tr)
            dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$(S,span=%s)'%(fitSeconds),tr)
        elif lt(fitSeconds,1.):
            dds= generateTimeRanges('$Y-$m-$d $H:$M:$S.$(milli,span=%s)'%int(fitSeconds*1E3),tr)
            dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$S.$(milli,span=%s)'%int(fitSeconds*1E3),tr)
        
        time_fit_begin = TimeUtil.now()
        monitor.setTaskSize(len(dds)-1)
        for ind in xrange(len(dds)-1):
            monitor.setTaskProgress(ind)
            monitor.setLabel('Linear Fits') 
            
            
            if ( monitor.cancelled ):
                print 'Canceling Process at (%s %s)'%(str(int(100.*ind/(len(dds)-1.))),'%')
                break
            
            try:
                tr_dds = dds[ind]+' to '+dds[ind+1]
                if mod(ind,modFits) == 0:
                    plot(3,datumRange(tr_dds),renderType='eventsBar',color='magenta')
                
                # Manual way to Create Event
#                event = dblarr(1,4)
#                event[0,0] = dataset(datumRange(tr_dds).min())
#                event[0,1] = dataset(datumRange(tr_dds).max())
#                event[0,2] = dataset(0x666600FF)
#                event[0,3] = dataset('event')

                # Correct way to Create Event
                event = createEvents(datumRange(tr_dds),Color(0x666600FF))
                
                v_z_dd = trim(v_z,tr_dds)
                vz_tanPhi_dd = trim(vz_tanPhi,tr_dds)
                vz_tanTheta_dd = trim(vz_tanTheta,tr_dds)
                
                totalFlux_dd = trim(totalFlux,tr_dds)
                vdf_dd = trim(vdf,tr_dds)
                
                Nx_temp_dd = trim(Nx_temp,tr_dds)
                Ny_temp_dd = trim(Ny_temp,tr_dds)
                Nz_temp_dd = mean(trim(Nz_temp,tr_dds))
                
                temp_v_z = None
                temp_vz_tanTheta = None
                temp_vz_tanPhi = None
                temp_totalFlux = None
                temp_vdf = None
                temp_Nx_temp_dd = None
                temp_Ny_temp_dd = None
                for i in xrange(len(v_z_dd)):
                    temp_v_z         = concatenate(temp_v_z,v_z_dd[i,:])
                    temp_vz_tanTheta = concatenate(temp_vz_tanTheta,vz_tanTheta_dd[i,:])  # Vx
                    temp_vz_tanPhi   = concatenate(temp_vz_tanPhi,vz_tanPhi_dd[i,:])      # Vy
                    temp_totalFlux   = concatenate(temp_totalFlux,totalFlux_dd[i,:])
                    temp_vdf         = concatenate(temp_vdf,vdf_dd[i,:])
                    temp_Nx_temp_dd  = concatenate(temp_Nx_temp_dd,ones(len(v_z_dd[i,:]))*Nx_temp_dd[i])
                    temp_Ny_temp_dd  = concatenate(temp_Ny_temp_dd,ones(len(v_z_dd[i,:]))*Ny_temp_dd[i])
                
                if mod(ind,modFits) == 0:    
                    print 'Rewriting each fitting parameter into rank1 array took:',TimeUtil.now()-time_last
                    time_last = TimeUtil.now()
                    
                norm_temp_totalFlux = normalize(temp_totalFlux)
                norm_temp_vdf = normalize(temp_vdf)
                r = where(ge(temp_vdf,minFluxValueForFit).and(valid(temp_vdf)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
                
                if separatePeaksWithL3Values == True:
                    peak_p_dd  = trim(peak_p, tr_dds)
                    peak_p1_dd = trim(peak_p1,tr_dds)
                    peak_a_dd  = trim(peak_a, tr_dds)
                    
                    temp_peak_p = None
                    for i in xrange(len(v_z_dd)):
                        temp_peak_p         = concatenate(temp_peak_p, peak_p_dd[i,:])
                        temp_peak_p1        = concatenate(temp_peak_p1,peak_p1_dd[i,:])
                        temp_peak_a         = concatenate(temp_peak_a, peak_a_dd[i,:])
                    
                elif separatePeaksWithL3Values == False:
                    # These two lines below should create a step function on the normalized weights such that anything less than 0.5 goes to 0. The idea is that this will only fit the points that are above half the max of the peak
                    blackoutNormalized = where(lt(norm_temp_vdf,0.5))
                    norm_temp_vdf[blackoutNormalized] = 0
                    temp_vdf[blackoutNormalized] = 0
                    #plot(norm_temp_vdf[r]*100,xrange=[0,600],renderType='scatter')
            
                f = LinFit()
                
                ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                ftr_psi = CurveFitter(LevenbergMarquardtOptimizer())
                
                if separatePeaksWithL3Values == True:
                
                    ftr_chi_p1 = CurveFitter(LevenbergMarquardtOptimizer())
                    ftr_psi_p1 = CurveFitter(LevenbergMarquardtOptimizer())
                    ftr_chi_a = CurveFitter(LevenbergMarquardtOptimizer())
                    ftr_psi_a = CurveFitter(LevenbergMarquardtOptimizer())
                
                for i in xrange(len(temp_v_z[r])):
                    # This weighting uses the normalized VDF data - It isn't working because it loses the weights for some reason (floats->doubles)
                    #ftr_chi.addObservedPoint( int(float(norm_temp_vdf[r][i])*100) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                    #ftr_psi.addObservedPoint( int(float(norm_temp_vdf[r][i])*100) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))
                    
                    if separatePeaksWithL3Values == True:
                        ftr_chi.addObservedPoint( int(float(temp_peak_p[r][i])*1000) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                        ftr_psi.addObservedPoint( int(float(temp_peak_p[r][i])*1000) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))
                        ftr_chi_p1.addObservedPoint( int(float(temp_peak_p1[r][i])*1000) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                        ftr_psi_p1.addObservedPoint( int(float(temp_peak_p1[r][i])*1000) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))
                        ftr_chi_a.addObservedPoint( int(float(temp_peak_a[r][i])*1000) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                        ftr_psi_a.addObservedPoint( int(float(temp_peak_a[r][i])*1000) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))
                    
                    elif separatePeaksWithL3Values == False:
                        # This weighting uses the original vdf where we ignore any points below half of the normalized peak
                        if useVDFFluxForWeights == False: #In this case, set all values above the above-listed noise floor to one so they have the same weights
                            temp_vdf[r][i] = 1.
                        ftr_chi.addObservedPoint( int(float(temp_vdf[r][i])*1000) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                        ftr_psi.addObservedPoint( int(float(temp_vdf[r][i])*1000) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))

                    
                if mod(ind,modFits) == 0:    
                    print 'Adding all points into fitting function took:',TimeUtil.now()-time_last
                    time_last = TimeUtil.now()
                
                result_chi = ftr_chi.fit(f,inputGuessParams)
                result_psi = ftr_psi.fit(f,inputGuessParams)
                
                xx_x = linspace( min((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
                xx_y = linspace( min((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
            
                
                
                # This is the chiSquared value I was using
                #temp_chiSquared_chi = abs(total( ( temp_vz_tanTheta[r] - (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) )**2 / (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) ) )
                #temp_chiSquared_psi = abs(total( ( temp_vz_tanPhi[r]   - (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) )**2 / (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) ) )
                
                # This chiSquared tries to only calculate it where I used the weighted values for the fit (ignoring the points with flux below 0.5*peak)
                VDF_fitValues = where(gt(temp_vdf[r],0))
                temp_fitValues_chi = (result_chi[0]*(temp_v_z[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues]) + result_chi[1])
                temp_fitValues_psi = (result_psi[0]*(temp_v_z[r][VDF_fitValues]*temp_Ny_temp_dd[r][VDF_fitValues]) + result_psi[1])
                temp_residualVariance_chi = ( temp_vz_tanTheta[r][VDF_fitValues] - temp_fitValues_chi )**2
                temp_residualVariance_psi = ( temp_vz_tanPhi[r][VDF_fitValues]   - temp_fitValues_psi )**2
                
                temp_chiSquared_chi = total( abs( temp_residualVariance_chi / temp_fitValues_chi ) )
                temp_chiSquared_psi = total( abs( temp_residualVariance_psi / temp_fitValues_psi ) )
                
                temp_chiSquaredReduced_chi = temp_chiSquared_chi / (len(temp_v_z[r][VDF_fitValues]) - 2) # Should be (n-2) degrees of freedom
                temp_chiSquaredReduced_psi = temp_chiSquared_psi / (len(temp_v_z[r][VDF_fitValues]) - 2)
                
                temp_totalVariance_chi = (temp_vz_tanTheta[r][VDF_fitValues] - mean(temp_vz_tanTheta[r][VDF_fitValues]))**2
                temp_totalVariance_psi = (temp_vz_tanPhi[r][VDF_fitValues]   - mean(temp_vz_tanPhi[r][VDF_fitValues]))**2
                
                temp_rSquared_chi = 1 - ( total(temp_residualVariance_chi) / total(temp_totalVariance_chi) )
                temp_rSquared_psi = 1 - ( total(temp_residualVariance_psi) / total(temp_totalVariance_psi) )
                
                temp_abscissaVariance_chi = ( (temp_v_z[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues]) - mean((temp_v_z[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues])) )**2
                temp_abscissaVariance_psi = ( (temp_v_z[r][VDF_fitValues]*temp_Ny_temp_dd[r][VDF_fitValues]) - mean((temp_v_z[r][VDF_fitValues]*temp_Ny_temp_dd[r][VDF_fitValues])) )**2
                
                temp_slopeError_chi = sqrt( total(temp_residualVariance_chi) / total(temp_abscissaVariance_chi) ) / (len(temp_v_z[r][VDF_fitValues]) - 2)
                temp_slopeError_psi = sqrt( total(temp_residualVariance_psi) / total(temp_abscissaVariance_psi) ) / (len(temp_v_z[r][VDF_fitValues]) - 2)
                
                
                # Have to append everything at once since I was left with uneven dataset/epoch arrays
                chiline = concatenate(chiline,result_chi[0])
                psiline = concatenate(psiline,result_psi[0])
                
                chiSquaredReduced_chi = concatenate(chiSquaredReduced_chi,temp_chiSquaredReduced_chi)
                chiSquaredReduced_psi = concatenate(chiSquaredReduced_psi,temp_chiSquaredReduced_psi)
                
                rSquared_chi = concatenate(rSquared_chi,temp_rSquared_chi)
                rSquared_psi = concatenate(rSquared_psi,temp_rSquared_psi)
                
                slopeError_chi = concatenate(slopeError_chi,temp_slopeError_chi)
                slopeError_psi = concatenate(slopeError_psi,temp_slopeError_psi)
                
                
                if mod(ind,modFits) == 0:    
                    print 'Calculating Uncertainties took:',TimeUtil.now()-time_last
                    time_last = TimeUtil.now()
                    print 'Total fitting function so far (%s %s) took:'%(str(int(100.*ind/(len(dds)-1.))),'%'),TimeUtil.now()-time_begin_tr
                
                if separatePeaksWithL3Values == True:
                    result_chi_p1 = ftr_chi_p1.fit(f,inputGuessParams)
                    result_psi_p1 = ftr_psi_p1.fit(f,inputGuessParams)
                    
                    
                    
                    # This is the chiSquared value I was using
                    #temp_chiSquared_chi = abs(total( ( temp_vz_tanTheta[r] - (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) )**2 / (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) ) )
                    #temp_chiSquared_psi = abs(total( ( temp_vz_tanPhi[r]   - (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) )**2 / (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) ) )
                    
                    # This chiSquared tries to only calculate it where I used the weighted values for the fit (ignoring the points with flux below 0.5*peak)
                    VDF_fitValues_p1 = where(gt(temp_peak_p1[r],0))
                    temp_fitValues_chi_p1 = (result_chi_p1[0]*(temp_v_z[r][VDF_fitValues_p1]*temp_Nx_temp_dd[r][VDF_fitValues_p1]) + result_chi_p1[1])
                    temp_fitValues_psi_p1 = (result_psi_p1[0]*(temp_v_z[r][VDF_fitValues_p1]*temp_Ny_temp_dd[r][VDF_fitValues_p1]) + result_psi_p1[1])
                    temp_residualVariance_chi_p1 = ( temp_vz_tanTheta[r][VDF_fitValues_p1] - temp_fitValues_chi_p1 )**2
                    temp_residualVariance_psi_p1 = ( temp_vz_tanPhi[r][VDF_fitValues_p1]   - temp_fitValues_psi_p1 )**2
                    
                    temp_chiSquared_chi_p1 = total( abs( temp_residualVariance_chi_p1 / temp_fitValues_chi_p1 ) )
                    temp_chiSquared_psi_p1 = total( abs( temp_residualVariance_psi_p1 / temp_fitValues_psi_p1 ) )
                    
                    temp_chiSquaredReduced_chi_p1 = temp_chiSquared_chi_p1 / (len(temp_v_z[r][VDF_fitValues_p1]) - 2) # Should be (n-2) degrees of freedom
                    temp_chiSquaredReduced_psi_p1 = temp_chiSquared_psi_p1 / (len(temp_v_z[r][VDF_fitValues_p1]) - 2)
                    
                    temp_totalVariance_chi_p1 = (temp_vz_tanTheta[r][VDF_fitValues_p1] - mean(temp_vz_tanTheta[r][VDF_fitValues_p1]))**2
                    temp_totalVariance_psi_p1 = (temp_vz_tanPhi[r][VDF_fitValues_p1]   - mean(temp_vz_tanPhi[r][VDF_fitValues_p1]))**2
                    
                    temp_rSquared_chi_p1 = 1 - ( total(temp_residualVariance_chi_p1) / total(temp_totalVariance_chi_p1) )
                    temp_rSquared_psi_p1 = 1 - ( total(temp_residualVariance_psi_p1) / total(temp_totalVariance_psi_p1) )
                    
                    temp_abscissaVariance_chi_p1 = ( (temp_v_z[r][VDF_fitValues_p1]*temp_Nx_temp_dd[r][VDF_fitValues_p1]) - mean((temp_v_z[r][VDF_fitValues_p1]*temp_Nx_temp_dd[r][VDF_fitValues_p1])) )**2
                    temp_abscissaVariance_psi_p1 = ( (temp_v_z[r][VDF_fitValues_p1]*temp_Ny_temp_dd[r][VDF_fitValues_p1]) - mean((temp_v_z[r][VDF_fitValues_p1]*temp_Ny_temp_dd[r][VDF_fitValues_p1])) )**2
                    
                    temp_slopeError_chi_p1 = sqrt( total(temp_residualVariance_chi_p1) / total(temp_abscissaVariance_chi_p1) ) / (len(temp_v_z[r][VDF_fitValues_p1]) - 2)
                    temp_slopeError_psi_p1 = sqrt( total(temp_residualVariance_psi_p1) / total(temp_abscissaVariance_psi_p1) ) / (len(temp_v_z[r][VDF_fitValues_p1]) - 2)
                    
                    
                    # Have to append everything at once since I was left with uneven dataset/epoch arrays
                    chiline_p1 = concatenate(chiline_p1,result_chi_p1[0])
                    psiline_p1 = concatenate(psiline_p1,result_psi_p1[0])
                    
                    chiSquaredReduced_chi_p1 = concatenate(chiSquaredReduced_chi_p1,temp_chiSquaredReduced_chi_p1)
                    chiSquaredReduced_psi_p1 = concatenate(chiSquaredReduced_psi_p1,temp_chiSquaredReduced_psi_p1)
                    
                    rSquared_chi_p1 = concatenate(rSquared_chi_p1,temp_rSquared_chi_p1)
                    rSquared_psi_p1 = concatenate(rSquared_psi_p1,temp_rSquared_psi_p1)
                    
                    slopeError_chi_p1 = concatenate(slopeError_chi_p1,temp_slopeError_chi_p1)
                    slopeError_psi_p1 = concatenate(slopeError_psi_p1,temp_slopeError_psi_p1)
                
                #epsilonEpoch = concatenate(epsilonEpoch,datum(dds[ind])+(datum(dds[ind+1])-datum(dds[ind]))/2.)
                epsilonEpoch = concatenate(epsilonEpoch,datum(dds[ind])+datum(str(fitSeconds/2.)+' sec') )
                #plot(4,epsilonEpoch))
                #plot(5,rSquared_psi)
                
                
                if plotFitsAndPauseALot == True:
                    
                    temp_epsilon_chi = - result_chi[0] / ( (result_chi[0]*(1 - Nz_temp_dd**2)) + Nz_temp_dd )
                    temp_epsilon_psi = - result_psi[0] / ( (result_psi[0]*(1 - Nz_temp_dd**2)) + Nz_temp_dd )
                    plot_anisotropy_chi = sqrt(temp_epsilon_chi+1)
                    plot_anisotropy_psi = sqrt(temp_epsilon_psi+1)
                    
                    
                    # The asin() is wrong, since I don't want the total orthogonality angle, just the angle between (Nx,Ny) and Nz
                    #mappedAngleIndex_chi = imin(abs(toDegrees(asin(Nx[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                    #mappedAngleIndex_psi = imin(abs(toDegrees(asin(Ny[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                    
                    # This atan() sould account for the above issue
                    mappedAngleIndex_chi = imin(abs(toDegrees(atan(mean(Nx_temp_dd)/Nz_temp_dd))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                    mappedAngleIndex_psi = imin(abs(toDegrees(atan(mean(Ny_temp_dd)/Nz_temp_dd))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                    
                    mappedAnisotropyIndex_chi = imin(abs(plot_anisotropy_chi-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
                    mappedAnisotropyIndex_psi = imin(abs(plot_anisotropy_psi-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
                    
                    if mappedAngleIndex_chi != -1 and mappedAnisotropyIndex_chi != -1 :
                        anisotropy_chi_deltaPlus  = anisotropy_deltaPlus[ mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                        anisotropy_chi_deltaMinus = anisotropy_deltaMinus[mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                    else:
                        anisotropy_chi_deltaPlus  = -1
                        anisotropy_chi_deltaMinus = -1
                        
                    if mappedAngleIndex_psi != -1 and mappedAnisotropyIndex_psi != -1 :
                        anisotropy_psi_deltaPlus  = anisotropy_deltaPlus[ mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                        anisotropy_psi_deltaMinus = anisotropy_deltaMinus[mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                    else:
                        anisotropy_psi_deltaPlus  = -1
                        anisotropy_psi_deltaMinus = -1
                    
                    #plot(3,dataset([datumRange(tr_dds).min(),datumRange(tr_dds).max(),'xff00ff','event']),renderType='eventsBar',color='magenta')
                    plot(3,event,renderType='eventsBar')
                    plot(4,temp_v_z[r]*temp_Nx_temp_dd[r],temp_vz_tanTheta[r] ,norm_temp_vdf[r],renderType='colorScatter',ztitle='Normalized Flux',symbolSize=3)
                    plot(6,temp_v_z[r]*temp_Ny_temp_dd[r],temp_vz_tanPhi[r]   ,norm_temp_vdf[r],renderType='colorScatter',ztitle='Normalized Flux',symbolSize=3)
                    #plot(5,xx_x,(result_chi[0]*xx_x + result_chi[1]),color='red',xtitle=tr_dds,title='r!U2!N = '+str(round(temp_rSquared_chi,4))+'     &Chi;!U2!Bred.!N = '+str(round(temp_chiSquaredReduced_chi,4))+'     Slope = '+str(round(result_chi[0],4))+'     SlopeError = '+str(round(temp_slopeError_chi,4)),symbolSize=0,lineWidth=2,ytitle='V!Bx')
                    #plot(7,xx_y,(result_psi[0]*xx_y + result_psi[1]),color='red',xtitle='V!Bz!N!C'+tr_dds,title='r!U2!N = '+str(round(temp_rSquared_psi,4))+'     &Chi;!U2!Bred.!N = '+str(round(temp_chiSquaredReduced_psi,4))+'     Slope = '+str(round(result_psi[0],4))+'     SlopeError = '+str(round(temp_slopeError_psi,4)),symbolSize=0,lineWidth=2,ytitle='V!By')
                    plot(5,xx_x,(result_chi[0]*xx_x + result_chi[1]),color='red',xtitle='V!Bz!N*B!Bx!N!C!C'+tr_dds,title='Slope = '+str(round(result_chi[0],4))+'     SlopeError = '+str(round(temp_slopeError_chi,4))+'     Anisotropy!B&Chi;!N = '+str(round(plot_anisotropy_chi,3))+' &plusmn; ['+str(round(anisotropy_chi_deltaPlus,3))+','+str(round(anisotropy_chi_deltaMinus,3))+']',symbolSize=0,lineWidth=2,ytitle='V!Bx')
                    plot(7,xx_y,(result_psi[0]*xx_y + result_psi[1]),color='red',xtitle='V!Bz!N*B!By!N!C!C'+tr_dds,title='Slope = '+str(round(result_psi[0],4))+'     SlopeError = '+str(round(temp_slopeError_psi,4))+'     Anisotropy!B&Psi;!N = '+str(round(plot_anisotropy_psi,3))+' &plusmn; ['+str(round(anisotropy_psi_deltaPlus,3))+','+str(round(anisotropy_psi_deltaMinus,3))+']',symbolSize=0,lineWidth=2,ytitle='V!By')
                    #plot(8,trim(Nz_temp,tr_dds),title=Nz_temp_dd)
                    
#                    psiline_temp = putProperty(copy(psiline),QDataSet.DEPEND_0,epsilonEpoch)
#                    chiline_temp = putProperty(copy(chiline),QDataSet.DEPEND_0,epsilonEpoch)
#
#                    (Nx_temp,Ny_temp,Nz_temp) = synchronize(chiline_temp,[Nx,Ny,Nz])
#                    Btotal_temp = synchronize(chiline_temp,[Btotal])[0]   # Since synchronize puts out a list of arrays, use the [0] to choose the array itself
#
#                    epsilon_chi_temp = - chiline_temp / ( (chiline_temp*(1 - Nz_temp**2)) + Nz_temp ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
#                    epsilon_psi_temp = - psiline_temp / ( (psiline_temp*(1 - Nz_temp**2)) + Nz_temp )
#
#                    anisotropy_chi_temp = sqrt(epsilon_chi_temp+1)
#                    anisotropy_psi_temp = sqrt(epsilon_psi_temp+1)

                    #plot(8,sqrt(temp_residualVariance_chi),renderType='scatter',color='red')
                    #plot(9,sqrt(temp_residualVariance_psi),renderType='scatter',color='blue')
                    #plot(10,sqrt(temp_totalVariance_chi),renderType='scatter',color='red')
                    #plot(11,sqrt(temp_totalVariance_psi),renderType='scatter',color='blue')
                    
                    sleep(5000)
                    continue
            except:
                #print 'oopsy, couldn\'t fit for some reason'
                continue
        
        #########
        #########
        #########
            
        if ( monitor.cancelled ):
            print 'Canceling Process for',timerange
            break
        
        print 'Total fitting section for day took:',TimeUtil.now()-time_fit_begin
        time_last = TimeUtil.now()
        
        
        ####### Set DEPEND_0 for datasets
        
        psiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        chiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        chiSquaredReduced_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        chiSquaredReduced_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        rSquared_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        rSquared_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        slopeError_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        slopeError_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        
        
        
        # ###
        # ### FINAL CALCULATIONS
        # ###
        
        (Nx,Ny,Nz) = synchronize(chiline,[Nx,Ny,Nz])
        Btotal = synchronize(chiline,[Btotal])[0]   # Since synchronize puts out a list of arrays, use the [0] to choose the array itself
        
        epsilon_chi = - chiline / ( (chiline*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
        epsilon_psi = - psiline / ( (psiline*(1 - Nz**2)) + Nz )
    
        anisotropy_chi = sqrt(epsilon_chi+1)
        anisotropy_psi = sqrt(epsilon_psi+1)
        
        
        
        #mappedAngleIndex_chi      = dblarr(len(epsilonEpoch))
        #mappedAngleIndex_psi      = dblarr(len(epsilonEpoch))
        #mappedAnisotropyIndex_chi = dblarr(len(epsilonEpoch))
        #mappedAnisotropyIndex_psi = dblarr(len(epsilonEpoch))
        anisotropy_chi_deltaPlus  = dblarr(len(epsilonEpoch))
        anisotropy_chi_deltaMinus = dblarr(len(epsilonEpoch))
        anisotropy_psi_deltaPlus  = dblarr(len(epsilonEpoch))
        anisotropy_psi_deltaMinus = dblarr(len(epsilonEpoch))
        for i in xrange(len(epsilonEpoch)):
            # The asin() is wrong, since I don't want the total orthogonality angle, just the angle between (Nx,Ny) and Nz
            #mappedAngleIndex_chi = imin(abs(toDegrees(asin(Nx[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
            #mappedAngleIndex_psi = imin(abs(toDegrees(asin(Ny[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
            
            # This atan() sould account for the above issue
            mappedAngleIndex_chi = imin(abs(toDegrees(atan(Nx[i]/Nz[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
            mappedAngleIndex_psi = imin(abs(toDegrees(atan(Ny[i]/Nz[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
            
            mappedAnisotropyIndex_chi = imin(abs(anisotropy_chi[i]-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
            mappedAnisotropyIndex_psi = imin(abs(anisotropy_psi[i]-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
            
            if mappedAngleIndex_chi != -1 and mappedAnisotropyIndex_chi != -1 :
                anisotropy_chi_deltaPlus[i]  = anisotropy_deltaPlus[ mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                anisotropy_chi_deltaMinus[i] = anisotropy_deltaMinus[mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
            else:
                anisotropy_chi_deltaPlus[i]  = -1
                anisotropy_chi_deltaMinus[i] = -1
                
            if mappedAngleIndex_psi != -1 and mappedAnisotropyIndex_psi != -1 :
                anisotropy_psi_deltaPlus[i]  = anisotropy_deltaPlus[ mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                anisotropy_psi_deltaMinus[i] = anisotropy_deltaMinus[mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
            else:
                anisotropy_psi_deltaPlus[i]  = -1
                anisotropy_psi_deltaMinus[i] = -1
            
        anisotropy_chi_deltaPlus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        anisotropy_chi_deltaMinus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        anisotropy_psi_deltaPlus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        anisotropy_psi_deltaMinus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            
        anisotropy_chi_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
        anisotropy_chi_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
        anisotropy_chi_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
        anisotropy_chi_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
        anisotropy_psi_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
        anisotropy_psi_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
        anisotropy_psi_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
        anisotropy_psi_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
        
        anisotropy_chi.putProperty(QDataSet.DELTA_PLUS, anisotropy_chi_deltaPlus)
        anisotropy_chi.putProperty(QDataSet.DELTA_MINUS,anisotropy_chi_deltaMinus)
        anisotropy_psi.putProperty(QDataSet.DELTA_PLUS, anisotropy_psi_deltaPlus)
        anisotropy_psi.putProperty(QDataSet.DELTA_MINUS,anisotropy_psi_deltaMinus)
            
            
        Bunit = bundle(Nx,Ny,Nz)
        Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        
        # ###
        # ### WRITE STUFF
        # ###
        
        if writeStuff == True:
            output_file = output_folder+'SPC_Anisotropy_%s_v%s.cdf'%(tr,version)
            #output_file = output_folder+'SPC_Anisotropy_%s_v%s_%ssec.cdf'%(tr,version,str(fitSeconds))
            
            Bunit.putProperty(QDataSet.NAME,'B_hat')
            Bunit.putProperty(QDataSet.TITLE,'Unit vector of background B-field direction using %s-second average'%(trend_seconds))
            Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            formatDataSet(Bunit,output_file)
            Btotal.putProperty(QDataSet.NAME,'B_total')
            Btotal.putProperty(QDataSet.TITLE,'Total B-field magnitude')
            Btotal.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            formatDataSet(Btotal,output_file+'?append=T')
            
            
            psiline.putProperty(QDataSet.NAME,'Psi')
            psiline.putProperty(QDataSet.TITLE,'Linear fit of scan points over %s-second range in Vy/Vz space'%fitSeconds)
            psiline.putProperty(QDataSet.DESCRIPTION,'Determined from slope between Vy and Vz*B_hat_y around peak of VDF')
            chiline.putProperty(QDataSet.NAME,'Chi')
            chiline.putProperty(QDataSet.TITLE,'Linear fit of scan points over %s-second range in Vx/Vz space'%fitSeconds)
            chiline.putProperty(QDataSet.DESCRIPTION,'Determined from slope between Vx and Vz*B_hat_x around peak of VDF')
            chiSquaredReduced_chi.putProperty(QDataSet.NAME,'ChiSquared_chi')
            chiSquaredReduced_chi.putProperty(QDataSet.TITLE,'Reduced chi-squared from linear fit determining Chi')
            chiSquaredReduced_psi.putProperty(QDataSet.NAME,'ChiSquared_psi')
            chiSquaredReduced_psi.putProperty(QDataSet.TITLE,'Reduced chi-squared from linear fit determining Psi')
            rSquared_chi.putProperty(QDataSet.NAME,'rSquared_chi')
            rSquared_chi.putProperty(QDataSet.TITLE,'R-squared from linear fit determining Chi')
            rSquared_psi.putProperty(QDataSet.NAME,'rSquared_psi')
            rSquared_psi.putProperty(QDataSet.TITLE,'R-squared from linear fit determining Psi')
            slopeError_chi.putProperty(QDataSet.NAME,'slopeError_chi')
            slopeError_chi.putProperty(QDataSet.TITLE,'Uncertainty in the slope from the linear fit that is Chi')
            slopeError_psi.putProperty(QDataSet.NAME,'slopeError_psi')
            slopeError_psi.putProperty(QDataSet.TITLE,'Uncertainty in the slope from the linear fit that is Psi')
            
            
            formatDataSet(chiline,output_file+'?append=T')
            formatDataSet(psiline,output_file+'?append=T')
            formatDataSet(chiSquaredReduced_chi,output_file+'?append=T')
            formatDataSet(chiSquaredReduced_psi,output_file+'?append=T')
            formatDataSet(rSquared_chi,output_file+'?append=T')
            formatDataSet(rSquared_psi,output_file+'?append=T')
            formatDataSet(slopeError_chi,output_file+'?append=T')
            formatDataSet(slopeError_psi,output_file+'?append=T')
            
            ######
            
    #        (Nx,Ny,Nz) = synchronize(chiline,[Nx,Ny,Nz])
    #        Btotal = synchronize(chiline,[Btotal])[0]   # Since synchronize puts out a list of arrays, use the [0] to choose the array itself
    #
    #        Bunit = bundle(Nx,Ny,Nz)
    #        Bunit.putProperty(QDataSet.NAME,'B_hat')
    #        Bunit.putProperty(QDataSet.TITLE,'Unit vector of background B-field direction using %s-second average'%(trend_seconds))
    #        Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    #        formatDataSet(Bunit,output_file+'?append=T')
    #        Btotal.putProperty(QDataSet.NAME,'B_total')
    #        Btotal.putProperty(QDataSet.TITLE,'Total B-field magnitude')
    #        Btotal.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    #        formatDataSet(Btotal,output_file+'?append=T')
            
            epsilon_chi.putProperty(QDataSet.NAME,'Epsilon_chi')
            epsilon_psi.putProperty(QDataSet.NAME,'Epsilon_psi')
            formatDataSet(epsilon_chi,output_file+'?append=T')
            formatDataSet(epsilon_psi,output_file+'?append=T')
            
            anisotropy_chi.putProperty(QDataSet.NAME,'Anisotropy_chi')
            anisotropy_chi.putProperty(QDataSet.TITLE,'Anisotropy from SPC determined from Vx/Vz fit over %s-second range with %s-second averaged background B-field direction'%(fitSeconds,trend_seconds))
            anisotropy_psi.putProperty(QDataSet.NAME,'Anisotropy_psi')
            anisotropy_psi.putProperty(QDataSet.TITLE,'Anisotropy from SPC determined from Vy/Vz fit over %s-second range with %s-second averaged background B-field direction'%(fitSeconds,trend_seconds))
            
            
            
            
            anisotropy_chi_deltaPlus.putProperty(QDataSet.NAME, 'anisotropy_chi_deltaPlus')
            anisotropy_chi_deltaPlus.putProperty(QDataSet.TITLE, 'DELTA_PLUS values for anisotropy_chi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            anisotropy_chi_deltaMinus.putProperty(QDataSet.NAME, 'anisotropy_chi_deltaMinus')
            anisotropy_chi_deltaMinus.putProperty(QDataSet.TITLE, 'DELTA_MINUS values for anisotropy_chi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            anisotropy_psi_deltaPlus.putProperty(QDataSet.NAME, 'anisotropy_psi_deltaPlus')
            anisotropy_psi_deltaPlus.putProperty(QDataSet.TITLE, 'DELTA_PLUS values for anisotropy_psi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            anisotropy_psi_deltaMinus.putProperty(QDataSet.NAME, 'anisotropy_psi_deltaMinus')
            anisotropy_psi_deltaMinus.putProperty(QDataSet.TITLE, 'DELTA_MINUS values for anisotropy_psi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            formatDataSet(anisotropy_chi,output_file+'?append=T')
            formatDataSet(anisotropy_psi,output_file+'?append=T')
            
            formatDataSet(anisotropy_chi_deltaPlus, output_file+'?append=T')
            formatDataSet(anisotropy_chi_deltaMinus,output_file+'?append=T')
            formatDataSet(anisotropy_psi_deltaPlus, output_file+'?append=T')
            formatDataSet(anisotropy_psi_deltaMinus,output_file+'?append=T')
        
        
        
            print 'Writing Data to CDF took:',TimeUtil.now()-time_fit_begin
            time_last = TimeUtil.now()
        
                
        if separatePeaksWithL3Values == True:
            continue
        
        
        # TODO: Add other peak writing stuff here (copy all from above but with p1 and alphas
        
        
        
        
        #plot(4,epsilonEpoch,epsilon_chi,color='red')
        #plot(5,epsilonEpoch,epsilon_psi,color='blue',ytitle='(&omega;!B&perp;!N/&omega;!B||!N)!U2!N - 1')
        
        #plot(4,epsilonEpoch,anisotropy_chi,color='red',symbol='none')
        #plot(5,epsilonEpoch,anisotropy_psi,color='blue',symbol='none',ytitle='&omega;!B&perp;!N/&omega;!B||!N')
        plot(4,epsilonEpoch,bundle(anisotropy_chi,anisotropy_psi),symbol='none',ytitle='&omega;!B&perp;!N/&omega;!B||!N')
        
        #plot(6,epsilonEpoch,rSquared_chi,color='red',symbol='none')
        #plot(7,epsilonEpoch,rSquared_psi,color='blue',symbol='none',ytitle='R!U2!N of Fit')
        plot(5,epsilonEpoch,bundle(slopeError_chi,slopeError_psi),symbol='none',ytitle='Slope Error of Fit')
        
        
        #plot(6,epsilonEpoch,anisotropy_chi_deltaPlus)
        plot(6,epsilonEpoch,bundle(toDegrees(atan(Nx/Nz)),toDegrees(atan(Ny/Nz))))
        
        
        
        
        #stop
        #
        #epsilon_chi.putProperty(QDataSet.DEPEND_1,mv_lo)
        #epsilon_psi.putProperty(QDataSet.DEPEND_1,mv_lo)
        #
        ##reset()
        #plot(0,totalFlux)
        #plot(3,epsilon_chi,ytitle='&epsilon;&Chi;')
        #plot(4,epsilon_psi,ytitle='&epsilon;&Psi;')
        
    
    except(java.io.FileNotFoundException):
        #if 'noSPCData' in locals():
        print 'DATA FOR %s COULD NOT BE FOUND'%(tr)
        continue

monitor.finished()
