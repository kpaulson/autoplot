


#randomSeed(30)
generatingTotalErrorMap = False
generatingDeltaPlusMinusMaps = True
RunningSingleCase = False

plotVzObservedVDF = True
UseRealisticGaussians = True

length = 500#0#00#000         # Number of points in each maxwellian distribution
numberOfPoints = 50000    # Number of points over which iteration is done (TODO: change this to time with timeUtil().Now)
numberIterations = 10     # Number of times to iterate each set slope and anisotropy measurement in TotalErrorMap
pauseAndPlotCounter = 20  # Number of points to run through before generating each plot

angleMin = -90
angleMax = 90
angleBinNumber = 90       # Number of bins in incident mag angle space

anisotropyMin = 0.03
anisotropyMax = 30
anisotropyBinNumber = 50  # Number of bins in anisotropy space

timeToStopProcessing = '2019-09-04 19:30'   # Time in UT until which the process will run and aggregate data before writing the result (EDT = UT-4)

# Mac
temp_outputMap = '/home/kpaulson/Research/PSP/Anisotropy/TEMP_Anisotropy_DELTA_PLUS-MINUS.cdf'
outputMap = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_DELTA_PLUS-MINUS.cdf'

# PC
#temp_outputMap = 'C:/Users/kpaulson/Google Drive/SPC Anisotropy/Anisotropy_Files/TEMP_Anisotropy_DELTA_PLUS-MINUS.cdf'
#outputMap = 'C:/Users/kpaulson/Google Drive/SPC Anisotropy/Anisotropy_Files/Anisotropy_DELTA_PLUS-MINUS.cdf'



if RunningSingleCase == True or UseRealisticGaussians == True:
    angle = getParam('Bfield_angle',-20,'Incident magnetic field angle relative to z_hat')
    aniso = getParam('Anisotropy',2.3,'Input distribution anisotropy')
    
    
    vz_min = 200   # Taken from bin averages around 2018-11-01 7:52 UT (arbitrarily chosen)
    vz_max = 740
    vx_min = -vz_max*cos(toRadians(28.5))  # Using the maximum measurable incoming flow direction of 28.5 degrees
    vx_max = abs(vx_min)

    factorBulk = 1.
    thermalSpeed_parallel = 50 # Taken from bin averages around 2018-11-01 7:52 UT (arbitrarily chosen)
    velocity_parallel = 325
    density_parallel = 220
    
    thermalSpeed_perp = thermalSpeed_parallel*aniso
    velocity_perp = 130
    density_perp = density_parallel
    
    BackgroundNoiseFactor = 0.3#.1
    
    aniso_beam = 1.2
    factorBeam = 0.4
    
    thermalSpeed_parallel_beam = 20 # Taken from bin averages around 2018-11-01 7:52 UT (arbitrarily chosen)
    velocity_parallel_beam = 460
    density_parallel_beam = 220
    
    thermalSpeed_perp_beam = thermalSpeed_parallel_beam*aniso_beam
    velocity_perp_beam = 2
    density_perp_beam = density_parallel
            
magSlopes = linspace(angleMin,angleMax,angleBinNumber)
anisotropyList = logspace(anisotropyMin,anisotropyMax,anisotropyBinNumber)


from org.apache.commons.math.optimization.fitting import CurveFitter
from org.apache.commons.math.optimization.fitting import ParametricRealFunction
from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer

class LinFit(ParametricRealFunction):
    def value(self, x, params):
        a = params[0]
        b = params[1]
        return (a*x + b)
    def gradient(self, x, params):
        a = params[0]
        b = params[1]
        return [x,1]

#############################
#############################
#############################
#############################

outputMagSlopes              = None
outputAnisotropiesInput      = None
outputAnisotropiesMeasured   = None
chiSquaredMap                   = None
outputMagSlopesMap              = None
outputAnisotropiesInputMap      = None
outputAnisotropiesMeasuredMap   = None

deltaPlus              = None
deltaPlus_dep0         = None
deltaPlus_dep1         = None
deltaMinus             = None
deltaMinus_dep0        = None
deltaMinus_dep1        = None

monitor.started()

counter = 0
if generatingTotalErrorMap == True:
    monitor.setTaskSize(len(magSlopes)*len(anisotropyList)*numberIterations)
    for angle in magSlopes:
        slope = toRadians(angle)
        
        for anisotropy in anisotropyList:
            aniso = anisotropy
            
            clusterUncertainty               = None
            temp_outputAnisotropiesMeasured  = None
            iteration = 0
            while iteration < numberIterations:
                monitor.setTaskProgress(counter)
                try:
                
                    p1 = randomn(long(rand(1)[0]*1E6),length)
                    p2 = randomn(long(rand(1)[0]*1E6),length)*aniso
                    
                    Nz = cos(slope)
                    Nx = sin(slope)
                    
                    p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[70,70],dataset([-5,5]),dataset([-5,5]))\
                    
                    peaks = None
                    peaks1 = None
                    peaks2 = None
                    for i in xrange(len(p1p2_hist)):
                        temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                        temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                        
                        peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                        peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                        
                    
                    
                            
                    inputGuessParams = [0.5,0.5]
                    f = LinFit()
                    ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                    peaks1 = normalize(peaks1)
                    
                    for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0))):
                        ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                        #ftr_chi.addObservedPoint(float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))#,float(ones(len((peaks1)))[i]))
                        
                    result_chi = ftr_chi.fit(f,inputGuessParams)
                       
                    
                    
                    chiline = result_chi[0]
                    print 'chiline:',chiline
                    #print result_chi[1] 
                    
                    
                    epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                    
                    phi = atan(chiline)
                    #print 'ecc:',(tan((slope - phi)/slope))
                    
                    #print '1/epsilon:',1./sqrt(epsilon_chi+1)
                    print 'measured_anisotropy:',sqrt(epsilon_chi+1)
                    print 'input_anisotropy:',aniso
                    
#                    anisotropyDifference = sqrt(epsilon_chi+1) - aniso
#                    if ge(anisotropyDifference.value(),0):
#                        deltaPlus_dep0 = concatenate(deltaPlus_dep0,angle)
#                        deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
#                        deltaPlus = concatenate( deltaPlus , anisotropyDifference )
#                        deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
#                        deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
#                    else:
#                        deltaMinus_dep0 = concatenate(deltaMinus_dep0,angle)
#                        deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
#                        deltaMinus = concatenate( deltaMinus , anisotropyDifference )
#                        deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
#                        deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
                except:
                    continue
                
                
    
                outputMagSlopes = concatenate(outputMagSlopes,angle)
                outputAnisotropiesInput = concatenate(outputAnisotropiesInput,aniso)
                outputAnisotropiesMeasured = concatenate(outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
                temp_outputAnisotropiesMeasured = concatenate(temp_outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
                temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MIN,0)
                temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MAX,1E10)
                
                iteration   = iteration+1  
                counter     = counter+1  
                
            r=where(valid(temp_outputAnisotropiesMeasured))
            chiSquared = total((temp_outputAnisotropiesMeasured[r]-aniso)**2/aniso)/numberIterations
            chiSquaredMap = concatenate(chiSquaredMap,chiSquared)
            outputMagSlopesMap = concatenate(outputMagSlopesMap,angle)
            outputAnisotropiesInputMap = concatenate(outputAnisotropiesInputMap,aniso)
    
    
    ##setLayoutOverplot(5)
    #plot(0,p1p2_hist,colorTable='apl_rainbow_white0',zlog=True,zrange=[1E-2,1E6])
    #plot(1,p1p2_hist.property(QDataSet.DEPEND_0),peaks2,renderType='scatter',symbolSize=7,color='black')
    #
    #line = p1p2_hist.property(QDataSet.DEPEND_0)*tan(slope)
    #plot(2,p1p2_hist.property(QDataSet.DEPEND_0),line,color='red',xrange=[-5,5],yrange=[-5,5],xtitle='Vz',ytitle='Vx',lineWidth=4)
    #plot(3,p1p2_hist.property(QDataSet.DEPEND_0),p1p2_hist.property(QDataSet.DEPEND_0)*result_chi[0],color='blue',lineWidth=4)
    
    outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MIN,0)
    outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MAX,1E10)
    plot(outputAnisotropiesMeasured)
    
    #plot(5,outputMagSlopes,outputAnisotropiesMeasured,outputAnisotropiesMeasured/outputAnisotropiesInput)
    plot(0,outputMagSlopes,outputAnisotropiesMeasured,renderType='scatter',xlog=False,ylog=True,xrange=[-1,91],yrange=[0.08,11])
    plot(1,outputMagSlopesMap,outputAnisotropiesInputMap,chiSquaredMap,renderType='colorScatter',xlog=False,ylog=True,xrange=[-1,91],yrange=[0.08,11])

            
elif generatingDeltaPlusMinusMaps == True:
    monitor.setTaskSize(numberOfPoints)
    monitor.setLabel('Generating Uncertainty Maps')   
    #while counter <= numberOfPoints:
    #while lt(TimeUtil.now(),TimeUtil.parseTime('2019-06-25 13:00')):
    while lt(TimeUtil.now(),datum(timeToStopProcessing)):
        if UseRealisticGaussians == True:
            randAngle = (angleMin + (angleMax-angleMin) * rand(1))
            randAnisotropy = 10.**(log10(anisotropyMin) + (log10(anisotropyMax)-log10(anisotropyMin)) * rand(1))
            #randAnisotropy[0]
            
            slope = toRadians(randAngle)[0]
            aniso = randAnisotropy[0]
            
            monitor.setTaskProgress(counter)
            try: 
                vz_axis = linspace(vz_min,vz_max,length)
                vx_axis = linspace(vx_min,vx_max,length)
    
                c1 = thermalSpeed_parallel
                a1 = density_parallel / (c1*sqrt(PI))
                b1 = 0#velocity_parallel
    
                thermalSpeed_perp = thermalSpeed_parallel*aniso
                c2 = thermalSpeed_perp
                a2 = density_perp / (c2*sqrt(PI))
                b2 = 0#velocity_perp
                
                #These are realistic individually, but need to be centered on same peak if the histogram is to work
                #p1_curve = (a1 * exp( -((vz_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
                #p2_curve = (a2 * exp( -((vx_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
    
                p1_axis = linspace(-800,800,length)
                p2_axis = linspace(-800,800,length)
                p1_curve = (a1 * exp( -((p1_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
                p2_curve = (a2 * exp( -((p2_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
                
                mapNormal = dblarr(p1_curve.length(),p2_curve.length())
                mapNormal_Depend0 = dblarr(p1_curve.length(),p2_curve.length())
                mapNormal_Depend1 = dblarr(p1_curve.length(),p2_curve.length())
                for i in xrange(p1_curve.length()):
                    mapNormal[i,:] = p1_curve[i]*p2_curve
                    for j in xrange(p2_curve.length()):
                        #mapNormal_Depend0[i,j] = (i-(p1_curve.length()/2.))*cos(slope) - (j-(p2_curve.length()/2.))*sin(slope)
                        #mapNormal_Depend1[i,j] = (i-(p1_curve.length()/2.))*sin(slope) + (j-(p2_curve.length()/2.))*cos(slope)
                        mapNormal_Depend0[i,j] = p1_axis[i]*cos(slope) - p2_axis[j]*sin(slope)
                        mapNormal_Depend1[i,j] = p1_axis[i]*sin(slope) + p2_axis[j]*cos(slope)
    
                
                mapNormal_rebin  = rebin( link(mapNormal_Depend0+velocity_parallel,mapNormal_Depend1+velocity_perp,mapNormal) , linspace(vz_min,vz_max,30) , linspace(vx_min,vx_max,250) )
                backgroundNoise = rand(mapNormal_rebin[:,0].length(),mapNormal_rebin[0,:].length())*BackgroundNoiseFactor
                mapNormal_rebin = mapNormal_rebin+backgroundNoise
                
                #plot(1,mapNormal_rebin)
                p1p2_hist = copy(mapNormal_rebin)
                
                p1p2_hist.putProperty(QDataSet.VALID_MIN,0)
                #print p1p2_hist[28,10]
                invalidPoints = where(eq(valid(p1p2_hist),0))
                validPoints = where(valid(p1p2_hist))
                p1p2_hist[invalidPoints] = 0#1E-30
    
        
                Nz = cos(slope)
                Nx = sin(slope)
    
                
                #
                # Peak Identification part:
                #
                
                peaks = None
                peaks1 = None
                peaks2 = None
                for i in xrange(len(p1p2_hist)):
                    temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                    temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                    
                    peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                    peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                    
                
                
                        
                inputGuessParams = [0.5,0.5]
                f = LinFit()
                ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                peaks1 = normalize(peaks1)
                
                goodData = where(ge(peaks1,0.3*max(peaks1)))
                
                for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0)[goodData])):
                    #print float(peaks1[goodData][i])
                    #ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                    ftr_chi.addObservedPoint(float(peaks1[goodData][i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[goodData][i]),float(peaks2[goodData][i]))
                    
                result_chi = ftr_chi.fit(f,inputGuessParams)
                   
                
                
                chiline = result_chi[0]
                #print 'chiline:',chiline
                #print result_chi[1] 
                
                
                epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                #epsilon_chi =  + chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                
                phi = atan(chiline)
                
                #print 'measured_anisotropy:',sqrt(epsilon_chi+1)
                #print 'input_anisotropy:',aniso
                
                
                anisotropyDifference = sqrt(epsilon_chi+1) - aniso
                if le(anisotropyDifference.value(),0):
                    deltaPlus_dep0 = concatenate(deltaPlus_dep0,randAngle[0])
                    deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
                    deltaPlus = concatenate( deltaPlus , -anisotropyDifference )
                    deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
                    deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
                else:
                    deltaMinus_dep0 = concatenate(deltaMinus_dep0,randAngle[0])
                    deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
                    deltaMinus = concatenate( deltaMinus , anisotropyDifference )
                    deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
                    deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
                counter     = counter+1  
                
            except:
                counter     = counter+1  
                continue
            
            
        elif UseRealisticGaussians == False:
    
            randAngle = (angleMin + (angleMax-angleMin) * rand(1))
            randAnisotropy = 10.**(log10(anisotropyMin) + (log10(anisotropyMax)-log10(anisotropyMin)) * rand(1))
            
            slope = toRadians(randAngle)[0]
            aniso = randAnisotropy[0]
            
            monitor.setTaskProgress(counter)
            try:
            
                p1 = randomn(long(rand(1)[0]*1E6),length)
                p2 = randomn(long(rand(1)[0]*1E6),length)*aniso
                
                Nz = cos(slope)
                Nx = sin(slope)
                
                p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[70,70],dataset([-5,5]),dataset([-5,5]))
                
                peaks = None
                peaks1 = None
                peaks2 = None
                for i in xrange(len(p1p2_hist)):
                    temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                    temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                    
                    peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                    peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                    
                
                
                        
                inputGuessParams = [0.5,0.5]
                f = LinFit()
                ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                peaks1 = normalize(peaks1)
                
                for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0))):
                    ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                    #ftr_chi.addObservedPoint(float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))#,float(ones(len((peaks1)))[i]))
                    
                result_chi = ftr_chi.fit(f,inputGuessParams)
                   
                
                
                chiline = result_chi[0]
                #print 'chiline:',chiline
                #print result_chi[1] 
                
                
                epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                
                phi = atan(chiline)
                #print 'ecc:',(tan((slope - phi)/slope))
                
                #print '1/epsilon:',1./sqrt(epsilon_chi+1)
                #print 'measured_anisotropy:',sqrt(epsilon_chi+1)
                #print 'input_anisotropy:',aniso
                
                anisotropyDifference = sqrt(epsilon_chi+1) - aniso
                if le(anisotropyDifference.value(),0):
                    deltaPlus_dep0 = concatenate(deltaPlus_dep0,randAngle[0])
                    deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
                    deltaPlus = concatenate( deltaPlus , -anisotropyDifference )
                    deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
                    deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
                else:
                    deltaMinus_dep0 = concatenate(deltaMinus_dep0,randAngle[0])
                    deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
                    deltaMinus = concatenate( deltaMinus , anisotropyDifference )
                    deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
                    deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
                counter     = counter+1  
                
            except:
                counter     = counter+1  
                continue
                    
        if mod(counter,pauseAndPlotCounter) == 0 and deltaPlus!=None and deltaMinus!=None :     
            monitor.setProgressMessage('Remaining: '+str(datum(timeToStopProcessing) - TimeUtil.now()))    
                 
            
            deltaPlus.putProperty(QDataSet.VALID_MIN,0)
            deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
            deltaPlus.putProperty(QDataSet.NAME,'DELTA_PLUS')
            deltaPlus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
            deltaPlus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
            deltaMinus.putProperty(QDataSet.VALID_MIN,0)
            deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
            deltaMinus.putProperty(QDataSet.NAME,'DELTA_MINUS')
            deltaMinus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
            deltaMinus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
            
            deltaPlusLink  = link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus)
            deltaMinusLink = link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus)
            deltaPlusLink.putProperty(QDataSet.NAME,'Anisotropy DELTA_PLUS')
            deltaMinusLink.putProperty(QDataSet.NAME,'Anisotropy DELTA_MINUS')
            
            # This commented section is left over from plotting the results as a spectrogram before the rebinning was fixed
            #plot(0,link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus),renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_PLUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
            #plot(1,link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus),xtitle='Incident MAG Angle',renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_MINUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
            
            
            deltaPlusRebin  = rebin(deltaPlusLink,magSlopes,anisotropyList)
            deltaMinusRebin = rebin(deltaMinusLink,magSlopes,anisotropyList)
            
            anisotropyArray = dblarr(len(deltaPlusRebin[:,0]),len(deltaPlusRebin[0,:]))
            for i in xrange(len(deltaPlusRebin[:,0])):
                anisotropyArray[i,:] = anisotropyList
                
            plot(0,deltaPlusRebin/anisotropyArray,colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E0,1E2],ztitle='DELTA_PLUS Percentage',zlog=True)
            plot(1,deltaMinusRebin/anisotropyArray,xtitle='Incident MAG Angle',colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E0,1E2],ztitle='DELTA_MINUS Percentage',zlog=True)
            #plot(1,anisotropyArray)
            
            formatDataSet( deltaPlusLink   , temp_outputMap )
            formatDataSet( deltaMinusLink  , temp_outputMap+'?append=T' )
            formatDataSet( deltaPlusRebin  , temp_outputMap+'?append=T' )
            formatDataSet( deltaMinusRebin , temp_outputMap+'?append=T' )
      
    deltaPlus.putProperty(QDataSet.VALID_MIN,0)
    deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
    deltaPlus.putProperty(QDataSet.NAME,'DELTA_PLUS')
    deltaPlus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
    deltaPlus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
    deltaMinus.putProperty(QDataSet.VALID_MIN,0)
    deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
    deltaMinus.putProperty(QDataSet.NAME,'Anisotropy DELTA_MINUS')
    deltaMinus.putProperty(QDataSet.NAME,'DELTA_MINUS')
    deltaMinus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
    deltaMinus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
            
    deltaPlusLink  = link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus)
    deltaMinusLink = link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus)
    deltaPlusLink.putProperty(QDataSet.NAME,'Anisotropy DELTA_PLUS')
    deltaMinusLink.putProperty(QDataSet.NAME,'Anisotropy DELTA_MINUS')
    
    # This commented section is left over from plotting the results as a spectrogram before the rebinning was fixed
    #plot(0,link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus),renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_PLUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
    #plot(1,link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus),xtitle='Incident MAG Angle',renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_MINUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
    
    deltaPlusRebin  = rebin(deltaPlusLink ,magSlopes,anisotropyList)
    deltaMinusRebin = rebin(deltaMinusLink,magSlopes,anisotropyList)
            
    anisotropyArray = dblarr(len(deltaPlusRebin[:,0]),len(deltaPlusRebin[0,:]))
    for i in xrange(len(deltaPlusRebin[:,0])):
        anisotropyArray[i,:] = anisotropyList
    
    deltaPlusRebin.putProperty(QDataSet.VALID_MIN,0)
    deltaPlusRebin.putProperty(QDataSet.VALID_MAX,1E10)
    deltaPlusRebin.putProperty(QDataSet.NAME,'UncertaintyMap DELTA_PLUS')
    deltaMinusRebin.putProperty(QDataSet.VALID_MIN,0)
    deltaMinusRebin.putProperty(QDataSet.VALID_MAX,1E10)
    deltaMinusRebin.putProperty(QDataSet.NAME,'UncertaintyMap DELTA_MINUS')
    
    plot(0,deltaPlusRebin/anisotropyArray,colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-1,1E2],ztitle='DELTA_PLUS Percentage',zlog=True)
    plot(1,deltaMinusRebin/anisotropyArray,xtitle='Incident MAG Angle',colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-1,1E2],ztitle='DELTA_MINUS Percentage',zlog=True)
        
  
    formatDataSet( deltaPlusLink   , outputMap )
    formatDataSet( deltaMinusLink  , outputMap+'?append=T' )
    formatDataSet( deltaPlusRebin  , outputMap+'?append=T' )
    formatDataSet( deltaMinusRebin , outputMap+'?append=T' )
    
    
elif RunningSingleCase == True:
    #monitor.setTaskSize(len(magSlopes)*len(anisotropyList)*numberIterations)
    #for angle in magSlopes:
        
    slope = toRadians(angle)
        
    
    clusterUncertainty               = None
    temp_outputAnisotropiesMeasured  = None
    iteration = 0
    while iteration < numberIterations:
        monitor.setTaskProgress(counter)
        #try:
        if True:
            
            
            
            vz_axis = linspace(vz_min,vz_max,length)
            vx_axis = linspace(vx_min,vx_max,length)

            c1 = thermalSpeed_parallel
            a1 = density_parallel / (c1*sqrt(PI))
            b1 = 0#velocity_parallel

            c2 = thermalSpeed_perp
            a2 = density_perp / (c2*sqrt(PI))
            b2 = 0#velocity_perp
            
            #These are realistic individually, but need to be centered on same peak if the histogram is to work
            #p1_curve = (a1 * exp( -((vz_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
            #p2_curve = (a2 * exp( -((vx_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)

            p1_axis = linspace(-800,800,length)
            p2_axis = linspace(-800,800,length)
            p1_curve = (a1 * exp( -((p1_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
            p2_curve = (a2 * exp( -((p2_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
            
            mapNormal = dblarr(p1_curve.length(),p2_curve.length())
            mapNormal_Depend0 = dblarr(p1_curve.length(),p2_curve.length())
            mapNormal_Depend1 = dblarr(p1_curve.length(),p2_curve.length())
            for i in xrange(p1_curve.length()):
                mapNormal[i,:] = p1_curve[i]*p2_curve
                for j in xrange(p2_curve.length()):
                    #mapNormal_Depend0[i,j] = (i-(p1_curve.length()/2.))*cos(slope) - (j-(p2_curve.length()/2.))*sin(slope)
                    #mapNormal_Depend1[i,j] = (i-(p1_curve.length()/2.))*sin(slope) + (j-(p2_curve.length()/2.))*cos(slope)
                    mapNormal_Depend0[i,j] = p1_axis[i]*cos(slope) - p2_axis[j]*sin(slope)
                    mapNormal_Depend1[i,j] = p1_axis[i]*sin(slope) + p2_axis[j]*cos(slope)
            #plot(mapNormal)
            
            #slope = toRadians(24)
            #mapNormal.putProperty(QDataSet.DEPEND_0,mapNormal_Depend0)
            #mapNormal.putProperty(QDataSet.DEPEND_1,mapNormal_Depend1)
            #mapNormal = transpose(mapNormal)
            #mapNormal.putProperty(QDataSet.DEPEND_1,mapNormal_Depend0)
            #mapNormal = transpose(mapNormal)
            #print mapNormal.property(QDataSet.DEPEND_0)
            
            mapNormal_rebin  = rebin( link(mapNormal_Depend0+velocity_parallel,mapNormal_Depend1+velocity_perp,mapNormal) , linspace(vz_min,vz_max,30) , linspace(vx_min,vx_max,250) )
            backgroundNoise = rand(mapNormal_rebin[:,0].length(),mapNormal_rebin[0,:].length())*BackgroundNoiseFactor
            mapNormal_rebin = mapNormal_rebin+backgroundNoise
            
            #plot(1,mapNormal_rebin)
            p1p2_hist = copy(mapNormal_rebin)
            
            p1p2_hist.putProperty(QDataSet.VALID_MIN,0)
            #print p1p2_hist[28,10]
            invalidPoints = where(eq(valid(p1p2_hist),0))
            validPoints = where(valid(p1p2_hist))
            p1p2_hist[invalidPoints] = 0#1E-30
            #print p1p2_hist[28,10]
            
#            plot(1,p1p2_hist)
#            tempTotals = dblarr(len(p1p2_hist))
#            for i in xrange(p1p2_hist[:,0].length()):
#                print p1p2_hist[i,0]
#                tempTotals[i] = total(p1p2_hist[i,:])
#            plot(2,tempTotals)
#            stop
#
#            time1 = TimeUtil.now()
#            p1 = None
#            p2 = None
##            for i in xrange(length):
##                for j in xrange(int(p1_curve[i]*1E1)):
##                    p1 = concatenate(p1,vz_axis[i])
##                for j in xrange(int(p2_curve[i]*1E1)):
##                    p2 = concatenate(p2,vx_axis[i])
#            for i in xrange(length):
#                for j in xrange(int(p1_curve[i])):
#                    p1 = concatenate(p1,p1_axis[i])
#                for j in xrange(int(p2_curve[i])):
#                    p2 = concatenate(p2,p2_axis[i])
#
#            if gt( p1.length() , p2.length() ):
#                temp_p2 = copy(p2)
#                p2 = dblarr(p1.length())
#                p2[0:temp_p2.length()] = temp_p2
#            else:
#                temp_p1 = copy(p1)
#                p1 = dblarr(p2.length())
#                p1[0:temp_p1.length()] = temp_p1
#            print 'Time taken:',TimeUtil.now()-time1
#            #plot(vz_axis,p1_curve)
#            #plot(p1_curve)
#            #p2 = synchronize(p1,p2)
#            #plot(0,p2)
#            #plot(1,p1)
#            #plot(0,p1_curve)
#            #plot(1,p2_curve)
#            p1_random = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_parallel+velocity_parallel
#            p2_random = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_perp + velocity_perp
#            #p1 = synchronize(p1_random,p1)
#            plot(0,p1)
#            plot(1, p2 )
#            plot(0,histogram(p1,10))
#            plot(1, histogram(p2,10) )
#
#            p1 = p1_random
#            p2 = p2_random
#
#            p1p2_hist = histogram2d((p1*cos(slope)-p2*sin(slope))+velocity_parallel,(p2*cos(slope)+p1*sin(slope))+velocity_perp,[130,160],dataset([vz_min,vz_max]),dataset([vx_min,vx_max]))
#            p1p2_hist = histogram2d((p1*cos(slope)-p2*sin(slope)),(p2*cos(slope)+p1*sin(slope)),[130,160],dataset([-vz_min,vz_max]),dataset([vx_min,vx_max]))
#            plot(2,p1p2_hist)
#            STOP
#
#            #p2 = ones(length)
#
#
#            #distribution = dblarr(len(p1),len(p2))
#            #for i in xrange(len(p1)):
#            #    for j in xrange(len(p2)):
#            #        distribution[i,j] = p1[i]*p2[j]
#                    #distribution[i,j] = p1[int(i+i*cos(slope))]*p2[j]
#                    #distribution[i,j] = (p1[i]*cos(slope)+p2[j]*sin(slope))*(p2[j]*cos(slope)+p1[i]*sin(slope))
#            #plot(vz_axis,vx_axis,distribution+(rand(length,length)*0.2))
#            #stop
#
#            p1_normal = randomn(long(rand(1)[0]*1E6),length)
#            p2_normal = randomn(long(rand(1)[0]*1E6),length)*aniso
#            #p1_normal = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_parallel + velocity_parallel
#            #p2_normal = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_perp + velocity_perp
#
            Nz = cos(slope)
            Nx = sin(slope)
#
#            p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[32,32],dataset([-5,5]),dataset([-5,5]))
#            #p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[32,32],dataset([vz_min,vz_max]),dataset([vx_min,vx_max]))
#
#            p1p2_hist = rebin( link(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),ones(len(p1))) , linspace(vz_min,vz_max,30)   , linspace(vx_min,vx_max,30) ).property(QDataSet.WEIGHTS)
#            p1p2_hist = rebin( link(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),ones(len(p1))) , linspace(-100,vz_max,3000)   , linspace(vx_min,vx_max,3000) ).property(QDataSet.WEIGHTS)
#            #p1p2_normal_hist = rebin( link(p1_normal*cos(slope)-p2_normal*sin(slope),p2_normal*cos(slope)+p1_normal*sin(slope),ones(len(p1))) , linspace(-100,vz_max,3000)   , linspace(vx_min,vx_max,3000) ).property(QDataSet.WEIGHTS)
#            p1p2_normal_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[300,300],dataset([-10,7]),dataset([-20,20]))
#            plot(p1p2_normal_hist)
#            #plot(p1p2_hist)
#            #plot(vz_axis,p1)
#            #plot(p1)
#            #plot(p1_normal)
#            #plot(vx_axis,p2)
#
#
#            #p1 = randomn(long(rand(1)[0]*1E6),length)
#            #p2 = randomn(long(rand(1)[0]*1E6),length)*aniso
#            p1 = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_parallel# + rand(length)*0.1
#            p2 = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_perp# + rand(length)*0.1
#
#            p1 = p1[sort(p1)]
#            p2 = p2[sort(p2)]
#
#            p1_beam = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_parallel_beam
#            p2_beam = randomn(long(rand(1)[0]*1E6),length)*thermalSpeed_perp_beam
#
#            Nz = cos(slope)
#            Nx = sin(slope)
#
#            p1p2_hist = histogram2d((p1*cos(slope)-p2*sin(slope))+velocity_parallel,(p2*cos(slope)+p1*sin(slope))+velocity_perp,[30,150],dataset([vz_min,vz_max]),dataset([vx_min,vx_max]))
#            p1p2_hist_beam = histogram2d((p1_beam*cos(slope)-p2_beam*sin(slope))+velocity_parallel_beam,(p2_beam*cos(slope)+p1_beam*sin(slope))+velocity_perp_beam,[30,150],dataset([vz_min,vz_max]),dataset([vx_min,vx_max]))
#            #p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[70,70],dataset([-5,5]),dataset([-5,5]))
#
#            p1p2_hist = (p1p2_hist)*factorBulk + (p1p2_hist_beam)*factorBeam
#            #plot(p1p2_hist+(p1p2_hist_beam)*0.6)
#            #stop
            
            
            #
            # Peak Identification part:
            #
            
            peaks = None
            peaks1 = None
            peaks2 = None
            for i in xrange(len(p1p2_hist)):
                temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                
                peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                
            
            
                    
            inputGuessParams = [0.5,0.5]
            f = LinFit()
            ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
            peaks1 = normalize(peaks1)
            
            goodData = where(ge(peaks1,0.3*max(peaks1)))
            
            for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0)[goodData])):
                print float(peaks1[goodData][i])
                #ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                ftr_chi.addObservedPoint(float(peaks1[goodData][i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[goodData][i]),float(peaks2[goodData][i]))
                
            result_chi = ftr_chi.fit(f,inputGuessParams)
               
            
            
            chiline = result_chi[0]
            #print 'chiline:',chiline
            #print result_chi[1] 
            
            
            epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
            #epsilon_chi =  + chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
            
            phi = atan(chiline)
            #print 'ecc:',(tan((slope - phi)/slope))
            
            #print '1/epsilon:',1./sqrt(epsilon_chi+1)
            print 'measured_anisotropy:',sqrt(epsilon_chi+1)
            print 'input_anisotropy:',aniso
            
#                    anisotropyDifference = sqrt(epsilon_chi+1) - aniso
#                    if ge(anisotropyDifference.value(),0):
#                        deltaPlus_dep0 = concatenate(deltaPlus_dep0,angle)
#                        deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
#                        deltaPlus = concatenate( deltaPlus , anisotropyDifference )
#                        deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
#                        deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
#                    else:
#                        deltaMinus_dep0 = concatenate(deltaMinus_dep0,angle)
#                        deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
#                        deltaMinus = concatenate( deltaMinus , anisotropyDifference )
#                        deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
#                        deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
        #except:
        #    iteration   = iteration+1  
        #    continue
        
        

        outputMagSlopes = concatenate(outputMagSlopes,angle)
        outputAnisotropiesInput = concatenate(outputAnisotropiesInput,aniso)
        outputAnisotropiesMeasured = concatenate(outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
        temp_outputAnisotropiesMeasured = concatenate(temp_outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
        temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MIN,0)
        temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MAX,1E10)
        
        iteration   = iteration+1  
        counter     = counter+1  
        
    r=where(valid(temp_outputAnisotropiesMeasured))
    chiSquared = total((temp_outputAnisotropiesMeasured[r]-aniso)**2/aniso)/numberIterations
    #chiSquaredMap = concatenate(chiSquaredMap,chiSquared)
    #outputMagSlopesMap = concatenate(outputMagSlopesMap,angle)
    #outputAnisotropiesInputMap = concatenate(outputAnisotropiesInputMap,aniso)
    
    
    setLayoutOverplot(5)
    plot(0,p1p2_hist,colorTable='apl_rainbow_white0',zlog=True,zrange=[1E-2,1E1])
    plot(1,p1p2_hist.property(QDataSet.DEPEND_0),peaks2,renderType='scatter',symbolSize=7,color='black')
    #plot(1,p1p2_hist.property(QDataSet.DEPEND_0),peaks2,p1p2_hist[:,peaks2],renderType='colorScatter',symbolSize=7)
    
    line = p1p2_hist.property(QDataSet.DEPEND_0)*tan(slope)
    if RunningSingleCase == True:
        line = p1p2_hist.property(QDataSet.DEPEND_0)*tan(slope)-((velocity_parallel*tan(slope))-velocity_perp)
        
    plot(2,p1p2_hist.property(QDataSet.DEPEND_0),line,color='red',xrange=[vz_min,vz_max],yrange=[vx_min,vx_max],xtitle='Vz',ytitle='Vx',lineWidth=4)
    plot(3,p1p2_hist.property(QDataSet.DEPEND_0),p1p2_hist.property(QDataSet.DEPEND_0)*result_chi[0]+result_chi[1],color='blue',lineWidth=4)
    if plotVzObservedVDF == True:
        tempTotals = dblarr(len(p1p2_hist))
        for i in xrange(p1p2_hist[:,0].length()):
            #print p1p2_hist[i,0]
            tempTotals[i] = total(p1p2_hist[i,:])
        plot(5,p1p2_hist.property(QDataSet.DEPEND_0),tempTotals)
        #plot(5,total(p1p2_hist,1))
    
monitor.finished()

###############################
###############################
###############################
