

# ############################################################################################ 


def field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds ):
    """Routine used to define field-aligned coordinate system by smoothing over given magnetic field data.
	
	Parameters:
	    Bx = rank1 X component of magnetic field
		By = rank1 Y component of magnetic field
		Bz = rank1 Z component of magnetic field
		TEMP_Rx = rank1 X component of radial s/c position (in same coord system as B)
		TEMP_Ry = rank1 Y component of radial s/c position (in same coord system as B)
		TEMP_Rz = rank1 Z component of radial s/c position (in same coord system as B)
		trend_seconds = rank0 number of seconds over which to average B to define as background
		
    Returns:
	    (Bn , Bp , Bq) = rank1 collection of Magnetic Field components in field-aligned system.
		(Nx , Ny , Nz) = rank1 collection of Magnetic Field direction components in original coord system.
		(Px , Py , Pz) = rank1 collection of Quasi-Radial direction components in original coord system.
		(Qx , Qy , Qz) = rank1 collection of Quasi-Azimuthal direction components in original coord system.
	
	"""
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_smooth = smooth(Bx,smooth_points)
    By_smooth = smooth(By,smooth_points)
    Bz_smooth = smooth(Bz,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_smooth / Btotal_smooth
    Ny = By_smooth / Btotal_smooth
    Nz = Bz_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    
    ephem_time = TEMP_Rx.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    TEMP_Rx = interpolate( TEMP_Rx, ephem_to_mag_ratio )
    TEMP_Ry = interpolate( TEMP_Ry , ephem_to_mag_ratio )
    TEMP_Rz = interpolate( TEMP_Rz , ephem_to_mag_ratio )
    
    TEMP_Rmag = sqrt(TEMP_Rx**2 + TEMP_Ry**2 + TEMP_Rz**2)
    
    Rx = -(TEMP_Rx/TEMP_Rmag) #Negate R so that NxR is westwards (need this for right-handedness)
    Ry = -(TEMP_Ry/TEMP_Rmag) 
    Rz = -(TEMP_Rz/TEMP_Rmag) 
    
    TEMP_Px = ( Ny * Rz ) - ( Nz * Ry )
    TEMP_Py = ( Nz * Rx ) - ( Nx * Rz )
    TEMP_Pz = ( Nx * Ry ) - ( Ny * Rx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # N x P ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx * Nx) + (By * Ny) + (Bz * Nz)
    Bp = (Bx * Px) + (By * Py) + (Bz * Pz)
    Bq = (Bx * Qx) + (By * Qy) + (Bz * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
#    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
#    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
#    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
#    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;x!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;x!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;y!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;y!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )
    
    



############################################################################

#plot(3,mv_hi-mv_lo)

#dqf = getDataSet('http://sweap.cfa.harvard.edu/data/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?DQF&timerange=2018-307+9:00+to+18:00')
#
#for j in xrange(len(dqf[0,:])):
#    print dqf[:,j]
    
tr = '2018-11-03 18:33 to 18:39'
tr = '2018-11-02 16:45 to 17:20'
tr = '2019-04-01 07:00 to 10:00'
tr = '2018-11-04 05:00 to 06:00'
#tr = '2019-04-01 08:00 to 08:15'
#tr = '2018-10-30 19:10 to 19:40'

plotFitsAndPauseALot = True

m_p               = 1.6726231E-24
trend_seconds     = 30     # Number of seconds over which to average magField to determine background field direction

cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'
    
spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)

mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)

#plot(0,mv_hi-mv_lo)
#stop

#print spc_a

spc_list = [spc_a,spc_b,spc_c,spc_d]

#for l in spc_list:
#    trim(l,tr)
    
#print spc_a

spc_a = trim(spc_a,tr)
spc_b = trim(spc_b,tr)
spc_c = trim(spc_c,tr)
spc_d = trim(spc_d,tr)

mv_lo = trim(mv_lo,tr)
mv_hi = trim(mv_hi,tr)
#print spc_a


#spc_a = putProperty(spc_a/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
#spc_b = putProperty(spc_b/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
#spc_c = putProperty(spc_c/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
#spc_d = putProperty(spc_d/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
spc_list = [spc_a,spc_b,spc_c,spc_d]
#spc_list = [spc_a/(mv_hi-mv_lo),spc_b/(mv_hi-mv_lo),spc_c/(mv_hi-mv_lo),spc_d/(mv_hi-mv_lo)]
i=0
#for l in spc_list:
#    plot(i,l)
#    i = i+1
#STOP
totalFlux = sum(spc_list)
#totalFlux = totalFlux/((mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo))

fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])

U = (fluxDifference_scy/totalFlux)/0.035
V = (fluxDifference_scx/totalFlux)/0.035

U.putProperty(QDataSet.VALID_MIN,None)
V.putProperty(QDataSet.VALID_MIN,None)
U.putProperty(QDataSet.VALID_MAX,None)
V.putProperty(QDataSet.VALID_MAX,None)

#r0 = where(valid(U)) *(-1) + 1
#U[r0] = -180
#r0 = where(valid(V)) *(-1) + 1
#V[r0] = -180

for j in xrange(len(U[0,:])):
    try:
        U[:,j] = medianFilter(U[:,j],3)
    except:
        continue
    try:
        V[:,j] = medianFilter(V[:,j],3)
    except:
        continue

U.putProperty(QDataSet.UNITS,Units.degrees)
V.putProperty(QDataSet.UNITS,Units.degrees)

#plot(0,totalFlux)
#plot(1,U)
#plot(2,V)

#totalFlux = totalFlux / (mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo)
totalFlux = totalFlux/( (mv_hi-mv_lo))
totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
peaks = reduceMax(totalFlux,1)
r = where(eq(totalFlux,peaks))

mainFlowYsc = U[r]  # Mike's routine calls this azimuth (and is negative)
mainFlowXsc = V[r]  # Mike's routine calls this elevation

#mainFlowU = smooth1(U,3)[r]
#mainFlowV = smooth1(V,3)[r]

#plot(3,mainFlowYsc,ytitle='Ysc Deflection')
#plot(4,mainFlowXsc,ytitle='Xsc Deflection')


###

#fluxDifference_agyro = (spc_list[0]+spc_list[2]) - (spc_list[1]+spc_list[3])
#W = (fluxDifference_agyro/totalFlux)/0.035
#
#W.putProperty(QDataSet.VALID_MIN,None)
#W.putProperty(QDataSet.VALID_MAX,None)
#for j in xrange(len(W[0,:])):
#    try:
#        W[:,j] = medianFilter(W[:,j],3)
#    except:
#        continue
        
#plot(5,W)

####

# chi = (v_z2-v_z1) / (v_z2*tan(phi2) - v_z1*tan(phi1))
# V_lo < 0.5*m*v^2 < V_hi

v_z2 = mv_hi
v_z1 = mv_lo 
v_z = sqrt( (2/m_p) * (mv_lo + (mv_hi-mv_lo)/2) )    # in cm/s
v_z = sqrt( (2/m_p) * (mv_lo + (mv_hi-mv_lo)/2) ) / 1.E5   # in km/s
#plot(v_z)
#stop

vz_tanPhi   = v_z * tan(toRadians(U))     # Vy
vz_tanTheta = v_z * tan(toRadians(V))     # Vx
#plot(vz_tanPhi)
#stop


chi = zeros(len(U[:,0]),len(U[0,:]))
psi = zeros(len(U[:,0]),len(U[0,:]))
#for i in xrange(len(U[:,0])):
#    chi[i] = diff(v_z[i,:]) / diff(vz_tanPhi[i,:])
#    psi[i] = diff(v_z[i,:]) / diff(vz_tanTheta[i,:])

#v_z.putProperty(QDataSet.DEPEND_1,mv_lo)  

###
# Define upper point
r_lower = copy(r)
r_lower[:,1] = r[:,1]-2
r_upper = copy(r)
r_upper[:,1] = r[:,1]+2
#plot(chi)

#setLayoutOverplot(4) 

#plot(0,totalFlux)
plot(0,totalFlux,colorTable='apl_rainbow_black0')
upperBound = dblarr(len(totalFlux))
upperBound = mv_lo[r_upper]
lowerBound = dblarr(len(totalFlux))
lowerBound = mv_lo[r_lower]
plot(1,upperBound)
plot(2,lowerBound)


from org.apache.commons.math.optimization.fitting import CurveFitter
from org.apache.commons.math.optimization.fitting import ParametricRealFunction
from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer
from org.apache.commons.math.stat.regression      import SimpleRegression

class LinFit(ParametricRealFunction):
    def value(self, x, params):
        a = params[0]
        b = params[1]
        return (a*x + b)
    def gradient(self, x, params):
        a = params[0]
        b = params[1]
        return [x,1]
####################

mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)

#mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
mag = trim(mag,tr)

mag_time = mag.property(QDataSet.DEPEND_0)

pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
pos_time = pos.property(QDataSet.DEPEND_0)

Bx = mag[:,0]
By = mag[:,1]
Bz = mag[:,2]
Btotal = magnitude(mag)

TEMP_Rx = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
TEMP_Ry = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
TEMP_Rz = putProperty(ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)


( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )

(Nx_temp,Ny_temp,Nz_temp) = synchronize(totalFlux,[Nx,Ny,Nz])
#################


inputGuessParams = [float(rand(1)[0]),float(rand(1)[0])]            
chiline                = None
psiline                = None
epsilonEpoch           = None
chiSquaredReduced_chi  = None
chiSquaredReduced_psi  = None
dds= generateTimeRanges('$Y-$m-$d $H:$M:$(S,span=10)',tr)
dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$(S,span=10)',tr)
for ind in xrange(len(dds)-1):
    tr_dds = dds[ind]+' to '+dds[ind+1]
    plot(3,datumRange(tr_dds),renderType='eventsBar',color='magenta')
    
    v_z_dd = trim(v_z,tr_dds)
    vz_tanPhi_dd = trim(vz_tanPhi,tr_dds)
    vz_tanTheta_dd = trim(vz_tanTheta,tr_dds)
    #vz_tanTheta_dd = trim(vz_tanTheta,'%s to %s'%())
    totalFlux_dd = trim(totalFlux,tr_dds)
    Nx_temp_dd = trim(Nx_temp,tr_dds)
    Ny_temp_dd = trim(Ny_temp,tr_dds)
    
    temp_v_z = None
    temp_vz_tanTheta = None
    temp_vz_tanPhi = None
    temp_totalFlux = None
    temp_Nx_temp_dd = None
    temp_Ny_temp_dd = None
    for i in xrange(len(v_z_dd)):
        temp_v_z         = concatenate(temp_v_z,v_z_dd[i,:])
        temp_vz_tanPhi   = concatenate(temp_vz_tanPhi,vz_tanPhi_dd[i,:])
        temp_vz_tanTheta = concatenate(temp_vz_tanTheta,vz_tanTheta_dd[i,:])
        temp_totalFlux   = concatenate(temp_totalFlux,totalFlux_dd[i,:])
        temp_Nx_temp_dd  = concatenate(temp_Nx_temp_dd,ones(len(v_z_dd[i,:]))*Nx_temp_dd[i])
        temp_Ny_temp_dd  = concatenate(temp_Ny_temp_dd,ones(len(v_z_dd[i,:]))*Ny_temp_dd[i])
    #plot(8,temp_Nx_temp_dd[where(valid(temp_v_z))])
    #plot(9,indgen(341),temp_v_z[where(valid(temp_v_z))]),temp_Nx_temp_dd[where(valid(temp_v_z))])
        
    norm_temp_totalFlux = normalize(temp_totalFlux)
    r = where(ge(temp_totalFlux,0.5).and(valid(temp_totalFlux)))  # Removes points from the measurement below a particular threschhold
    r = where(ge(temp_totalFlux,0.5).and(valid(temp_totalFlux)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
    

    f = LinFit()
    ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
    ftr_psi = CurveFitter(LevenbergMarquardtOptimizer())
    
    regr_chi = SimpleRegression()
    regr_psi = SimpleRegression()

    for i in xrange(len(temp_v_z[r])):
        ftr_chi.addObservedPoint(float(norm_temp_totalFlux[r][i]),float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]),float(temp_vz_tanPhi[r][i]))
        ftr_psi.addObservedPoint(float(norm_temp_totalFlux[r][i]),float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]),float(temp_vz_tanTheta[r][i]))
        
        #regr_chi.addObservedPoint(float(norm_temp_totalFlux[r][i]),float(temp_v_z[r][i]*temp_Nx_temp_dd[i]),float(temp_vz_tanPhi[r][i]))
        #regr_psi.addObservedPoint(float(norm_temp_totalFlux[r][i]),float(temp_v_z[r][i]*temp_Ny_temp_dd[i]),float(temp_vz_tanTheta[r][i]))
        
    result_chi = ftr_chi.fit(f,inputGuessParams)
    result_psi = ftr_psi.fit(f,inputGuessParams)
#    print 'slope:',result[0]
#    print 'offset:',result[1]
    
    #xx = linspace( min(temp_v_z[r][where(valid(temp_v_z[r]))]) , max(temp_v_z[r][where(valid(temp_v_z[r]))]) , 100)
    xx_x = linspace( min((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
    xx_y = linspace( min((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)

    
    psiline = concatenate(psiline,result_psi[0])
    chiline = concatenate(chiline,result_chi[0])
    
    temp_chiSquaredReduced_chi = abs(total( ( temp_vz_tanPhi[r] - (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) )**2 / (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) ) ) / len(temp_v_z[r])
    temp_chiSquaredReduced_psi = abs(total( ( temp_vz_tanTheta[r] - (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) )**2 / (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) ) ) / len(temp_v_z[r])
    chiSquaredReduced_chi = concatenate(chiSquaredReduced_chi,temp_chiSquaredReduced_chi)
    chiSquaredReduced_psi = concatenate(chiSquaredReduced_psi,temp_chiSquaredReduced_psi)
    
    epsilonEpoch = concatenate(epsilonEpoch,datum(dds[ind])+(datum(dds[ind+1])-datum(dds[ind]))/2.)
    if plotFitsAndPauseALot == True:
        plot(6,temp_v_z[r]*temp_Nx_temp_dd[r],temp_vz_tanPhi[r]  ,norm_temp_totalFlux[r],renderType='colorScatter')
        plot(4,temp_v_z[r]*temp_Ny_temp_dd[r],temp_vz_tanTheta[r],norm_temp_totalFlux[r],renderType='colorScatter')
        plot(5,xx_y,(result_psi[0]*xx_y + result_psi[1]),color='red',xtitle=tr_dds,title=str(mean(Ny_temp_dd)))
        plot(7,xx_x,(result_chi[0]*xx_x + result_chi[1]),color='red',xtitle=tr_dds,title=str(mean(Nx_temp_dd)))
        sleep(1000)
psiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
chiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
chiSquaredReduced_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
chiSquaredReduced_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
#plot(8,psiline)
#stop

output_file = '/home/kpaulson/Research/PSP/Anisotropy/TEMPfits_fromMath_%s.cdf'%(dds_title[0]+'_to_'+dds_title[-1])
output_file = 'D:/Research/ParkerProbe/SWEAP/SPC/Anisotropy/TEMPfits_fromMath_%s.cdf'%(dds_title[0]+'_to_'+dds_title[-1])

psiline.putProperty(QDataSet.NAME,'Psi')
psiline.putProperty(QDataSet.DESCRIPTION,'Linear fit of scan points over 10-second range in Vy/Vz space')
chiline.putProperty(QDataSet.NAME,'Chi')
chiline.putProperty(QDataSet.DESCRIPTION,'Linear fit of scan points over 10-second range in Vx/Vz space')
chiSquaredReduced_chi.putProperty(QDataSet.NAME,'ChiSquared_chi')
chiSquaredReduced_chi.putProperty(QDataSet.DESCRIPTION,'Reduced chi-squared from linear fit determining Chi')
chiSquaredReduced_psi.putProperty(QDataSet.NAME,'ChiSquared_psi')
chiSquaredReduced_psi.putProperty(QDataSet.DESCRIPTION,'Reduced chi-squared from linear fit determining Psi')

formatDataSet(psiline,output_file)
formatDataSet(chiline,output_file+'?append=T')
formatDataSet(chiSquaredReduced_chi,output_file+'?append=T')
formatDataSet(chiSquaredReduced_psi,output_file+'?append=T')


#plot(1,v_z[r])
#plot(2,chi[r-1])
#plot(2,v_z[r_upper])
#plot(r)

#chiline = (v_z[r_upper]-v_z[r_lower]) / (vz_tanPhi[r_upper] - vz_tanPhi[r_lower])
#psiline = (v_z[r_upper]-v_z[r_lower]) / (vz_tanTheta[r_upper] - vz_tanTheta[r_lower])

#plot(3,chiline)
#plot(4,psiline)
#stop

#mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
#mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
#
##mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
#mag = trim(mag,tr)
#
#mag_time = mag.property(QDataSet.DEPEND_0)
#
#pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
#pos_time = pos.property(QDataSet.DEPEND_0)
#
#Bx = mag[:,0]
#By = mag[:,1]
#Bz = mag[:,2]
#Btotal = magnitude(mag)
#
#TEMP_Rx = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
#TEMP_Ry = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
#TEMP_Rz = putProperty(ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)
#
#
#( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )

(Nx,Ny,Nz) = synchronize(chiline,[Nx,Ny,Nz])

Bunit = bundle(Nx,Ny,Nz)
Bunit.putProperty(QDataSet.NAME,'B_hat')
Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
formatDataSet(Bunit,output_file+'?append=T')

#epsilon_chi = 1. / ( Nz**2 + Nx*Nz*chiline - 1 )
#epsilon_psi = 1. / ( Nz**2 + Ny*Nz*psiline - 1 )
#epsilon_chi = -1. / ( 1 + Nx*Nz*chiline - Nz**2 )
#epsilon_psi = -1. / ( 1 + Ny*Nz*psiline - Nz**2 )

#epsilon_chi = - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
#epsilon_psi = - psiline / ( (psiline*(1 - Nz**2)) + Nz*Ny )
epsilon_chi = - chiline / ( (chiline*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
epsilon_psi = - psiline / ( (psiline*(1 - Nz**2)) + Nz )
formatDataSet(epsilon_chi,output_file+'?append=T')
formatDataSet(epsilon_psi,output_file+'?append=T')

#plot(8,epsilonEpoch,epsilon_chi,color='red')
#plot(8,epsilonEpoch,1. / ( Nz**2 + Ny*Nz*0 - 1 ),color='red')
#plot(9,epsilonEpoch,epsilon_psi,color='blue')
plot(4,epsilonEpoch,epsilon_chi,color='red')
plot(5,epsilonEpoch,epsilon_psi,color='blue',ytitle='(&omega;!B&perp;!N/&omega;!B||!N)!U2!N - 1')
#plot(4,epsilonEpoch,sqrt(epsilon_chi+1),color='red')
#plot(5,epsilonEpoch,sqrt(epsilon_psi+1),color='blue',ytitle='&omega;!B&perp;!N/&omega;!B||!N')


#stop
#
#epsilon_chi.putProperty(QDataSet.DEPEND_1,mv_lo)
#epsilon_psi.putProperty(QDataSet.DEPEND_1,mv_lo)
#
##reset()
#plot(0,totalFlux)
#plot(3,epsilon_chi,ytitle='&epsilon;&Chi;')
#plot(4,epsilon_psi,ytitle='&epsilon;&Psi;')
