
############################################################################
##################            VARIABLES          ###########################
############################################################################
############################################################################


#timerange = getParam('timerange','2018-11-01 06:00 to 08:00','Iteration Timerange')#
#timerange = getParam('timerange','2020-01-27 to 2020-01-30','Iteration Timerange')
timerange = getParam('timerange','2020-01-27','Iteration Timerange')
version = getParam('version','0.4.5','Version number to be appended to filenames')

#separatePeaksWithL3Values      = False #Attempt to calculate anisotropy around each of fit peaks
#writeStuff                     = True  #Write out L0 anisotropy file
#useVDFFluxForWeights           = True  #Weight linear fits by normalized flux around peak (points at peak take precendence)
#conflateAndDownsampleSpectra   = True  #Downsample the spectra for individual pads (smoothSeconds parameter)
#analyzingTimeWidthComparisons  = False #Run Routine for various timewidths to compare end results (TESTING ONLY)
#usePreviouslyDownsampledData   = True  #Use Downsampled data file created previously
#useLocalSubprocesses           = True  #Use local script call files instead of pulling from github

skipPreviousFiles              = getParam('skipPreviousFiles','T','Look for previously generated files and skip analysis if found',['T','F'])
separatePeaksWithL3Values      = getParam('separatePeaksWithL3Values','F','Attempt to calculate anisotropy around each of fit peaks',['T','F'])
writeStuff                     = getParam('writeStuff','T','Write out L0 anisotropy file',['T','F'])
useVDFFluxForWeights           = getParam('useVDFFluxForWeights','T','Weight linear fits by normalized flux around peak (points at peak take precendence)',['T','F'])
useLocalSubprocesses           = getParam('useLocalSubprocesses','T','Use local script call files instead of pulling from github',['T','F'])
conflateAndDownsampleSpectra   = getParam('conflateAndDownsampleSpectra','T','Downsample the spectra for individual pads (smoothSeconds parameter)',['T','F'])
usePreviouslyDownsampledData   = getParam('usePreviouslyDownsampledData','T','Use Downsampled data file created previously',['T','F'])
if usePreviouslyDownsampledData == 'F':
    spc_mode                       = getParam('spcInstrumentMode', 'fullScan', 'Use data from Peak Tracking (default) or Full Scan mode?', ['peakTrack', 'fullScan'])
analyzingTimeWidthComparisons  = getParam('analyzingTimeWidthComparisons','F','Run Routine for various timewidths to compare end results (TESTING ONLY)',['T','F'])


m_p                  = 1.6726231E-24
q                    = 1.6022E-12
#trend_seconds        = 30     # Number of seconds over which to average magField to determine background field direction
trend_seconds        = getParam('Bfield_window' , 60 , 'Number of seconds over which to average magField to determine background field direction' )
#minFluxValueForFit   = 0.5    # Throw out/Don't fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])
minFluxValueForFit   = getParam('Minimum_VDF' , 0.5 , 'Throw out/Don\'t fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])' )
#fitSeconds           = 5      # Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)
fitSeconds           = getParam('fit_window' , 4 , 'Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)')
modFits              = getParam('mod_number' , 50 , 'Number of fits performed before updating plot/time reporting')
smoothSeconds        = getParam('smoothSeconds' , 1 , 'Number of seconds over which to average spectra together before defining flow directions')
minVoltage           = getParam('minimumVoltage', 150, 'Throw out points in mv_lo channels below this voltage')


angleBinWdith        = getParam('angleBinWidth' , 4 , 'Width of bins in degrees making up incident field angle axis of uncertainty map')
anisotropyBinNumber  = getParam('anisotropyBinNumber' , 30 , 'Number of bins making up anisotropy axis of uncertainty map')

cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/sweap/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'


plotFitsAndPauseALot_yn = getParam('FitPlots','F', 'Run the script while pausing and plotting each fit for test purposes?',['T','F'])



if useLocalSubprocesses == 'T':
    useLocalSubprocesses = True
elif useLocalSubprocesses == 'F':
    useLocalSubprocesses = False
    
if usePreviouslyDownsampledData == 'T':
    usePreviouslyDownsampledData = True
elif usePreviouslyDownsampledData == 'F':
    usePreviouslyDownsampledData = False
    
if writeStuff == 'T':
    writeStuff = True
elif writeStuff == 'F':
    writeStuff = False
    
if useVDFFluxForWeights == 'T':
    useVDFFluxForWeights = True
elif useVDFFluxForWeights == 'F':
    useVDFFluxForWeights = False
    
if conflateAndDownsampleSpectra == 'T':
    conflateAndDownsampleSpectra = True
elif conflateAndDownsampleSpectra == 'F':
    conflateAndDownsampleSpectra = False
    
if analyzingTimeWidthComparisons == 'T':
    analyzingTimeWidthComparisons = True
elif analyzingTimeWidthComparisons == 'F':
    analyzingTimeWidthComparisons = False
    
if separatePeaksWithL3Values == 'T':
    separatePeaksWithL3Values = True
elif separatePeaksWithL3Values == 'F':
    separatePeaksWithL3Values = False
    
if plotFitsAndPauseALot_yn == 'T':
    plotFitsAndPauseALot = True
elif plotFitsAndPauseALot_yn == 'F':
    plotFitsAndPauseALot = False
    
if skipPreviousFiles == 'T':
    skipPreviousFiles = True
elif skipPreviousFiles == 'F':
    skipPreviousFiles = False
    
    
############################################################################
##################            IMPORTS            ###########################
############################################################################
############################################################################
    

import sys
### IMPORT SUBPROCESSES
localGithubDirectory = 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/'
remoteGithubDirectory = 'https://github.com/kpaulson/autoplot/blob/master/'
try:
    if useLocalSubprocesses == True:
        findVDFAnisotropy = getFile( localGithubDirectory+'PSP/PSPSubProcesses/findVDFAnisotropy.jy',monitor.getSubtaskMonitor('import findVDFAnisotropy()'))
        execfile( findVDFAnisotropy.toString() )
        
        writeAnisotropyL0 = getFile( localGithubDirectory+'PSP/PSPSubProcesses/writeAnisotropyL0.jy',monitor.getSubtaskMonitor('import writeAnisotropyL0()'))
        execfile( writeAnisotropyL0.toString() )
        
        fittingUncertainties = getFile( localGithubDirectory+'PSP/PSPSubProcesses/fittingUncertainties.jy',monitor.getSubtaskMonitor('import fittingUncertainties()'))
        execfile( fittingUncertainties.toString() )
        
        field_aligner = getFile( localGithubDirectory+'CoreSubprocesses/Field_Aligner.jy',monitor.getSubtaskMonitor('import field_aligner()'))
        execfile( field_aligner.toString() )

        get_OS_version = getFile( localGithubDirectory+'CoreSubprocesses/get_os_version.jy',monitor.getSubtaskMonitor('import get_os_version()'))
        execfile( get_OS_version.toString() )

        getSPCAnisotropyUncertaintyMaps = getFile( localGithubDirectory+'PSP/PSPSubProcesses/getSPCAnisotropyUncertaintyMaps.jy',monitor.getSubtaskMonitor('import getSPCAnisotropyUncertaintyMaps()'))
        execfile( getSPCAnisotropyUncertaintyMaps.toString() )

        smoothSPCByVoltage = getFile( localGithubDirectory+'PSP/PSPSubProcesses/smoothSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothSPCByVoltage()'))
        execfile( smoothSPCByVoltage.toString() )

        smoothAndDownsampleSPCByVoltage = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/PSP/PSPSubProcesses/smoothAndDownsampleSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothAndDownsampleSPCByVoltage()'))
        execfile( smoothAndDownsampleSPCByVoltage.toString() )
       
    else:
    
        findVDFAnisotropy = getFile( remoteGithubDirectory+'PSP/PSPSubProcesses/findVDFAnisotropy.jy',monitor.getSubtaskMonitor('import findVDFAnisotropy()'))
        execfile( findVDFAnisotropy.toString() )
        
        writeAnisotropyL0 = getFile( remoteGithubDirectory+'PSP/PSPSubProcesses/writeAnisotropyL0.jy',monitor.getSubtaskMonitor('import writeAnisotropyL0()'))
        execfile( writeAnisotropyL0.toString() )
        
        fittingUncertainties = getFile( remoteGithubDirectory+'PSP/PSPSubProcesses/fittingUncertainties.jy',monitor.getSubtaskMonitor('import fittingUncertainties()'))
        execfile( fittingUncertainties.toString() )
        
        field_aligner = getFile( remoteGithubDirectory+'CoreSubprocesses/Field_Aligner.jy',monitor.getSubtaskMonitor('import field_aligner()'))
        execfile( field_aligner.toString() )

        get_OS_version = getFile( remoteGithubDirectory+'CoreSubprocesses/get_os_version.jy',monitor.getSubtaskMonitor('import get_os_version()'))
        execfile( get_OS_version.toString() )

        getSPCAnisotropyUncertaintyMaps = getFile( remoteGithubDirectory+'PSP/PSPSubProcesses/getSPCAnisotropyUncertaintyMaps.jy',monitor.getSubtaskMonitor('import getSPCAnisotropyUncertaintyMaps()'))
        execfile( getSPCAnisotropyUncertaintyMaps.toString() )

        smoothSPCByVoltage = getFile( remoteGithubDirectory+'PSP/PSPSubProcesses/smoothSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothSPCByVoltage()'))
        execfile( smoothSPCByVoltage.toString() )

        smoothAndDownsampleSPCByVoltage = getFile( remoteGithubDirectory+'PSP/PSPSubProcesses/smoothAndDownsampleSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothAndDownsampleSPCByVoltage()'))
        execfile( smoothAndDownsampleSPCByVoltage.toString() )
    
except:

    print 'Unable to grab subprocess from github'
    
    findVDFAnisotropy = getFile( localGithubDirectory+'PSP/PSPSubProcesses/findVDFAnisotropy.jy',monitor.getSubtaskMonitor('import findVDFAnisotropy()'))
    execfile( findVDFAnisotropy.toString() )
    
    writeAnisotropyL0 = getFile( localGithubDirectory+'PSP/PSPSubProcesses/writeAnisotropyL0.jy',monitor.getSubtaskMonitor('import writeAnisotropyL0()'))
    execfile( writeAnisotropyL0.toString() )
        
    fittingUncertainties = getFile( localGithubDirectory+'PSP/PSPSubProcesses/fittingUncertainties.jy',monitor.getSubtaskMonitor('import fittingUncertainties()'))
    execfile( fittingUncertainties.toString() )
    
    field_aligner = getFile( localGithubDirectory+'CoreSubprocesses/Field_Aligner.jy',monitor.getSubtaskMonitor('import field_aligner()'))
    execfile( field_aligner.toString() )

    get_OS_version = getFile( localGithubDirectory+'CoreSubprocesses/get_os_version.jy',monitor.getSubtaskMonitor('import get_os_version()'))
    execfile( get_OS_version.toString() )

    getSPCAnisotropyUncertaintyMaps = getFile( localGithubDirectory+'PSP/PSPSubProcesses/getSPCAnisotropyUncertaintyMaps.jy',monitor.getSubtaskMonitor('import getSPCAnisotropyUncertaintyMaps()'))
    execfile( getSPCAnisotropyUncertaintyMaps.toString() )

    smoothSPCByVoltage = getFile( localGithubDirectory+'PSP/PSPSubProcesses/smoothSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothSPCByVoltage()'))
    execfile( smoothSPCByVoltage.toString() )

    smoothAndDownsampleSPCByVoltage = getFile( localGithubDirectory+'PSP/PSPSubProcesses/smoothAndDownsampleSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothAndDownsampleSPCByVoltage()'))
    execfile( smoothAndDownsampleSPCByVoltage.toString() )
       
from org.apache.commons.math.optimization.fitting import CurveFitter
from org.apache.commons.math.optimization.fitting import ParametricRealFunction
from org.apache.commons.math.optimization.fitting import WeightedObservedPoint
from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer
from org.apache.commons.math.stat.regression      import SimpleRegression

OS = get_os_version().split()[0]
if OS == 'mac':
    googleDrive_path = '/Volumes/Macintosh HD/Volumes/GoogleDrive/My Drive/'
    googleDrive_path = '/Volumes/GoogleDrive/My Drive/'
elif OS == 'windows':
    #googleDrive_path = '/Users/kpaulson/GoogleDrive/'
    googleDrive_path = 'G:/My Drive/'

#addToSearchPath(sys.path, str(googleDrive_path+'Software/Autoplot/jar/commons-math3-3.6.1.jar'), monitor)

#from org.apache.commons.math3.fitting import AbstractCurveFitter
#from org.apache.commons.math3.fitting import SimpleCurveFitter
#from org.apache.commons.math3.fitting.leastsquares import LevenbergMarquardtOptimizer as LMO
#from org.apache.commons.math3.fitting.leastsquares import GaussNewtonOptimizer
#from org.apache.commons.math3.analysis import ParametricUnivariateFunction

class LinFit(ParametricRealFunction):
#class LinFit(ParametricUnivariateFunction):
    def value(self, x, params):
        a = params[0]
        b = params[1]
        return (a*x + b)
    def gradient(self, x, params):
        a = params[0]
        b = params[1]
        return [x,1]


############################################################################
##################            DEFINITIONS        ###########################
############################################################################
############################################################################
    
if analyzingTimeWidthComparisons == True:
    output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/TEMP/L0/v%s/'%(version)
    #output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
elif analyzingTimeWidthComparisons == False:
    output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
    
    
# def fittingUncertainties(fitResult,tempVDF,tempvz,tempvq,tempBq):
    # r = where(ge(tempVDF,minFluxValueForFit).and(valid(tempVDF)).and(valid(tempvz)))  # Removes points from the measurement below a particular threschhold
    # r = where(ge(tempVDF,minFluxValueForFit).and(valid(tempVDF)).and(valid(tempvz)))  # Removes points from the measurement below a particular threschhold
    # VDF_fitValues = where(gt(tempVDF[r],0))
    # temp_fitValues = (fitResult[0]*(tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues]) + fitResult[1])
    # temp_residualVariance = ( tempvq[r][VDF_fitValues] - temp_fitValues )**2
    
    # try:
        # temp_chiSquared = total( abs( temp_residualVariance / temp_fitValues ) )
        # temp_chiSquaredReduced = temp_chiSquared / (len(tempvz[r][VDF_fitValues]) - 2)
    # except:
        # temp_chiSquaredReduced = -1E38
    # try:
        # temp_totalVariance = (tempvq[r][VDF_fitValues] - mean(tempvq[r][VDF_fitValues]))**2
        # temp_rSquared = 1 - ( total(temp_residualVariance) / total(temp_totalVariance) )
        # temp_abscissaVariance = ( (tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues]) - mean((tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues])) )**2
        # temp_slopeError = sqrt( total(temp_residualVariance) / total(temp_abscissaVariance) ) / (len(tempvz[r][VDF_fitValues]) - 2)
    # except:
        # temp_rSquared = -1E38
        # temp_slopeError = -1E38
    
    # return(temp_chiSquaredReduced,temp_rSquared,temp_slopeError)
                        
    
    
############################################################################
#################            BEGIN SCRIPT        ###########################
############################################################################
############################################################################

import java
time_begin = TimeUtil.now()    

    
        
# Set up error/uncertainty maps
(anisotropy_deltaPlus,anisotropy_deltaMinus) = getSPCAnisotropyUncertaintyMaps(angleBinWdith,anisotropyBinNumber,OS)
   
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)


# Split analysis by day
monitor.started()
trs= generateTimeRanges('$Y-$m-$d',timerange)
for tr in trs:
    
    fileAlreadyExists = False
    time_begin_tr = TimeUtil.now() 
    timeTitle = str(tr)    
    
    if lt(datumRange(timerange).width(), datumRange(tr).width()):
        tr = timerange
        tp_begin = TimeParser.create('$Y-$m-$dT$H$M')
        tp_end = TimeParser.create('-$H$M')
        timeTitle = tp_begin.format(datumRange(timerange).min())+tp_end.format(datumRange(timerange).max())
    
    # Create list of VDF poulations over which to perform analysis
    vdfList = list() 
    if separatePeaksWithL3Values == True:
        vdfList.append('vdf_p1')
        vdfList.append('vdf_3')
        vdfList.append('vdf_a')
    else:
        vdfList.append('vdf_full')

    # Look for previous instances of the file and skip rather than overwrite
    if skipPreviousFiles == True:
        try:
            if separatePeaksWithL3Values == False:
                for vdf in vdfList:
                    output_file = output_folder+'SPC_Anisotropy_%s_v%s.cdf'%(timeTitle,version)
                    TEMP_epoch = getDataSet(output_file+'?Epoch')
                    if ne( long(mode(copy(TEMP_epoch))), 0):
                        print 'File already exists for %s on %s'%(vdf,timeTitle)
                        vdfList.remove(vdf)
                    
            elif separatePeaksWithL3Values == True:
                for vdf in vdfList:
                    if vdf == 'vdf_full':
                        output_file = output_folder+'SPC_Anisotropy_%s_v%s.cdf'%(timeTitle,version)
                    else:
                        output_file = output_folder+'SPC_Anisotropy_%s_%s_v%s.cdf'%(vdf.split('_')[1],timeTitle,version)
                        print output_file
                    TEMP_epoch = getDataSet(output_file+'?Epoch')
                    if ne( long(mode(copy(TEMP_epoch))), 0):
                        print 'File already exists for %s on %s'%(vdf,timeTitle)
                        vdfList.remove(vdf)
            if len(vdfList) == 0:
                fileAlreadyExists = True
        except:
            fileAlreadyExists = False
        
    # Run the big routine    
    try:
        if fileAlreadyExists == True:
            raise fileAlreadyExistsException
            
        monitor.setProgressMessage(tr)
        
        if usePreviouslyDownsampledData == True:
            monitor.setLabel('Using Local SPC Downsample') 
            
            localDownsampledDataDirectory = googleDrive_path+'Research/PSP/SPC/DownsampledSpectra/%ssec/'%smoothSeconds
            localDownsampledDataFile = localDownsampledDataDirectory+'SPC_DownsampledSpectra_$Y-$m-$d_%ssec.cdf'%(smoothSeconds)
            try:
                spc_a = getDataSet(localDownsampledDataFile+'?spc_a_mean',tr)
                spc_b = getDataSet(localDownsampledDataFile+'?spc_b_mean',tr)
                spc_c = getDataSet(localDownsampledDataFile+'?spc_c_mean',tr)
                spc_d = getDataSet(localDownsampledDataFile+'?spc_d_mean',tr)
                
                mv_lo = getDataSet(localDownsampledDataFile+'?mv_lo',tr)
                mv_hi = getDataSet(localDownsampledDataFile+'?mv_hi',tr)
                
                spc_a = trim(spc_a,tr)
                spc_b = trim(spc_b,tr)
                spc_c = trim(spc_c,tr)
                spc_d = trim(spc_d,tr)
                
                mv_lo = trim(mv_lo,tr)
                mv_hi = trim(mv_hi,tr)
                
                print 'Loading downsampled SPC L2 data took:',TimeUtil.now()-time_begin_tr
                time_last = TimeUtil.now()
                
            except:
                usePreviouslyDownsampledData = False
                raise java.io.FileNotFoundException
                
        elif usePreviouslyDownsampledData == False:
            monitor.setLabel('Downloading SPC') 
            if spc_mode == 'peakTrack':
                try:
                    print cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)'
                    spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
                    spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
                    spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
                    spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)
                    
                    mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
                    mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)
                except:
                    noSPCData = None
                    raise java.io.FileNotFoundException
            elif spc_mode == 'fullScan':
                output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/fullScan/L0/v%s/'%(version)
                monitor.setLabel('Downloading SPC FullScan Data') 
                try:
                    print cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(1)'
                    spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(1)',tr)
                    spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(1)',tr)
                    spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(1)',tr)
                    spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(1)',tr)
                    
                    mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(1)',tr)
                    mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(1)',tr)
                except:
                    noSPCData = None
                    raise java.io.FileNotFoundException
            
                
            print 'Downloading SPC L2 data took:',TimeUtil.now()-time_begin_tr
            time_last = TimeUtil.now()
            #spc_list = [spc_a,spc_b,spc_c,spc_d]
            
            spc_a = trim(spc_a,tr)
            spc_b = trim(spc_b,tr)
            spc_c = trim(spc_c,tr)
            spc_d = trim(spc_d,tr)
            
            mv_lo = trim(mv_lo,tr)
            mv_hi = trim(mv_hi,tr)
            
            if conflateAndDownsampleSpectra == True:
                monitor.setLabel('Downsampling') 
                
                (spc_a_smooth_downsampled_mean, spc_a_smooth_downsampled_median, spc_a_smooth_downsampled_mode, mv_lo_downsampled, mv_hi_downsampled) = smoothAndDownsampleSPCByVoltage(spc_a,mv_lo,mv_hi,smoothSeconds)
                (spc_b_smooth_downsampled_mean, spc_b_smooth_downsampled_median, spc_b_smooth_downsampled_mode, mv_lo_downsampled, mv_hi_downsampled) = smoothAndDownsampleSPCByVoltage(spc_b,mv_lo,mv_hi,smoothSeconds)
                (spc_c_smooth_downsampled_mean, spc_c_smooth_downsampled_median, spc_c_smooth_downsampled_mode, mv_lo_downsampled, mv_hi_downsampled) = smoothAndDownsampleSPCByVoltage(spc_c,mv_lo,mv_hi,smoothSeconds)
                (spc_d_smooth_downsampled_mean, spc_d_smooth_downsampled_median, spc_d_smooth_downsampled_mode, mv_lo_downsampled, mv_hi_downsampled) = smoothAndDownsampleSPCByVoltage(spc_d,mv_lo,mv_hi,smoothSeconds)
                
                spc_a = spc_a_smooth_downsampled_mean
                spc_b = spc_b_smooth_downsampled_mean
                spc_c = spc_c_smooth_downsampled_mean
                spc_d = spc_d_smooth_downsampled_mean
    #            spc_a = smoothAndDownsampleSPCByVoltage(spc_a,mv_lo,smoothSeconds/3.)
    #            spc_b = smoothAndDownsampleSPCByVoltage(spc_b,mv_lo,smoothSeconds/3.)
    #            spc_c = smoothAndDownsampleSPCByVoltage(spc_c,mv_lo,smoothSeconds/3.)
    #            spc_d = smoothAndDownsampleSPCByVoltage(spc_d,mv_lo,smoothSeconds/3.)
                
                mv_lo = mv_lo_downsampled
                mv_hi = mv_hi_downsampled
                
                #mv_lo = spc_a.property(QDataSet.DEPEND_1)
                mv_lo.putProperty(QDataSet.DEPEND_0,spc_a.property(QDataSet.DEPEND_0))
                mv_hi.putProperty(QDataSet.DEPEND_0,spc_a.property(QDataSet.DEPEND_0))
                #mv_hi = synchronize(mv_lo,mv_hi) #This will lead to some errors when interpolating across changing bin sizes. Could fix in the smoothAndD... subprocess
                
            
            print 'Smoothing and downsampling data took:',TimeUtil.now()-time_last
            time_last = TimeUtil.now()
        
        badLowVoltagePoints = where(lt(mv_lo,minVoltage))
        spc_a[badLowVoltagePoints] = 0
        spc_b[badLowVoltagePoints] = 0
        spc_c[badLowVoltagePoints] = 0
        spc_d[badLowVoltagePoints] = 0
        
        monitor.setLabel('Flow Angles') 
        spc_list = [spc_a,spc_b,spc_c,spc_d]
        del(spc_a,spc_b,spc_c,spc_d)
        
        totalFlux = sum(spc_list)
        
        fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
        fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])
        
        U = -(fluxDifference_scy/totalFlux)/0.035 #Negative symbol needed to align with Mike's calculations
        V = (fluxDifference_scx/totalFlux)/0.035
        
        U.putProperty(QDataSet.VALID_MIN,None)
        V.putProperty(QDataSet.VALID_MIN,None)
        U.putProperty(QDataSet.VALID_MAX,None)
        V.putProperty(QDataSet.VALID_MAX,None)
        

        # This part is in there to match Mike's measurement of Bulk Flow Directions, 
        # but we should pull it out for our fitting, right? - Yes, right now it filters over index for rank2 instead of DEPEND_1 so you get bad results
#        for j in xrange(len(U[0,:])):
#            try:
#                U[:,j] = medianFilter(U[:,j],3)
#            except:
#                continue
#            try:
#                V[:,j] = medianFilter(V[:,j],3)
#            except:
#                continue
        
        U.putProperty(QDataSet.UNITS,Units.degrees)
        V.putProperty(QDataSet.UNITS,Units.degrees)
        
        
        
        #Are you measuring the slope near the peak in current or near the peak in the velocity distribution function? 
        #(the VDF goes like current divided by speed time window width in speed units)
        
        print 'Calculating Flow Angles took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        
        monitor.setLabel('Defining VDF')
        v_z = sqrt( (2./m_p) * q*(mv_lo + (mv_hi-mv_lo)/2.) ) / 1.E5   # in km/s
        windowWidths = sqrt( (2./m_p) * q*(mv_hi-mv_lo)/2.) / 1.E5
        vdf_full = totalFlux/(v_z*windowWidths)*1.66667E3 #This factor seems arbitrary, but is necessary to line up with Mike's L3 values.
        vdf_full.putProperty(QDataSet.DEPEND_1,v_z)
        #vdfList.append('vdf_full')
        del(windowWidths,mv_hi)
        
        
        # This step is meant to be a further step in removing full scans, but is probably not set properly
#        if manuallyRemoveFullScans == True:
#            for i in xrange(len(v_z)):
#                if gt(v_z[i,max(where(valid(v_z[i,:])))] - v_z[i,min(where(valid(v_z[i,:])))],500):
#                    vdf[i,:] = -1E38
        
        totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
        #peaks = reduceMax(totalFlux,1)
        #r = where(eq(totalFlux,peaks))
        peaks = reduceMax(vdf_full,1)
        peaks_smooth = synchronize( vdf_full, medianFilter(peaks[where(valid(peaks))],5) )
        r = where(eq(vdf_full,peaks))
        r_smooth = where(eq(vdf_full,peaks_smooth))
        
        
        print 'Defining VDF took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        # If we want to use the peaks as weights in fitting, import L3 data and build model distributions
        if separatePeaksWithL3Values == True:
            sweap_spc_L3_file = 'http://sweap.cfa.harvard.edu/data/sci/sweap/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf'
            
            DQF = getDataSet(sweap_spc_L3_file+'?DQF',tr)
            goodFlags = where(eq(DQF[:,0],0))

            np_fit = getDataSet(sweap_spc_L3_file+'?np_fit',tr)[goodFlags]
            wp_fit = getDataSet(sweap_spc_L3_file+'?wp_fit',tr)[goodFlags]
            vp_fit_SC = getDataSet(sweap_spc_L3_file+'?vp_fit_SC',tr)[goodFlags]
            vp_fit = magnitude(vp_fit_SC)
            spc_time = np_fit.property(QDataSet.DEPEND_0)
            
            np1_fit = getDataSet(sweap_spc_L3_file+'?np1_fit',tr)[goodFlags]
            wp1_fit = getDataSet(sweap_spc_L3_file+'?wp1_fit',tr)[goodFlags]
            vp1_fit_SC = getDataSet(sweap_spc_L3_file+'?vp1_fit_SC',tr)[goodFlags]
            vp1_fit = magnitude(vp1_fit_SC)
            
            n3_fit = getDataSet(sweap_spc_L3_file+'?n3_fit',tr)[goodFlags]
            w3_fit = getDataSet(sweap_spc_L3_file+'?w3_fit',tr)[goodFlags]
            v3_fit_SC = getDataSet(sweap_spc_L3_file+'?v3_fit_SC',tr)[goodFlags]
            v3_fit = magnitude(v3_fit_SC)
            
            na_fit = getDataSet(sweap_spc_L3_file+'?na_fit',tr)[goodFlags]
            wa_fit = getDataSet(sweap_spc_L3_file+'?wa_fit',tr)[goodFlags]
            va_fit_SC = getDataSet(sweap_spc_L3_file+'?va_fit_SC',tr)[goodFlags]
            va_fit = magnitude(va_fit_SC)
            
            # Define Gaussian parameters
            cp = wp_fit            
            ap = np_fit / (cp*sqrt(PI))         
            bp = vp_fit
            
            cp1 = wp1_fit     
            ap1 = np1_fit / (cp1*sqrt(PI))                
            bp1 = vp1_fit
            
            c3 = w3_fit     
            a3 = n3_fit / (c3*sqrt(PI))                
            b3 = v3_fit
            
            ca = wa_fit    
            aa = (na_fit/2.) / (ca*sqrt(PI))                 
            ba = va_fit * sqrt(2.)
            
            (ap,bp,cp) = synchronize(v_z,[ap,bp,cp])
            (ap1,bp1,cp1) = synchronize(v_z,[ap1,bp1,cp1])
            (a3,b3,c3) = synchronize(v_z,[a3,b3,c3])
            (aa,ba,ca) = synchronize(v_z,[aa,ba,ca])
            
            
            v_space = copy(v_z)
            v_space_time = v_space.property(QDataSet.DEPEND_0)
            vdf_p  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_p1 = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_3  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_a  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            v_index = 0
            for v_index in xrange(len(v_space[0,:])):
                
                #peak_p[:,v_index]  = ap*exp(-((v_space[:,v_index] - bp)**2 / (2*cp**2)))
                #peak_p1[:,v_index] = ap1*exp(-((v_space[:,v_index] - bp1)**2 / (2*cp1**2)))
                #peak_a[:,v_index]  = aa*exp(-((v_space_a[:,v_index] - ba)**2 / (2*ca**2)))
                
                vdf_p[:,v_index]  = ap *exp(-((v_space[:,v_index]   - bp )**2 / (cp**2)))
                vdf_p1[:,v_index] = ap1*exp(-((v_space[:,v_index]   - bp1)**2 / (cp1**2)))
                vdf_3[:,v_index]  = a3 *exp(-((v_space[:,v_index]   - b3 )**2 / (c3**2)))
                vdf_a[:,v_index]  = aa *exp(-((v_space[:,v_index]   - ba )**2 / (ca**2)))
                #v_index+=1
            
            vdf_p.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_p.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_p.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_p.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_p1.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_p1.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_p1.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_p1.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_3.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_3.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_3.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_3.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_a.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_a.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_a.putProperty(QDataSet.VALID_MIN,0)
            vdf_a.putProperty(QDataSet.VALID_MAX,1E20)
            
            #plot(0,vdf_p1)
            #plot(1,vdf_3)
            #plot(2,vdf_a)
#
#            vdfList.append('vdf_p1')
#            vdfList.append('vdf_3')
#            vdfList.append('vdf_a')
            #stop
            
            print 'Building Peaks took:',TimeUtil.now()-time_last
            time_last = TimeUtil.now()
        
        
        vz_tanTheta = v_z * tan(toRadians(V))     # Vx
        vz_tanPhi   = v_z * tan(toRadians(-U))     # Vy The negative sign here is to align the velocity with the sc coordinate system (sc_y = -spc_y)
        #plot(vz_tanPhi)
        #stop
        
        #U is supposed to be v_sc so that we keep the spacecraft motion out of this (duh...)
        #HOWEVER, it has little to no effect on the results
        try:
            psp_ephem_file_local = googleDrive_path+'Research/PSP/Ephemeris/EPHEMERIS/$Y/$m/spp_swp_spc_ephem_$Y$m$d_v$v.cdf'
            psp_ephem_file = psp_ephem_file_local #Some day I need to figure out how to grab a nonlocal copy of these files
            v_scz = getDataSet(psp_ephem_file+'?SC_VR_kms',tr)
            v_scx = getDataSet(psp_ephem_file+'?SC_VORB_kms',tr)
            v_scy = getDataSet(psp_ephem_file+'?SC_VZ_kms',tr)
            u_x = synchronize(v_z,v_scx)
            u_y = synchronize(v_z,v_scy)
            u_z = synchronize(v_z,v_scz)
        except(java.io.FileNotFoundException):
            print 'PSP ephemeris file not found at', psp_ephem_file
            break
        
        
        #if 'alreadyPlottedOnce' not in globals():
            #setLayoutOverplot(4) 
        reset()
        load(googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/anisotropyFromMath_DayOverviewPlotter.vap')
        
        #plot(0,totalFlux)
        plot(0,vdf_full,xrange=tr, colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle='VDF (cm!U-3!N km!U-1!N s)',zlog=True,title='%s-sec downsample,  %s-sec fit'%(smoothSeconds,fitSeconds))
        plot(1,v_z[r_smooth])
        #alreadyPlottedOnce = True
        #stop
        #plot(0,vz_tanTheta-synchronize(vz_tanTheta,u_x))
        
        #####
        ##########
        #################
        
        # Why was this using the full-resolution data instead of the 1min product? I am smoothing it on that order anyway, this was a dumb choice.
        try:
            # First try public 1min data
            mag_datafile = 'http://research.ssl.berkeley.edu/data/psp/data/sci/fields/l2/mag_SC_1min/$Y/$m/psp_fld_l2_mag_SC_1min_$Y$m$d_v$v.cdf'
            mag = getDataSet(mag_datafile+'?psp_fld_l2_mag_SC_1min',tr)
            print 'Used mag data from:',mag_datafile
        except:
            try:
                # Then try team 1min data
                mag_datafile = 'http://research.ssl.berkeley.edu/data/spp/data/sci/fields/staging/l2/mag_SC_1min/$Y/$m/psp_fld_l2_mag_SC_1min_$Y$m$d_v$v.cdf'
                mag = getDataSet(mag_datafile+'?psp_fld_l2_mag_SC_1min',tr)
                print 'Used mag data from:',mag_datafile
            except:
                try:
                    # Then start probing the full-resolution files to see if anything is there
                    mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/sweap/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
                    mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
                    print 'Used mag data from:',mag_datafile
                except:
                    try:
                        mag_datafile = googleDrive_path+'Research/Data/AutoplotCache/http/w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
                        mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
                        print 'Used mag data from:',mag_datafile
                    except:
                        mag_datafile = 'http://research.ssl.berkeley.edu/data/spp/data/sci/fields/staging/l2/mag_SC/$Y/$m/psp_fld_l2_mag_SC_$Y$m$d$(H,span=6)_v$v.cdf'
                        mag = getDataSet(mag_datafile+'?psp_fld_l2_mag_SC',tr)
                        print 'Used mag data from:',mag_datafile
                
        #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
        mag = trim(mag,tr)
        
        mag_time = mag.property(QDataSet.DEPEND_0)
        
        #pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/sweap/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
        #pos_time = pos.property(QDataSet.DEPEND_0)
        
        Bx = mag[:,0]
        By = mag[:,1]
        Bz = mag[:,2]
        Btotal = magnitude(mag)
        
        # These inputs are arbitrary since we don't really care what the B_perp directions are for now. Does not affect outcome
        TEMP_Rx = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Ry = putProperty(-1*ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Rz = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        
        
        ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
        
        #################
        ##########
        #####
        
        print 'Downloading MAG Data took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        plot(6,mag_time,bundle(toDegrees(atan(Nx/Nz)),toDegrees(atan(Ny/Nz))), xrange=tr, ylog=False,ytitle='&#x2220;B!Bincident!N')
        #plot(6,mag_time,bundle(toDegrees(atan2(Nx,Nz)),toDegrees(atan2(Ny,Nz))), xrange=tr, ylog=False,ytitle='&#x2220;B!Bincident!N')
            
        
        for vdf in vdfList:
            if vdf == 'vdf_full':
                vdf_in = vdf_full
                u_x_in = u_x
                u_y_in = u_y
                u_z_in = u_z
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BTot.!N (cm!U-3!N km!U-1!N s)' 
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True, xrange=tr)
                (chiline, psiline, chiSquaredReduced_chi, chiSquaredReduced_psi,
                    rSquared_chi, rSquared_psi, slopeError_chi, slopeError_psi,
                    epsilon_chi, epsilon_psi, anisotropy_chi, anisotropy_psi, 
                    epsilonEpoch, anisotropy_chi_deltaPlus,
                    anisotropy_chi_deltaMinus, anisotropy_psi_deltaPlus,
                    anisotropy_psi_deltaMinus, anisotropy_chi_standardDev, anisotropy_psi_standardDev) = findVDFAnisotropy(-v_z, vz_tanPhi, vz_tanTheta, 
                                                 u_x_in, u_y_in, u_z_in, vdf_in, Nx_temp, 
                                                 Ny_temp, Nz_temp)
                plot(4,epsilonEpoch,bundle(anisotropy_chi,anisotropy_psi), xrange=tr, ylog=True, yrange='0.1 to 10', ytitle='&omega;!B&perp;!N/&omega;!B||!N')
                plot(5,epsilonEpoch,bundle(slopeError_chi,slopeError_psi), xrange=tr, ylog=True, yrange='0.005 to 50', ytitle='Slope Error of Fit')
                
            elif vdf == 'vdf_p1':
                vdf_in = vdf_p1
                vp1_fit_SC = synchronize(vdf_p1,vp1_fit_SC)
                u_x_in = vp1_fit_SC[:,0]
                u_y_in = vp1_fit_SC[:,1]
                u_z_in = vp1_fit_SC[:,2]
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BCore!N (cm!U-3!N km!U-1!N s)'
                minFluxValueForFit = 0
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
                (chiline_p1, psiline_p1, chiSquaredReduced_chi_p1, chiSquaredReduced_psi_p1,
                    rSquared_chi_p1, rSquared_psi_p1, slopeError_chi_p1, slopeError_psi_p1,
                    epsilon_chi_p1, epsilon_psi_p1, anisotropy_chi_p1, anisotropy_psi_p1, 
                    epsilonEpoch_p1, anisotropy_chi_deltaPlus_p1, anisotropy_chi_deltaMinus_p1,
                    anisotropy_psi_deltaPlus_p1,anisotropy_psi_deltaMinus_p1, anisotropy_chi_standardDev_p1, anisotropy_psi_standardDev_p1) = findVDFAnisotropy(-v_z, vz_tanPhi,
                                                 vz_tanTheta, u_x_in, u_y_in, u_z_in, vdf_in, 
                                                 Nx_temp, Ny_temp, Nz_temp)
                plot(4,epsilonEpoch_p1,bundle(anisotropy_chi_p1,anisotropy_psi_p1), xrange=tr, ylog=True, yrange='0.1 to 10', ytitle='&omega;!B&perp;!N/&omega;!B||!N')
                plot(5,epsilonEpoch_p1,bundle(slopeError_chi_p1,slopeError_psi_p1), xrange=tr, ylog=True, yrange='0.005 to 50', ytitle='Slope Error of Fit')
                
            elif vdf == 'vdf_3':
                vdf_in = vdf_3
                v3_fit_SC = synchronize(vdf_3,v3_fit_SC)
                u_x_in = v3_fit_SC[:,0]
                u_y_in = v3_fit_SC[:,1]
                u_z_in = v3_fit_SC[:,2]
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BBeam!N (cm!U-3!N km!U-1!N s)'
                minFluxValueForFit = 0
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
                (chiline_3, psiline_3, chiSquaredReduced_chi_3, chiSquaredReduced_psi_3,
                    rSquared_chi_3, rSquared_psi_3, slopeError_chi_3, slopeError_psi_3,
                    epsilon_chi_3, epsilon_psi_3, anisotropy_chi_3, anisotropy_psi_3, 
                    epsilonEpoch_3, anisotropy_chi_deltaPlus_3, anisotropy_chi_deltaMinus_3,
                    anisotropy_psi_deltaPlus_3,anisotropy_psi_deltaMinus_3, anisotropy_chi_standardDev_3, anisotropy_psi_standardDev_3) = findVDFAnisotropy(-v_z, vz_tanPhi,
                                                 vz_tanTheta, u_x_in, u_y_in, u_z_in, vdf_in, 
                                                 Nx_temp, Ny_temp, Nz_temp)
                plot(4,epsilonEpoch_3,bundle(anisotropy_chi_3,anisotropy_psi_3), xrange=tr, ylog=True, yrange='0.1 to 10', ytitle='&omega;!B&perp;!N/&omega;!B||!N')
                plot(5,epsilonEpoch_3,bundle(slopeError_chi_3,slopeError_psi_3), xrange=tr, ylog=True, yrange='0.005 to 50', ytitle='Slope Error of Fit')
                
            elif vdf == 'vdf_a':
                vdf_in = vdf_a
                va_fit_SC = synchronize(vdf_a,va_fit_SC)
                u_x_in = va_fit_SC[:,0]
                u_y_in = va_fit_SC[:,1]
                u_z_in = va_fit_SC[:,2]
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BAlpha!N (cm!U-3!N km!U-1!N s)'
                minFluxValueForFit = 0
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
                (chiline_a, psiline_a, chiSquaredReduced_chi_a, chiSquaredReduced_psi_a,
                    rSquared_chi_a, rSquared_psi_a, slopeError_chi_a, slopeError_psi_a,
                    epsilon_chi_a, epsilon_psi_a, anisotropy_chi_a, anisotropy_psi_a, 
                    epsilonEpoch_a, anisotropy_chi_deltaPlus_a, anisotropy_chi_deltaMinus_a,
                    anisotropy_psi_deltaPlus_a,anisotropy_psi_deltaMinus_a, anisotropy_chi_standardDev_a, anisotropy_psi_standardDev_a) = findVDFAnisotropy(-v_z, vz_tanPhi,
                                                 vz_tanTheta, u_x_in, u_y_in, u_z_in, vdf_in, 
                                                 Nx_temp, Ny_temp, Nz_temp)
                plot(4,epsilonEpoch_a,bundle(anisotropy_chi_a,anisotropy_psi_a), xrange=tr, ylog=True, yrange='0.1 to 10', ytitle='&omega;!B&perp;!N/&omega;!B||!N')
                plot(5,epsilonEpoch_a,bundle(slopeError_chi_a,slopeError_psi_a), xrange=tr, ylog=True, yrange='0.005 to 50', ytitle='Slope Error of Fit')
                #plot(6,bundle(anisotropy_chi_a,anisotropy_psi_a),ylog=True)
        
        
            #Btotal_in = synchronize(chiline,Btotal)
            
            
            
            # ###
            # ### WRITE STUFF
            # ###
            
        if writeStuff == True:
            if analyzingTimeWidthComparisons == True:
                output_file = output_folder+'SPC_Anisotropy_%s_v%s_%ssec_%ssec.cdf'%(timeTitle,version,str(smoothSeconds),str(fitSeconds))
            elif analyzingTimeWidthComparisons == False:
                output_file = output_folder+'SPC_Anisotropy_%s_v%s.cdf'%(timeTitle,version)
                #output_file = output_folder+'SPC_Anisotropy_%s_%s_v%s.cdf'%(vdf.split('_')[1],timeTitle,version)
            
            
            for vdf in vdfList:
                time_write_begin = TimeUtil.now()
                print 'writing %s file'%(vdf)
                if vdf == 'vdf_full':
                    tempB = synchronize(chiline,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
                    Btotal_in = synchronize(Bunit,Btotal)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal_in, chiline, psiline, 
                         chiSquaredReduced_chi, chiSquaredReduced_psi,
                         rSquared_chi, rSquared_psi, slopeError_chi, slopeError_psi,
                         epsilon_chi, epsilon_psi, anisotropy_chi, anisotropy_psi, 
                         epsilonEpoch, anisotropy_chi_deltaPlus,
                         anisotropy_chi_deltaMinus, anisotropy_psi_deltaPlus,
                         anisotropy_psi_deltaMinus, anisotropy_chi_standardDev, 
                         anisotropy_psi_standardDev)
                     #plot(epsilonEpoch)
                     #print epsilonEpoch.property(QDataSet.UNITS)
                         
                elif vdf == 'vdf_p1':
                    tempB = synchronize(chiline_p1,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch_p1)
                    Btotal_in = synchronize(Bunit,Btotal)
                    output_file = output_folder+'SPC_Anisotropy_%s_%s_v%s.cdf'%(vdf.split('_')[1],timeTitle,version)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal_in, chiline_p1, psiline_p1, 
                        chiSquaredReduced_chi_p1, chiSquaredReduced_psi_p1,
                        rSquared_chi_p1, rSquared_psi_p1, slopeError_chi_p1, slopeError_psi_p1,
                        epsilon_chi_p1, epsilon_psi_p1, anisotropy_chi_p1, anisotropy_psi_p1, 
                        epsilonEpoch_p1, anisotropy_chi_deltaPlus_p1, anisotropy_chi_deltaMinus_p1,
                        anisotropy_psi_deltaPlus_p1,anisotropy_psi_deltaMinus_p1, anisotropy_chi_standardDev_p1, 
                         anisotropy_psi_standardDev_p1)
                        
                elif vdf == 'vdf_3':
                    tempB = synchronize(chiline_3,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch_3)
                    Btotal_in = synchronize(Bunit,Btotal)
                    output_file = output_folder+'SPC_Anisotropy_%s_%s_v%s.cdf'%(vdf.split('_')[1],timeTitle,version)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal_in, chiline_3, psiline_3, 
                        chiSquaredReduced_chi_3, chiSquaredReduced_psi_3,
                        rSquared_chi_3, rSquared_psi_3, slopeError_chi_3, slopeError_psi_3,
                        epsilon_chi_3, epsilon_psi_3, anisotropy_chi_3, anisotropy_psi_3, 
                        epsilonEpoch_3, anisotropy_chi_deltaPlus_3, anisotropy_chi_deltaMinus_3,
                        anisotropy_psi_deltaPlus_3,anisotropy_psi_deltaMinus_3, anisotropy_chi_standardDev_3, 
                        anisotropy_psi_standardDev_3)
                                                     
                elif vdf == 'vdf_a':
                    tempB = synchronize(chiline_a,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch_a)
                    Btotal_in = synchronize(Bunit,Btotal)
                    output_file = output_folder+'SPC_Anisotropy_%s_%s_v%s.cdf'%(vdf.split('_')[1],timeTitle,version)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal_in, chiline_a, psiline_a, 
                        chiSquaredReduced_chi_a, chiSquaredReduced_psi_a,
                        rSquared_chi_a, rSquared_psi_a, slopeError_chi_a, slopeError_psi_a,
                        epsilon_chi_a, epsilon_psi_a, anisotropy_chi_a, anisotropy_psi_a, 
                        epsilonEpoch_a, anisotropy_chi_deltaPlus_a, anisotropy_chi_deltaMinus_a,
                        anisotropy_psi_deltaPlus_a,anisotropy_psi_deltaMinus_a, anisotropy_chi_standardDev_a, 
                        anisotropy_psi_standardDev_a)
            
    except:
        import traceback
        traceback.print_exc()
        continue
