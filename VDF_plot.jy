
# ############################################################################################ 


def field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds ):
    """Routine used to define field-aligned coordinate system by smoothing over given magnetic field data.
	
	Parameters:
	    Bx = rank1 X component of magnetic field
		By = rank1 Y component of magnetic field
		Bz = rank1 Z component of magnetic field
		TEMP_Rx = rank1 X component of radial s/c position (in same coord system as B)
		TEMP_Ry = rank1 Y component of radial s/c position (in same coord system as B)
		TEMP_Rz = rank1 Z component of radial s/c position (in same coord system as B)
		trend_seconds = rank0 number of seconds over which to average B to define as background
		
    Returns:
	    (Bn , Bp , Bq) = rank1 collection of Magnetic Field components in field-aligned system.
		(Nx , Ny , Nz) = rank1 collection of Magnetic Field direction components in original coord system.
		(Px , Py , Pz) = rank1 collection of Quasi-Radial direction components in original coord system.
		(Qx , Qy , Qz) = rank1 collection of Quasi-Azimuthal direction components in original coord system.
	
	"""
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_smooth = smooth(Bx,smooth_points)
    By_smooth = smooth(By,smooth_points)
    Bz_smooth = smooth(Bz,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_smooth / Btotal_smooth
    Ny = By_smooth / Btotal_smooth
    Nz = Bz_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    
    ephem_time = TEMP_Rx.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    TEMP_Rx = interpolate( TEMP_Rx, ephem_to_mag_ratio )
    TEMP_Ry = interpolate( TEMP_Ry , ephem_to_mag_ratio )
    TEMP_Rz = interpolate( TEMP_Rz , ephem_to_mag_ratio )
    
    TEMP_Rmag = sqrt(TEMP_Rx**2 + TEMP_Ry**2 + TEMP_Rz**2)
    
    Rx = -(TEMP_Rx/TEMP_Rmag) #Negate R so that NxR is westwards (need this for right-handedness)
    Ry = -(TEMP_Ry/TEMP_Rmag) 
    Rz = -(TEMP_Rz/TEMP_Rmag) 
    
    TEMP_Px = ( Ny * Rz ) - ( Nz * Ry )
    TEMP_Py = ( Nz * Rx ) - ( Nx * Rz )
    TEMP_Pz = ( Nx * Ry ) - ( Ny * Rx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # N x P ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx * Nx) + (By * Ny) + (Bz * Nz)
    Bp = (Bx * Px) + (By * Py) + (Bz * Pz)
    Bq = (Bx * Qx) + (By * Qy) + (Bz * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
#    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
#    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
#    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
#    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;x!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;x!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;y!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;y!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )
    
    



############################################################################
############################################################################
############################################################################
############################################################################

timerange = getParam('timerange','2018-11-01','Iteration Timerange')
version = getParam('version','0.4.1','Version number to be appended to filenames')

plotFitsAndPauseALot = True
separatePeaksWithL3Values = False

output_folder = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
#output_folder = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_Files/TEMP/'
#output_folder = 'D:/Research/ParkerProbe/SWEAP/SPC/Anisotropy/Anisotropy_Files/L0/v%s/'%(version)

m_p                  = 1.6726231E-24
q                    = 1.6022E-12
#trend_seconds        = 30     # Number of seconds over which to average magField to determine background field direction
trend_seconds        = getParam('Bfield_window' , 30 , 'Number of seconds over which to average magField to determine background field direction' )
#minFluxValueForFit   = 0.5    # Throw out/Don't fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])
minFluxValueForFit   = getParam('Minimum_VDF' , 0.5 , 'Throw out/Don\'t fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])' )
#fitSeconds           = 5     # Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)
fitSeconds           = getParam('fit_window' , 5 , 'Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)')
modFits              = getParam('mod_number' , 50 , 'Number of fits performed before updating plot/time reporting')

cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'
        
    
############################################################################
############################################################################
############################################################################
############################################################################

import java
time_begin = TimeUtil.now()    

plotFitsAndPauseALot_yn = getParam('FitPlots','F', 'Run the script while pausing and plotting each fit for test purposes?',['T','F'])
if plotFitsAndPauseALot_yn == 'T':
    plotFitsAndPauseALot = True
elif plotFitsAndPauseALot_yn == 'F':
    plotFitsAndPauseALot = False
    
        
#####
##########
#################
anisotropy_deltaPlusMinusFile = 'file:/home/kpaulson/Research/PSP/Anisotropy/TEMP_Anisotropy_DELTA_PLUS-MINUS copy.cdf'

anisotropy_deltaPlus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_PLUS')
anisotropy_deltaMinus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_MINUS')
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
#################
##########
#####
        

monitor.started()
trs= generateTimeRanges('$Y-$m-$d',timerange)
for tr in trs:
    time_begin_tr = TimeUtil.now()   
        
    try:

        #tr = '2018-11-03 18:33 to 18:39'
        #tr = '2018-11-02 16:45 to 17:20'
        #tr = '2019-04-01 07:00 to 10:00'
        #tr = '2019-04-05 17:30 to 22:30'
        #tr = '2019-04-05 18:30 to 18:40'
        #tr = '2018-11-12'
        #tr = '2018-11-04 04:40 to 06:20'
        #tr = '2019-04-01 08:00 to 08:15'
        #tr = '2018-10-30 16:10 to 20:40'
        
        monitor.setProgressMessage(tr)
        
        
        try:
            spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
            spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
            spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
            spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)
            
            mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
            mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)
        except:
            noSPCData = None
            raise java.io.FileNotFoundException
            
        print 'Downloading SPC L2 data took:',TimeUtil.now()-time_begin_tr
        time_last = TimeUtil.now()
        #spc_list = [spc_a,spc_b,spc_c,spc_d]
        
        spc_a = trim(spc_a,tr)
        spc_b = trim(spc_b,tr)
        spc_c = trim(spc_c,tr)
        spc_d = trim(spc_d,tr)
        
        mv_lo = trim(mv_lo,tr)
        mv_hi = trim(mv_hi,tr)
        #print spc_a
        
        
        #spc_a = putProperty(spc_a/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        #spc_b = putProperty(spc_b/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        #spc_c = putProperty(spc_c/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        #spc_d = putProperty(spc_d/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
        spc_list = [spc_a,spc_b,spc_c,spc_d]
        del(spc_a,spc_b,spc_c,spc_d)
        
        totalFlux = sum(spc_list)
        #totalFlux = totalFlux/((mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo))
        
        fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
        fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])
        
        U = (fluxDifference_scy/totalFlux)/0.035
        V = (fluxDifference_scx/totalFlux)/0.035
        
        U.putProperty(QDataSet.VALID_MIN,None)
        V.putProperty(QDataSet.VALID_MIN,None)
        U.putProperty(QDataSet.VALID_MAX,None)
        V.putProperty(QDataSet.VALID_MAX,None)
        
        #r0 = where(valid(U)) *(-1) + 1
        #U[r0] = -180
        #r0 = where(valid(V)) *(-1) + 1
        #V[r0] = -180
        
        for j in xrange(len(U[0,:])):
            try:
                U[:,j] = medianFilter(U[:,j],3)
            except:
                continue
            try:
                V[:,j] = medianFilter(V[:,j],3)
            except:
                continue
        
        U.putProperty(QDataSet.UNITS,Units.degrees)
        V.putProperty(QDataSet.UNITS,Units.degrees)
        
        #plot(0,totalFlux)
        #plot(1,U)
        #plot(2,V)
        
        
        #Are you measuring the slope near the peak in current or near the peak in the velocity distribution function? 
        #(the VDF goes like current divided by speed time window width in speed units)
        
        print 'Calculating Flow Angles took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        v_z = sqrt( (2./m_p) * q*(mv_lo + (mv_hi-mv_lo)/2.) ) / 1.E5   # in km/s
        windowWidths = sqrt( (2./m_p) * q*(mv_hi-mv_lo)/2.) / 1.E5
        vdf = totalFlux/(v_z*windowWidths)*1.66667E3 #This factor seems arbitrary, but is necessary to line up with Mike's L3 values.
        vdf.putProperty(QDataSet.DEPEND_1,v_z)
        del(windowWidths,mv_hi)
        
        #totalFlux = totalFlux / (mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo)
        #totalFlux = totalFlux/( (mv_hi-mv_lo))
        totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
        peaks = reduceMax(totalFlux,1)
        r = where(eq(totalFlux,peaks))
        
        print 'Defining VDF took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        plot(vdf)
    except:
        continue