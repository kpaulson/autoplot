

# ############################################################################################

def putProps( dss, name='DEPEND_0', value=None ):
    for ds in dss:
        ds.putProperty( name, value )
        
        
# ############################################################################################ 


def field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds ):
    """Routine used to define field-aligned coordinate system by smoothing over given magnetic field data.
	
	Parameters:
	    Bx = rank1 X component of magnetic field
		By = rank1 Y component of magnetic field
		Bz = rank1 Z component of magnetic field
		TEMP_Rx = rank1 X component of radial s/c position (in same coord system as B)
		TEMP_Ry = rank1 Y component of radial s/c position (in same coord system as B)
		TEMP_Rz = rank1 Z component of radial s/c position (in same coord system as B)
		trend_seconds = rank0 number of seconds over which to average B to define as background
		
    Returns:
	    (Bn , Bp , Bq) = rank1 collection of Magnetic Field components in field-aligned system.
		(Nx , Ny , Nz) = rank1 collection of Magnetic Field direction components in original coord system.
		(Px , Py , Pz) = rank1 collection of Quasi-Radial direction components in original coord system.
		(Qx , Qy , Qz) = rank1 collection of Quasi-Azimuthal direction components in original coord system.
	
	"""
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_smooth = smooth(Bx,smooth_points)
    By_smooth = smooth(By,smooth_points)
    Bz_smooth = smooth(Bz,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_smooth / Btotal_smooth
    Ny = By_smooth / Btotal_smooth
    Nz = Bz_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    
    ephem_time = TEMP_Rx.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    TEMP_Rx = interpolate( TEMP_Rx, ephem_to_mag_ratio )
    TEMP_Ry = interpolate( TEMP_Ry , ephem_to_mag_ratio )
    TEMP_Rz = interpolate( TEMP_Rz , ephem_to_mag_ratio )
    
    TEMP_Rmag = sqrt(TEMP_Rx**2 + TEMP_Ry**2 + TEMP_Rz**2)
    
    Rx = -(TEMP_Rx/TEMP_Rmag) #Negate R so that NxR is westwards (need this for right-handedness)
    Ry = -(TEMP_Ry/TEMP_Rmag) 
    Rz = -(TEMP_Rz/TEMP_Rmag) 
    
    TEMP_Px = ( Ny * Rz ) - ( Nz * Ry )
    TEMP_Py = ( Nz * Rx ) - ( Nx * Rz )
    TEMP_Pz = ( Nx * Ry ) - ( Ny * Rx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # N x P ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx * Nx) + (By * Ny) + (Bz * Nz)
    Bp = (Bx * Px) + (By * Py) + (Bz * Pz)
    Bq = (Bx * Qx) + (By * Qy) + (Bz * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
#    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
#    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
#    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
#    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;x!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;x!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;y!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;y!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )
    
    



############################################################################


        
def Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min ):
    """Polarization analysis performed on spectral components based on [Means 1972].
    
    Parameters:
        Bn_fft = rank3 fft of field-aligned magnetic component.
        Bp_fft = rank3 fft of first perpendicular magnetic component.
        Bq_fft = rank3 fft of second perpendicular magnetic component.
        Nx = rank1 X component of magnetic field direction in B_fft coordinate system.
        Ny = rank1 Y component of magnetic field direction in B_fft coordinate system.
        Nz = rank1 Z component of magnetic field direction in B_fft coordinate system.
        wave_power_min = minimum value of wave power at which to keep returned components (all lower values discarded).
    
    Returns:
        Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization"""
         
    # ###
    # ### RUN POLARIZATION ANALYSIS
    # ###
  
    ###
    ### DEFINE J_PRIME (INPUT) MATRIX ELEMENTS
    ###

    monitor.setProgressMessage('Defining J-Prime Matrix Components')

    Jxx_prime = ( (Bp_fft[:,:,0]*Bp_fft[:,:,0]) + (Bp_fft[:,:,1]*Bp_fft[:,:,1]) )
    Jyy_prime = ( (Bq_fft[:,:,0]*Bq_fft[:,:,0]) + (Bq_fft[:,:,1]*Bq_fft[:,:,1]) )
    Jzz_prime = ( (Bn_fft[:,:,0]*Bn_fft[:,:,0]) + (Bn_fft[:,:,1]*Bn_fft[:,:,1]) )

    Jxy_prime_real = ( (Bp_fft[:,:,0]*Bq_fft[:,:,0]) + (Bp_fft[:,:,1]*Bq_fft[:,:,1]) )
    Jxy_prime_img = ( (Bq_fft[:,:,0]*Bp_fft[:,:,1]) - (Bp_fft[:,:,0]*Bq_fft[:,:,1]) )

    Jxz_prime_real = ( (Bp_fft[:,:,0]*Bn_fft[:,:,0]) + (Bp_fft[:,:,1]*Bn_fft[:,:,1]) )
    Jxz_prime_img = ( (Bn_fft[:,:,0]*Bp_fft[:,:,1]) - (Bp_fft[:,:,0]*Bn_fft[:,:,1]) )

    Jyz_prime_real = ( (Bn_fft[:,:,0]*Bq_fft[:,:,0]) + (Bn_fft[:,:,1]*Bq_fft[:,:,1]) )
    Jyz_prime_img = ( (Bq_fft[:,:,0]*Bn_fft[:,:,1]) - (Bn_fft[:,:,0]*Bq_fft[:,:,1]) )

    fft_time = Jxx_prime.property(QDataSet.DEPEND_0)
    frequency_axis = Jxx_prime.property(QDataSet.DEPEND_1)



    ###
    ### DEFINE K-HAT VECTOR (MEANS - IMAGINARY COMPONENTS)
    ###

    monitor.setProgressMessage('Finding Wave-Normal Direction (Means)')

    img_mag = sqrt( Jxy_prime_img**2 + Jxz_prime_img**2 + Jyz_prime_img**2 )

    kx = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )
    ky = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )
    kz = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )
    trace = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )

    trace = Jxx_prime + Jyy_prime + Jzz_prime
    r = where(lt(abs(img_mag) , 1E-5))
    kx[r] = sqrt( Jxx_prime[r] / trace[r] )
    ky[r] = Jxy_prime_real[r] / ( trace[r] * Jxx_prime[r] )
    kz[r] = Jxz_prime_real[r] / ( trace[r] * Jxx_prime[r] )

    r0 = where(ge(abs(img_mag) , 1E-5))
    kx[r0] = Jyz_prime_img[r0] / img_mag[r0]
    ky[r0] = -Jxz_prime_img[r0] / img_mag[r0]
    kz[r0] = Jxy_prime_img[r0] / img_mag[r0]

    trace.putProperty ( QDataSet.DEPEND_0 , fft_time )
    trace.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    
    del ( img_mag )

    lowering_ratio = findex( Nx.property( QDataSet.DEPEND_0 ) , fft_time )

    Nx_fftcadence = interpolate ( Nx , lowering_ratio )
    Ny_fftcadence = interpolate ( Ny , lowering_ratio )
    Nz_fftcadence = interpolate ( Nz , lowering_ratio )

    Nx_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Ny_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Nz_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )

    for j in xrange( len( kx[1,:] ) ): # magnetic field direction is same at all times, so turn vector into an array where DEPEND_1 is constant
          Nx_fftarray[:,j] = Nx_fftcadence
          Ny_fftarray[:,j] = Ny_fftcadence
          Nz_fftarray[:,j] = Nz_fftcadence

    del ( [ Nx_fftcadence , Ny_fftcadence , Nz_fftcadence ] )

    Nx_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
    Nx_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
    Ny_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
    Ny_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
    Nz_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
    Nz_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
   
    #This is necessary because the direction of k is not the same as the direction of the wave-normal, it will depend on |B| (Look up the Means paper if confused, this took a while to understand)
    r = where(lt( ((kx * Nx_fftarray) + (ky* Ny_fftarray) + (kz * Nz_fftarray)) , 0 ))
    kx[r] = -kx[r]
    ky[r] = -ky[r]
    kz[r] = -kz[r]
                
    ###
    ### DEFINE WAVE-NORMAL COORDINATES AND ROTATE J-PRIME - DEFINE J MATRIX IN _|_ DIRECTIONS
    ###

    monitor.setProgressMessage('Creating Wave-Normal Coordinate System')
     
    theta = acos( kx*Nx_fftarray + ky*Ny_fftarray + kz*Nz_fftarray )
    factor = sin( theta )
    
    r = where(gt(theta , (PI/2)))
    theta[r] = PI - theta[r]

    Rx = ((ky * Nz_fftarray) - (kz * Ny_fftarray)) / factor # R_hat = k_hat x N_hat so is perpendicular to plane of wave normal and magnetic field
    Ry = ((kz * Nx_fftarray) - (kx * Nz_fftarray)) / factor
    Rz = ((kx * Ny_fftarray) - (ky * Nx_fftarray)) / factor

    Sx = (Ry * kz) - (Rz * ky)# S_hat = R_hat x k_hat so is in plane of wave normal and magnetic field
    Sy = (Rz * kx) - (Rx * kz)
    Sz = (Rx * ky) - (Ry * kx)

    Jxx = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jyy = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jzz = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jxy_real = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jxy_img = dblarr( len( kx[:,1] ) , len( kx[1,:] ) ) 

    monitor.setProgressMessage('Rotating J-Prime into Wave-Normal')

    ###
    ### BELOW ROTATION VECTOR TAKES UNIT VECTORS  AS COLUMNS  - correct, at least on paper I think
    ###

#    Jxx = (Jxx_prime * (Rx**2)) + (Jyy_prime * (Sx**2)) + (Jzz_prime * (kx**2)) + 2*(Jxy_prime_real*Rx*Sx + Jxz_prime_real*Rx*kx + Jyz_prime_real*Sx*kx) # THIS IS WRONG... It fucked up a lot of things and results from taking [J]=[r][J'][r]^-1 instead of [J]=[r]^-1[J'][r] (or vice versa, I can't remember now)
#    Jyy = (Jxx_prime * (Ry**2)) + (Jyy_prime * (Sy**2)) + (Jzz_prime * (ky**2)) + 2*(Jxy_prime_real*Ry*Sy + Jxz_prime_real*Ry*ky + Jyz_prime_real*Sy*ky)
#    Jzz = (Jxx_prime * (Rz**2)) + (Jyy_prime * (Sz**2)) + (Jzz_prime * (kz**2)) + 2*(Jxy_prime_real*Rz*Sz + Jxz_prime_real*Rz*kz + Jyz_prime_real*Sz*kz)

    Jxx = (Jxx_prime * (Rx**2)) + (Jyy_prime * (Ry**2)) + (Jzz_prime * (Rz**2)) + 2*(Jxy_prime_real*Rx*Ry + Jxz_prime_real*Rx*Rz + Jyz_prime_real*Ry*Rz)
    Jyy = (Jxx_prime * (Sx**2)) + (Jyy_prime * (Sy**2)) + (Jzz_prime * (Sz**2)) + 2*(Jxy_prime_real*Sx*Sy + Jxz_prime_real*Sx*Sz + Jyz_prime_real*Sy*Sz)
    Jzz = (Jxx_prime * (kx**2)) + (Jyy_prime * (ky**2)) + (Jzz_prime * (kz**2)) + 2*(Jxy_prime_real*kx*ky + Jxz_prime_real*kx*kz + Jyz_prime_real*ky*kz)

    Jxy_real = Jxx_prime*Rx*Ry + Jyy_prime*Sx*Sy + Jzz_prime*kx*ky + Jxy_prime_real*(Rx*Sy + Sx*Ry) + Jxz_prime_real*(Rx*ky + Ry*kx) + Jyz_prime_real*(ky*Sx + Sy*kx) # These two parts of the rotation are the same no matter what
    Jxy_img = Jxy_prime_img*(Rx*Sy - Sx*Ry) + Jxz_prime_img*(Rx*ky - kx*Ry) + Jyz_prime_img*(ky*Sx - Sy*kx)

    Wave_Power = Jxx + Jyy

    del ( [ factor , kx , ky , kz , Nx , Ny , Nz , Rx , Ry , Rz , Sx , Sy , Sz , Jxy_prime_real , Jxz_prime_real , Jyz_prime_real , Jxy_prime_img , Jxz_prime_img , Jyz_prime_img ] )

    ###
    ### SMOOTHING OVER FREQUENCY BINS (NECESSARY FOR POLARIZATION COMPARISON ANALYSIS)
    ###

    monitor.setProgressMessage('Smoothing Across Frequency Bins')
    
    if ( len( Jxx[1,:] ) < 5 ):
          freq_avg = 3 #number of frequency bins to average over for polarization, must be odd (is 5 too much? Its is what is in Means paper)
    else:
          freq_avg = 5

    Jxx      = smooth1(Jxx     ,freq_avg)
    Jyy      = smooth1(Jyy     ,freq_avg)
    Jzz      = smooth1(Jzz     ,freq_avg)
    Jxy_real = smooth1(Jxy_real,freq_avg)
    Jxy_img  = smooth1(Jxy_img ,freq_avg)
    
    putProps( [ Jxx, Jyy, Jzz, Jxy_real, Jxy_img, theta  ], QDataSet.DEPEND_0, fft_time )
    putProps( [ Jxx, Jyy, Jzz, Jxy_real, Jxy_img, theta  ], QDataSet.DEPEND_1, frequency_axis )

    
    J_det =  ( Jxx*Jyy - (Jxy_real*Jxy_real + Jxy_img*Jxy_img) )

    ###
    ### POWER IN MAGNETIC FIELD DIRECTIONS
    ###

    #monitor.setProgressMessage('Defining Wave Intensity')

    Power_compressional = Jzz_prime
    Power_perp = sqrt(Jxx**2 + Jyy**2) 
    #Power_transverse = Jxx_prime + Jyy_prime # upon recommendation from Chuck, this is the wave intensity rather than magnitude of diagonal elements
         
         
    ###
    ### DEFINE POLARIZATION PARAMETERS USING J MATRIX
    ###
          
    #monitor.setProgressMessage('Calculating Degree of Polarization')
    Deg_Polarization = sqrt ( 1 - ( (4 * J_det) / ( (Jxx + Jyy)**2 ) ) )
    Deg_Polarization.putProperty ( QDataSet.VALID_MIN , 0 )

    #monitor.setProgressMessage('Calculating Coherency')
    Coherency = sqrt( (Jxy_real*Jxy_real + Jxy_img*Jxy_img) / (Jxx * Jyy) )
    Coherency.putProperty ( QDataSet.VALID_MIN , 0 )

    Angle_Polarization = toDegrees( 0.5 * atan((2 * Jxx) / (Jxx - Jyy)) ) # sure Jxx isn't supposed to be Jxy_real?

    monitor.setProgressMessage('Calculating Ellipticity and Handedness')
    Handedness = ( (1 * (2 * Jxy_img) / sqrt( (Jxx + Jyy)**2 - (4 * J_det) ) ))
    Ellipticity = ( tan ( 0.5 * asin( Handedness ) ))
    Ellipticity.putProperty ( QDataSet.VALID_MIN , -1 )

    monitor.setProgressMessage('Definining Wave-Normal angle relative to |B|')
    Angle_Normal = toDegrees( theta )
    Angle_Normal.putProperty ( QDataSet.VALID_MIN , 0 )
    
    
    del ( [ Jxx , Jyy , Jzz , Jxy_real , Jxy_img , theta ] )


    ###
    ### ONLY KEEPING TERMS WITH WAVE POWER ASSOCIATED
    ###
    
    monitor.setProgressMessage('Throwing out Values of Low Wave Power')
    if ( wave_power_min > 0 ): # this executes a step function zero-ing out spectra where there are no waves (to make it easier to see what is happening) 
        r = where(lt(Wave_Power,wave_power_min))
        Angle_Normal[r] = -1
        Ellipticity[r]  = -2
        Coherency[r]    = -1

    
    ###
    ### SPIT OUT RESULTS
    ###
    
    return ( Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_Polarization , Wave_Power) 




# ############################################################################################

def Hanningfft( ds , freq_min , freq_max , window , slide ):
    """FFT routine employing sliding Hanning window function while preserving both real and imaginary components. 
    
    Parameters:
        ds = The rank1 time-series input data.
        freq_min = Lower end of frequency range to be preserved (excess thrown out to speed up subsequent processing).
        freq_max = Upper end of frequency range.
        window = Length of window to be taken measured in number of data points.
        slide = Window overlap size, expressed as a fraction of the length (1 for no slide, 2 for half steps, 4 for quarters)
        
    Returns:
        waveform_fft = The rank3 fft result of both real and imaginary components trimmed to frequency range."""
    
    ds_time = ds.property(QDataSet.DEPEND_0)
    
    ds_cadence = convertUnitsTo((ds_time[1]-ds_time[0]),Units.seconds)
    per_sec = int(1./ds_cadence)
    
    processed_ds = hanning(ds,window)

    for i in xrange( slide ):
        try:
            processed_ds = trim_it_merge_it(ds,ds_time,processed_ds,window,window*(i+1)/slide)
        except( java.lang.ArrayIndexOutOfBoundsException ):
            pass

    TEMP_waveform_fft = dblarr( len(processed_ds[:,0]) , len(processed_ds[0,:]) , 2 )

    for i in xrange( len(processed_ds[:,0]) ):
        processed_ds_fft = 2 * fft( processed_ds[i,:] )
        TEMP_waveform_fft[i,:,:] = processed_ds_fft * sqrt(float(window)/per_sec) / 1.725

    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_0 , processed_ds.property(QDataSet.DEPEND_0) )
    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_1 , processed_ds_fft[:,0].property(QDataSet.DEPEND_0)*per_sec )
    TEMP_waveform_fft.property(QDataSet.DEPEND_1).putProperty( QDataSet.UNITS , Units.hertz )

    frequency_range = where( TEMP_waveform_fft.property(QDataSet.DEPEND_1).ge(freq_min).and(TEMP_waveform_fft.property(QDataSet.DEPEND_1).le(freq_max)) )
    waveform_fft = TEMP_waveform_fft[:,frequency_range,:]
    waveform_fft.putProperty( QDataSet.DEPEND_1 , TEMP_waveform_fft.property(QDataSet.DEPEND_1)[frequency_range] )
    del ( TEMP_waveform_fft )
    
    uniqueness = uniq( waveform_fft.property(QDataSet.DEPEND_0) )
    waveform_fft_time = waveform_fft.property(QDataSet.DEPEND_0)[uniqueness]
    waveform_fft = waveform_fft[uniqueness,:,:]
    waveform_fft.putProperty( QDataSet.DEPEND_0 , waveform_fft_time )
    
    return ( waveform_fft )
        

# ############################################################################################

###
### USED IN CONJUNCTION WITH Hanningfft TO CREATE SLIDING WINDOW FUNCTION
###

def trim_it_merge_it(ds,ds_time,processed_ds,window,leading_points):
    
    
    ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    
    trimmed_ds = trim(ds,int(leading_points),int(len(ds)))
    trimmed_ds.putProperty( QDataSet.DEPEND_0 , trim(ds_time,int(leading_points),int(len(ds))) )
    
    processed_ds_too = hanning( trimmed_ds , window )
    processed_ds_too.putProperty( QDataSet.DEPEND_1 , ds.property(QDataSet.DEPEND_1) )
    
    processed_ds_time = processed_ds.property( QDataSet.DEPEND_0 )
    processed_ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    processed_ds.putProperty( QDataSet.DEPEND_0 , processed_ds_time )
    
    result = merge( processed_ds , processed_ds_too )
    return( result )


# ############################################################################################
# ############################################################################################

# ############################################################################################
# ############################################################################################


scrollingPlots    = False  # True spits out polarization plots by scrolling through data 
timerange         = '2018-11-03 18:45 to 19:30'

freq_min          = 0.2    # Minimum frequency kept for analysis
freq_max          = 8.     # Maximum frequency kept for analysis (cutting out unwanted data helps speed things up)
window            = 2048   # Number of points for FFT window -> TODO: change this to seconds?
slide             = 4      # Amount of overlap if sliding window (2=1/2, 4=3/4, 8=7/8, etc.)

wave_power_min    = 0.07   # Minimum amount of wave power in (nT^2/Hz) to keep for analysis (set to 0 to skip)

trend_seconds     = 10     # Number of seconds over which to average magField to determine background field direction

logyn             = 'T'    # Display the frequency axis logarithmically, 'T' or 'F'?
output_dir        = '/home/kpaulson/Research/PSP/Wave_Polarization/'      # Local directory for image/file storage

    

# ############################################################################################
# ############################################################################################

# ############################################################################################
# ############################################################################################

import java

power_min         = wave_power_min
power_max         = 1E2


if scrollingPlots == True:
    dds= generateTimeRanges('$Y$m$d $(H,span=6):00 ',timerange)
    monitor.started()
    monitor.setLabel('PSP Polarization')
    monitor.setTaskSize(len(dds))
    
    for ind in xrange(len(dds)):
        monitor.setTaskProgress(ind)
        monitor.setProgressMessage('Downloading Data')
        
        if ind < len(dds)-1:
            try:
                #tr = dds[ind]+' to '+str(dds[ind+1])
                tr = dds[ind]+' to '+dds[ind+1]
        
        
                mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
                mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
                
                #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
                mag = trim(mag,tr)
                
                mag_time = mag.property(QDataSet.DEPEND_0)
                
                pos = getDataSet('http://sweap.cfa.harvard.edu/data/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
                pos_time = pos.property(QDataSet.DEPEND_0)
                
                Bx = mag[:,0]
                By = mag[:,1]
                Bz = mag[:,2]
                Btotal = magnitude(mag)
                
                
                # ###
                # ### ROTATE INTO FIELD-ALIGNED COORDINATES
                # ###
                
                monitor.setProgressMessage('Rotating Data')
                
                TEMP_Rx = pos[:,0]  # Theoretically I would use a radial position vector to calculate the perpendicular field components.
                TEMP_Ry = pos[:,1]
                TEMP_Rz = pos[:,2]
                
                TEMP_Rx = ones(len(pos))   # Instead of position vector, I am just using a vector pointing in the positive X direction. For PSP and SC frame mag data, this would mean the ram direction, right?
                TEMP_Ry = zeros(len(pos))
                TEMP_Rz = zeros(len(pos))
                TEMP_Rx.putProperty(QDataSet.DEPEND_0,pos_time)
                TEMP_Ry.putProperty(QDataSet.DEPEND_0,pos_time)
                TEMP_Rz.putProperty(QDataSet.DEPEND_0,pos_time)
                
                try:
                    ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
                except:
                    TEMP_Rx = ones(len(mag))   # Instead of position vector, I am just using a vector pointing in the positive X direction. For PSP and SC frame mag data, this would mean the ram direction, right?
                    TEMP_Ry = zeros(len(mag))
                    TEMP_Rz = zeros(len(mag))
                    TEMP_Rx.putProperty(QDataSet.DEPEND_0,mag_time)
                    TEMP_Ry.putProperty(QDataSet.DEPEND_0,mag_time)
                    TEMP_Rz.putProperty(QDataSet.DEPEND_0,mag_time)
                    ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
                
                
                # ###
                # ### GENERATE FFTs
                # ###
                
                monitor.setProgressMessage('Generating FFTs')
                
                Bn_fft = Hanningfft( Bn , freq_min , freq_max , window , slide )
                Bp_fft = Hanningfft( Bp , freq_min , freq_max , window , slide )
                Bq_fft = Hanningfft( Bq , freq_min , freq_max , window , slide )
                
            
                # ###
                # ### RUN POLARIZATION
                # ###
                
                monitor.setProgressMessage('Running Polarization')
            
                ( Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization , Wave_Power) = Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min )
                
                
                # ###
                # ### PREPARE STUFF
                # ###
                
                
                background_grey = java.awt.Color(216,216,216,255)
                
                if ( logyn == 'T'):
                  logfreq = 1
                else:
                  logfreq = 0
                
                from org.das2.graph.DasColorBar.Type import APL_RAINBOW_BLACK0
                from org.das2.graph.DasColorBar.Type import BLUE_WHITE_RED_WEDGE
                from org.das2.graph.DasColorBar.Type import GRAYSCALE
                from org.das2.graph.DasColorBar.Type import INVERSE_GRAYSCALE
                from org.das2.graph.LegendPosition import *
                from org.das2.graph.SpectrogramRenderer.RebinnerEnum import lanlNearestNeighbor
                from org.das2.graph.SpectrogramRenderer.RebinnerEnum import nearestNeighbor
                
                putProps([Bp, Bq, Bn ] , QDataSet.VALID_MAX , 1E10 )
                putProps([Bp, Bq, Bn ] , QDataSet.VALID_MIN , -1E10 )
                
                
                ###
                ### PLOT STUFF
                ###
                
                monitor.setProgressMessage('Plotting Parameters')
                
                r = where(Bp.ge(-1E10).and(Bp.ge(-1E10)).and(Bp.le(1E10).and(Bp.le(1E10))))
                #Bp = Bp[r]
                #Bn = Bn[r]
                #Btime = Btime[r]
                
                y_max = 1.1 * max( max(abs(Bp[r])) , max(abs(Bn[r])) )
                
                setLayoutOverplot(2)
                plotx ( 0 , mag_time , Bp , yrange=[-y_max,y_max] , renderType='series' , title = 'Polarization parameters for PSP' , ytitle='Field!CComponents' )
                plotx ( 1 , mag_time , Bn , yrange=[-y_max,y_max] , renderType='series' )
                dom.plotElements[0].setDisplayLegend(True)
                dom.plotElements[1].style.color= Color.BLUE
                dom.plotElements[1].setDisplayLegend(True)
                
                plotx ( 2 , Wave_Power , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , zlog=1, zrange=[power_min , power_max], ztitle='Wave Intensity!C(nT!U2!N/Hz)' )#, title = 'Polarization parameters for RBSP S/C-'+SC_upper+' - '+start_date+'T'+str(start_hour))
                plotx ( 3 , Coherency , ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='Coherency', zlog=0, zrange=[0,1] )
                plotx ( 4 , Angle_Normal , ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='Wave-Normal!CRelative to |B|', zrange=[0, 90])
                plotx ( 5 , Ellipticity , ylog=logfreq , yrange=[freq_min, freq_max] , zrange=[-1 , 1], ztitle='Ellipticity!CRH               LH')#, ztitle='              Ellipticity!C!BRight                         Left!C!BHand                       Hand!N' )
                
                monitor.setProgressMessage('Tweaking Plots')
                waitUntilIdle()
                
                dom.plots[0].xaxis.drawTickLabels = 0
                dom.plots[0].controller.dasColorBar.setFillColor(background_grey)
                dom.plots[0].setDisplayLegend(True)
                dom.plots[0].setLegendPosition(OutsideNE)
                dom.plots[0].xaxis.setRange(datumRange(tr))
                
                dom.plots[1].xaxis.drawTickLabels = 0
                dom.plots[1].displayTitle = 0
                dom.plots[1].setColortable(APL_RAINBOW_BLACK0)
                dom.plots[1].controller.dasColorBar.setFillColor(background_grey)
                dom.plots[1].xaxis.setRange(datumRange(tr))
                dom.plotElements[2].style.setRebinMethod(nearestNeighbor)
                
                dom.plots[2].xaxis.drawTickLabels = 0
                dom.plots[2].displayTitle = 0
                dom.plots[2].setColortable(GRAYSCALE)
                dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
                dom.plots[2].xaxis.setRange(datumRange(tr))
                dom.plotElements[3].style.setRebinMethod(nearestNeighbor)
                
                dom.plots[3].xaxis.drawTickLabels = 0
                dom.plots[3].displayTitle = 0
                dom.plots[3].setColortable(INVERSE_GRAYSCALE)
                dom.plots[3].controller.dasColorBar.setFillColor(background_grey)
                dom.plots[3].xaxis.setRange(datumRange(tr))
                dom.plotElements[4].style.setRebinMethod(nearestNeighbor)
                
                dom.plots[4].displayTitle = 0
                dom.plots[4].setColortable(BLUE_WHITE_RED_WEDGE)
                dom.plots[4].controller.dasColorBar.setFillColor(background_grey)
                dom.plots[4].xaxis.setRange(datumRange(tr))
                dom.plotElements[5].style.setRebinMethod(nearestNeighbor)
                #dom.plots[4].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SPACECRAFT+'.dsdf&timerange='+str(starttitle)+' through '+str(endtitle)+'&interval=60'
                
                waitUntilIdle()
                fixLayout()
                
                dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more compact
                dom.plots[1].controller.dasPlot.row.ptMaximum = 10
                dom.plots[2].controller.dasPlot.row.ptMaximum = 10
                dom.plots[3].controller.dasPlot.row.ptMaximum = 10
                dom.plots[4].controller.dasPlot.row.ptMaximum = 10
                
                dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
                dom.controller.bind( dom.plots[3].yaxis, dom.plots[3].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE )
                dom.controller.bind( dom.plots[4].yaxis, dom.plots[4].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE )
                
                dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
                dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )
                dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[3].xaxis, dom.plots[3].xaxis.PROP_RANGE )
                dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[4].xaxis, dom.plots[4].xaxis.PROP_RANGE )
            
                waitUntilIdle()
                dom.plots[4].xaxis.setRange(datumRange(tr))
                
                # ###
                # ### SAVE PLOT
                # ###
                
                waitUntilIdle()
                writeToPng(output_dir+'PSP_Polarization_'+dds[ind][0:8]+'_'+dds[ind][-5:-3]+dds[ind][-2:]+'-'+dds[ind+1][-5:-3]+dds[ind+1][-2:]+'.png')
            
                #stop
            
            
                # ###
                # ### WRITE STUFF
                # ###
                
                write_stuff = False
                if write_stuff == True:
                    
                    monitor.setProgressMessage('Writing to File')
                    
                    Btime.putProperty(QDataSet.NAME,'Bfield_time')
                    fft_time.putProperty(QDataSet.NAME,'FFT_time')
                    frequency_axis.putProperty(QDataSet.NAME,'Frequencies')
                    
                    tempOutputFile = 'C:/Users/Kristoff/Desktop/TEMP_polarization'#.cdf'
                    b_wna = bundle(Bp, Bq, Bn)
                    b_wna.putProperty(QDataSet.NAME,'Bfield_wna')
                    b_wna.putProperty(QDataSet.TITLE,'Magnetic Field in wave-normal coordinates')
                    b_wna.putProperty(QDataSet.VALID_MIN,-1E10)
                    b_wna.putProperty(QDataSet.VALID_MAX, 1E10)
                    b_wna.putProperty(QDataSet.DEPEND_0, Btime)
                    
                    failedToWrite = True
                    write_fail_counter = 0
                    while failedToWrite == True:
                        try:
                            formatDataSet(b_wna,tempOutputFile+'.cdf')
                            failedToWrite = False
                        except:
                            write_fail_counter+=1
                            tempOutputFile = tempOutputFile+str(write_fail_counter)
                    tempOutputFile = tempOutputFile+'.cdf'
                    
                    Coherency.putProperty(QDataSet.NAME,'Coherency')
                    Coherency.putProperty(QDataSet.VALID_MIN,0)
                    Coherency.putProperty(QDataSet.VALID_MAX,1)
                    Ellipticity.putProperty(QDataSet.NAME,'Ellipticity')
                    Ellipticity.putProperty(QDataSet.VALID_MIN,-1)
                    Ellipticity.putProperty(QDataSet.VALID_MAX,1)
                    Angle_Normal.putProperty(QDataSet.NAME,'Angle_Normal')
                    Angle_Normal.putProperty(QDataSet.VALID_MIN,0)
                    Angle_Normal.putProperty(QDataSet.VALID_MAX,90)
                    Power_perp.putProperty(QDataSet.NAME,'Power_Perp')
                    Power_perp.putProperty(QDataSet.UNITS,Units.lookupUnits('nT!U2!N/Hz'))
                    Power_perp.putProperty(QDataSet.VALID_MIN,0)
                    Power_perp.putProperty(QDataSet.VALID_MAX,1E10)
                    Power_par.putProperty(QDataSet.NAME,'Power_Par')
                    Power_par.putProperty(QDataSet.UNITS,Units.lookupUnits('nT!U2!N/Hz'))
                    Power_par.putProperty(QDataSet.VALID_MIN,0)
                    Power_par.putProperty(QDataSet.VALID_MAX,1E10)
                    
                    putProps([Coherency, Ellipticity, Angle_Normal, Power_perp, Power_par] , QDataSet.DEPEND_0 , fft_time )
                    putProps([Coherency, Ellipticity, Angle_Normal, Power_perp, Power_par] , QDataSet.DEPEND_1 , frequency_axis )
                    
                    formatDataSet(Power_perp,tempOutputFile+'?append=T')
                    formatDataSet(Power_par,tempOutputFile+'?append=T')
                    formatDataSet(Coherency,tempOutputFile+'?append=T')
                    formatDataSet(Ellipticity,tempOutputFile+'?append=T')
                    formatDataSet(Angle_Normal,tempOutputFile+'?append=T')
                    
            except:
                
                continue
                
elif scrollingPlots == False:
    
    monitor.started()
    monitor.setLabel('PSP Polarization')
    #monitor.setTaskSize(len(dds))
    
    #tr = dds[ind]+' to '+str(dds[ind+1])
    tr = timerange


    mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
    mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
    
    #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
    mag = trim(mag,tr)
    
    mag_time = mag.property(QDataSet.DEPEND_0)
    
    pos = getDataSet('http://sweap.cfa.harvard.edu/data/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
    pos_time = pos.property(QDataSet.DEPEND_0)
    
    Bx = mag[:,0]
    By = mag[:,1]
    Bz = mag[:,2]
    Btotal = magnitude(mag)
    
    
    # ###
    # ### ROTATE INTO FIELD-ALIGNED COORDINATES
    # ###
    
    monitor.setProgressMessage('Rotating Data')
    
    TEMP_Rx = pos[:,0]  # Theoretically I would use a radial position vector to calculate the perpendicular field components.
    TEMP_Ry = pos[:,1]
    TEMP_Rz = pos[:,2]
    
    TEMP_Rx = ones(len(pos))   # Instead of position vector, I am just using a vector pointing in the positive X direction. For PSP and SC frame mag data, this would mean the ram direction, right?
    TEMP_Ry = zeros(len(pos))
    TEMP_Rz = zeros(len(pos))
    TEMP_Rx.putProperty(QDataSet.DEPEND_0,pos_time)
    TEMP_Ry.putProperty(QDataSet.DEPEND_0,pos_time)
    TEMP_Rz.putProperty(QDataSet.DEPEND_0,pos_time)
    
    try:
        ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
    except:
        TEMP_Rx = ones(len(mag))   # Instead of position vector, I am just using a vector pointing in the positive X direction. For PSP and SC frame mag data, this would mean the ram direction, right?
        TEMP_Ry = zeros(len(mag))
        TEMP_Rz = zeros(len(mag))
        TEMP_Rx.putProperty(QDataSet.DEPEND_0,mag_time)
        TEMP_Ry.putProperty(QDataSet.DEPEND_0,mag_time)
        TEMP_Rz.putProperty(QDataSet.DEPEND_0,mag_time)
        ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
    
    
    # ###
    # ### GENERATE FFTs
    # ###
    
    monitor.setProgressMessage('Generating FFTs')
    
    Bn_fft = Hanningfft( Bn , freq_min , freq_max , window , slide )
    Bp_fft = Hanningfft( Bp , freq_min , freq_max , window , slide )
    Bq_fft = Hanningfft( Bq , freq_min , freq_max , window , slide )
    

    # ###
    # ### RUN POLARIZATION
    # ###
    
    monitor.setProgressMessage('Running Polarization')

    ( Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization , Wave_Power) = Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min )
    
    
    # ###
    # ### PREPARE STUFF
    # ###
    
    
    background_grey = java.awt.Color(216,216,216,255)
    
    if ( logyn == 'T'):
      logfreq = 1
    else:
      logfreq = 0
    
    from org.das2.graph.DasColorBar.Type import APL_RAINBOW_BLACK0
    from org.das2.graph.DasColorBar.Type import BLUE_WHITE_RED_WEDGE
    from org.das2.graph.DasColorBar.Type import GRAYSCALE
    from org.das2.graph.DasColorBar.Type import INVERSE_GRAYSCALE
    from org.das2.graph.LegendPosition import *
    from org.das2.graph.SpectrogramRenderer.RebinnerEnum import lanlNearestNeighbor
    from org.das2.graph.SpectrogramRenderer.RebinnerEnum import nearestNeighbor
    
    putProps([Bp, Bq, Bn ] , QDataSet.VALID_MAX , 1E10 )
    putProps([Bp, Bq, Bn ] , QDataSet.VALID_MIN , -1E10 )
    
    
    ###
    ### PLOT STUFF
    ###
    
    monitor.setProgressMessage('Plotting Parameters')
    
    r = where(Bp.ge(-1E10).and(Bp.ge(-1E10)).and(Bp.le(1E10).and(Bp.le(1E10))))
    #Bp = Bp[r]
    #Bn = Bn[r]
    #Btime = Btime[r]
    
    y_max = 1.1 * max( max(abs(Bp[r])) , max(abs(Bn[r])) )
    
    setLayoutOverplot(2)
    plotx ( 0 , mag_time , Bp , yrange=[-y_max,y_max] , renderType='series' , title = 'Polarization parameters for PSP' , ytitle='Field!CComponents' )
    plotx ( 1 , mag_time , Bn , yrange=[-y_max,y_max] , renderType='series' )
    dom.plotElements[0].setDisplayLegend(True)
    dom.plotElements[1].style.color= Color.BLUE
    dom.plotElements[1].setDisplayLegend(True)
    
    plotx ( 2 , Wave_Power , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , zlog=1, zrange=[power_min , power_max], ztitle='Wave Intensity!C(nT!U2!N/Hz)' )#, title = 'Polarization parameters for RBSP S/C-'+SC_upper+' - '+start_date+'T'+str(start_hour))
    plotx ( 3 , Coherency , ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='Coherency', zlog=0, zrange=[0,1] )
    plotx ( 4 , Angle_Normal , ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='Wave-Normal!CRelative to |B|', zrange=[0, 90])
    plotx ( 5 , Ellipticity , ylog=logfreq , yrange=[freq_min, freq_max] , zrange=[-1 , 1], ztitle='Ellipticity!CRH               LH')#, ztitle='              Ellipticity!C!BRight                         Left!C!BHand                       Hand!N' )
    
    monitor.setProgressMessage('Tweaking Plots')
    waitUntilIdle()
    
    dom.plots[0].xaxis.drawTickLabels = 0
    dom.plots[0].controller.dasColorBar.setFillColor(background_grey)
    dom.plots[0].setDisplayLegend(True)
    dom.plots[0].setLegendPosition(OutsideNE)
    dom.plots[0].xaxis.setRange(datumRange(tr))
    
    dom.plots[1].xaxis.drawTickLabels = 0
    dom.plots[1].displayTitle = 0
    dom.plots[1].setColortable(APL_RAINBOW_BLACK0)
    dom.plots[1].controller.dasColorBar.setFillColor(background_grey)
    dom.plots[1].xaxis.setRange(datumRange(tr))
    dom.plotElements[2].style.setRebinMethod(nearestNeighbor)
    
    dom.plots[2].xaxis.drawTickLabels = 0
    dom.plots[2].displayTitle = 0
    dom.plots[2].setColortable(GRAYSCALE)
    dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
    dom.plots[2].xaxis.setRange(datumRange(tr))
    dom.plotElements[3].style.setRebinMethod(nearestNeighbor)
    
    dom.plots[3].xaxis.drawTickLabels = 0
    dom.plots[3].displayTitle = 0
    dom.plots[3].setColortable(INVERSE_GRAYSCALE)
    dom.plots[3].controller.dasColorBar.setFillColor(background_grey)
    dom.plots[3].xaxis.setRange(datumRange(tr))
    dom.plotElements[4].style.setRebinMethod(nearestNeighbor)
    
    dom.plots[4].displayTitle = 0
    dom.plots[4].setColortable(BLUE_WHITE_RED_WEDGE)
    dom.plots[4].controller.dasColorBar.setFillColor(background_grey)
    dom.plots[4].xaxis.setRange(datumRange(tr))
    dom.plotElements[5].style.setRebinMethod(nearestNeighbor)
    #dom.plots[4].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SPACECRAFT+'.dsdf&timerange='+str(starttitle)+' through '+str(endtitle)+'&interval=60'
    
    waitUntilIdle()
    fixLayout()
    
    dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more compact
    dom.plots[1].controller.dasPlot.row.ptMaximum = 10
    dom.plots[2].controller.dasPlot.row.ptMaximum = 10
    dom.plots[3].controller.dasPlot.row.ptMaximum = 10
    dom.plots[4].controller.dasPlot.row.ptMaximum = 10
    
    dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
    dom.controller.bind( dom.plots[3].yaxis, dom.plots[3].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE )
    dom.controller.bind( dom.plots[4].yaxis, dom.plots[4].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE )
    
    dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
    dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )
    dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[3].xaxis, dom.plots[3].xaxis.PROP_RANGE )
    dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[4].xaxis, dom.plots[4].xaxis.PROP_RANGE )

    waitUntilIdle()
    dom.plots[4].xaxis.setRange(datumRange(tr))
    
    # ###
    # ### SAVE PLOT
    # ###
    
    waitUntilIdle()
    #writeToPng(output_dir+'PSP_Polarization_'+dds[ind][0:8]+'_'+dds[ind][-5:-3]+dds[ind][-2:]+'-'+dds[ind+1][-5:-3]+dds[ind+1][-2:]+'.png')

    #stop


    # ###
    # ### WRITE STUFF
    # ###
    
    write_stuff = False
    if write_stuff == True:
        
        monitor.setProgressMessage('Writing to File')
        
        Btime.putProperty(QDataSet.NAME,'Bfield_time')
        fft_time.putProperty(QDataSet.NAME,'FFT_time')
        frequency_axis.putProperty(QDataSet.NAME,'Frequencies')
        
        tempOutputFile = 'C:/Users/Kristoff/Desktop/TEMP_polarization'#.cdf'
        b_wna = bundle(Bp, Bq, Bn)
        b_wna.putProperty(QDataSet.NAME,'Bfield_wna')
        b_wna.putProperty(QDataSet.TITLE,'Magnetic Field in wave-normal coordinates')
        b_wna.putProperty(QDataSet.VALID_MIN,-1E10)
        b_wna.putProperty(QDataSet.VALID_MAX, 1E10)
        b_wna.putProperty(QDataSet.DEPEND_0, Btime)
        
        failedToWrite = True
        write_fail_counter = 0
        while failedToWrite == True:
            try:
                formatDataSet(b_wna,tempOutputFile+'.cdf')
                failedToWrite = False
            except:
                write_fail_counter+=1
                tempOutputFile = tempOutputFile+str(write_fail_counter)
        tempOutputFile = tempOutputFile+'.cdf'
        
        Coherency.putProperty(QDataSet.NAME,'Coherency')
        Coherency.putProperty(QDataSet.VALID_MIN,0)
        Coherency.putProperty(QDataSet.VALID_MAX,1)
        Ellipticity.putProperty(QDataSet.NAME,'Ellipticity')
        Ellipticity.putProperty(QDataSet.VALID_MIN,-1)
        Ellipticity.putProperty(QDataSet.VALID_MAX,1)
        Angle_Normal.putProperty(QDataSet.NAME,'Angle_Normal')
        Angle_Normal.putProperty(QDataSet.VALID_MIN,0)
        Angle_Normal.putProperty(QDataSet.VALID_MAX,90)
        Power_perp.putProperty(QDataSet.NAME,'Power_Perp')
        Power_perp.putProperty(QDataSet.UNITS,Units.lookupUnits('nT!U2!N/Hz'))
        Power_perp.putProperty(QDataSet.VALID_MIN,0)
        Power_perp.putProperty(QDataSet.VALID_MAX,1E10)
        Power_par.putProperty(QDataSet.NAME,'Power_Par')
        Power_par.putProperty(QDataSet.UNITS,Units.lookupUnits('nT!U2!N/Hz'))
        Power_par.putProperty(QDataSet.VALID_MIN,0)
        Power_par.putProperty(QDataSet.VALID_MAX,1E10)
        
        putProps([Coherency, Ellipticity, Angle_Normal, Power_perp, Power_par] , QDataSet.DEPEND_0 , fft_time )
        putProps([Coherency, Ellipticity, Angle_Normal, Power_perp, Power_par] , QDataSet.DEPEND_1 , frequency_axis )
        
        formatDataSet(Power_perp,tempOutputFile+'?append=T')
        formatDataSet(Power_par,tempOutputFile+'?append=T')
        formatDataSet(Coherency,tempOutputFile+'?append=T')
        formatDataSet(Ellipticity,tempOutputFile+'?append=T')
        formatDataSet(Angle_Normal,tempOutputFile+'?append=T')

monitor.finished()


