
############################################################################
##################            VARIABLES          ###########################
############################################################################
############################################################################


#timerange = getParam('timerange','2018-11-01 06:00 to 08:00','Iteration Timerange')
timerange = getParam('timerange','2019-08-26','Iteration Timerange')
#timerange = getParam('timerange','2019-04-04 01:22 to 01:23','Iteration Timerange') #Why no Chi?
#timerange = getParam('timerange','2018-11-04 5:00 to 5:10','Iteration Timerange')
version = getParam('version','0.4.4','Version number to be appended to filenames')

separatePeaksWithL3Values = False
writeStuff = True
useVDFFluxForWeights = True
conflateAndDownsampleSpectra = False
analyzingTimeWidthComparisons = False



m_p                  = 1.6726231E-24
q                    = 1.6022E-12
#trend_seconds        = 30     # Number of seconds over which to average magField to determine background field direction
trend_seconds        = getParam('Bfield_window' , 60 , 'Number of seconds over which to average magField to determine background field direction' )
#minFluxValueForFit   = 0.5    # Throw out/Don't fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])
minFluxValueForFit   = getParam('Minimum_VDF' , 0.5 , 'Throw out/Don\'t fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])' )
#fitSeconds           = 5     # Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)
fitSeconds           = getParam('fit_window' , 8 , 'Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)')
modFits              = getParam('mod_number' , 500 , 'Number of fits performed before updating plot/time reporting')
#smoothPoints         = getParam('smoothPoints' , 5 , 'Number of spectra to average together before defining flow directions')
smoothSeconds = fitSeconds

angleBinWdith        = getParam('angleBinWidth' , 4 , 'Width of bins in degrees making up incident field angle axis of uncertainty map')
anisotropyBinNumber  = getParam('anisotropyBinNumber' , 30 , 'Number of bins making up anisotropy axis of uncertainty map')

cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/sweap/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'

useLocalSubprocesses = True

plotFitsAndPauseALot_yn = getParam('FitPlots','F', 'Run the script while pausing and plotting each fit for test purposes?',['T','F'])

############################################################################
##################            IMPORTS            ###########################
############################################################################
############################################################################
    

import sys
try:
    if useLocalSubprocesses == True:
        raise stopLookingOnlineException
    ### IMPORT SUBPROCESSES
    findVDFAnisotropy = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSP/PSPSubProcesses/findVDFAnisotropy.jy',monitor.getSubtaskMonitor('import findVDFAnisotropy()'))
    execfile( findVDFAnisotropy.toString() )
    
    writeAnisotropyL0 = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSP/PSPSubProcesses/writeAnisotropyL0.jy',monitor.getSubtaskMonitor('import writeAnisotropyL0()'))
    execfile( writeAnisotropyL0.toString() )
    
    field_aligner = getFile( 'https://github.com/kpaulson/autoplot/blob/master/CoreSubprocesses/Field_Aligner.jy',monitor.getSubtaskMonitor('import field_aligner()'))
    execfile( field_aligner.toString() )

    get_OS_version = getFile( 'https://github.com/kpaulson/autoplot/blob/master/CoreSubprocesses/get_os_version.jy',monitor.getSubtaskMonitor('import get_os_version()'))
    execfile( get_OS_version.toString() )

    getSPCAnisotropyUncertaintyMaps = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSP/PSPSubProcesses/getSPCAnisotropyUncertaintyMaps.jy',monitor.getSubtaskMonitor('import getSPCAnisotropyUncertaintyMaps()'))
    execfile( getSPCAnisotropyUncertaintyMaps.toString() )

    smoothSPCByVoltage = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSP/PSPSubProcesses/smoothSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothSPCByVoltage()'))
    execfile( smoothSPCByVoltage.toString() )

    smoothAndDownsampleSPCByVoltage = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSP/PSPSubProcesses/smoothAndDownsampleSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothAndDownsampleSPCByVoltage()'))
    execfile( smoothAndDownsampleSPCByVoltage.toString() )
    
except:
    print 'Unable to grab subprocess from github'
    
    findVDFAnisotropy = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/PSP/PSPSubProcesses/findVDFAnisotropy.jy',monitor.getSubtaskMonitor('import findVDFAnisotropy()'))
    execfile( findVDFAnisotropy.toString() )
    
    writeAnisotropyL0 = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/PSP/PSPSubProcesses/writeAnisotropyL0.jy',monitor.getSubtaskMonitor('import writeAnisotropyL0()'))
    execfile( writeAnisotropyL0.toString() )
    
    field_aligner = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/CoreSubprocesses/Field_Aligner.jy',monitor.getSubtaskMonitor('import field_aligner()'))
    execfile( field_aligner.toString() )

    get_OS_version = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/CoreSubprocesses/get_os_version.jy',monitor.getSubtaskMonitor('import get_os_version()'))
    execfile( get_OS_version.toString() )

    getSPCAnisotropyUncertaintyMaps = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/PSP/PSPSubProcesses/getSPCAnisotropyUncertaintyMaps.jy',monitor.getSubtaskMonitor('import getSPCAnisotropyUncertaintyMaps()'))
    execfile( getSPCAnisotropyUncertaintyMaps.toString() )

    smoothSPCByVoltage = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/PSP/PSPSubProcesses/smoothSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothSPCByVoltage()'))
    execfile( smoothSPCByVoltage.toString() )

    smoothAndDownsampleSPCByVoltage = getFile( 'C:/Users/kpaulson/Software/Autoplot/GithubScripts/PSP/PSPSubProcesses/smoothAndDownsampleSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothAndDownsampleSPCByVoltage()'))
    execfile( smoothAndDownsampleSPCByVoltage.toString() )
       
from org.apache.commons.math.optimization.fitting import CurveFitter
from org.apache.commons.math.optimization.fitting import ParametricRealFunction
from org.apache.commons.math.optimization.fitting import WeightedObservedPoint
from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer
from org.apache.commons.math.stat.regression      import SimpleRegression

OS = get_os_version().split()[0]
if OS == 'mac':
    googleDrive_path = 'file:///Volumes/Macintosh HD/Volumes/GoogleDrive/My Drive/'
elif OS == 'windows':
    googleDrive_path = '/Users/kpaulson/GoogleDrive/'

addToSearchPath(sys.path,googleDrive_path+'Software/Autoplot/jar/commons-math3-3.6.1.jar',monitor)

from org.apache.commons.math3.fitting import AbstractCurveFitter
from org.apache.commons.math3.fitting import SimpleCurveFitter
from org.apache.commons.math3.fitting.leastsquares import LevenbergMarquardtOptimizer as LMO
from org.apache.commons.math3.fitting.leastsquares import GaussNewtonOptimizer
from org.apache.commons.math3.analysis import ParametricUnivariateFunction

class LinFit(ParametricRealFunction):
#class LinFit(ParametricUnivariateFunction):
    def value(self, x, params):
        a = params[0]
        b = params[1]
        return (a*x + b)
    def gradient(self, x, params):
        a = params[0]
        b = params[1]
        return [x,1]


############################################################################
##################            DEFINITIONS        ###########################
############################################################################
############################################################################
    
    
if analyzingTimeWidthComparisons == True:
    output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/TEMP/L0/v%s/'%(version)
elif analyzingTimeWidthComparisons == False:
    output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
    
if plotFitsAndPauseALot_yn == 'T':
    plotFitsAndPauseALot = True
elif plotFitsAndPauseALot_yn == 'F':
    plotFitsAndPauseALot = False
    
    
def fittingUncertainties(fitResult,tempVDF,tempvz,tempvq,tempBq):
    r = where(ge(tempVDF,minFluxValueForFit).and(valid(tempVDF)).and(valid(tempvz)))  # Removes points from the measurement below a particular threschhold
    VDF_fitValues = where(gt(tempVDF[r],0))
    temp_fitValues = (fitResult[0]*(tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues]) + fitResult[1])
    temp_residualVariance = ( tempvq[r][VDF_fitValues] - temp_fitValues )**2
    
    try:
        temp_chiSquared = total( abs( temp_residualVariance / temp_fitValues ) )
        temp_chiSquaredReduced = temp_chiSquared / (len(tempvz[r][VDF_fitValues]) - 2)
    except:
        temp_chiSquaredReduced = -1E38
    try:
        temp_totalVariance = (tempvq[r][VDF_fitValues] - mean(tempvq[r][VDF_fitValues]))**2
        temp_rSquared = 1 - ( total(temp_residualVariance) / total(temp_totalVariance) )
        temp_abscissaVariance = ( (tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues]) - mean((tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues])) )**2
        temp_slopeError = sqrt( total(temp_residualVariance) / total(temp_abscissaVariance) ) / (len(tempvz[r][VDF_fitValues]) - 2)
    except:
        temp_rSquared = -1E38
        temp_slopeError = -1E38
    
    return(temp_chiSquaredReduced,temp_rSquared,temp_slopeError)
                        
    
    
############################################################################
#################            BEGIN SCRIPT        ###########################
############################################################################
############################################################################

import java
time_begin = TimeUtil.now()    

    
        
# Set up error/uncertainty maps
(anisotropy_deltaPlus,anisotropy_deltaMinus) = getSPCAnisotropyUncertaintyMaps(angleBinWdith,anisotropyBinNumber,OS)
   
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)


# Split analysis by day
monitor.started()
trs= generateTimeRanges('$Y-$m-$d',timerange)
for tr in trs:
    time_begin_tr = TimeUtil.now() 
    timeTitle = str(tr)    
    
    if lt(datumRange(timerange).width(), datumRange(tr).width()):
        tr = timerange
        tp_begin = TimeParser.create('$Y-$m-$dT$H$M')
        tp_end = TimeParser.create('-$H$M')
        timeTitle = tp_begin.format(datumRange(timerange).min())+tp_end.format(datumRange(timerange).max())

        
    try:
        monitor.setLabel('Downloading SPC') 
        
        monitor.setProgressMessage(tr)
        
        try:
            print cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)'
            spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
            spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
            spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
            spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)
            
            mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
            mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)
        except:
            noSPCData = None
            raise java.io.FileNotFoundException
        
            
        print 'Downloading SPC L2 data took:',TimeUtil.now()-time_begin_tr
        time_last = TimeUtil.now()
        #spc_list = [spc_a,spc_b,spc_c,spc_d]
        
        spc_a = trim(spc_a,tr)
        spc_b = trim(spc_b,tr)
        spc_c = trim(spc_c,tr)
        spc_d = trim(spc_d,tr)
        
        mv_lo = trim(mv_lo,tr)
        mv_hi = trim(mv_hi,tr)
        
        if conflateAndDownsampleSpectra == True:
            monitor.setLabel('Downsampling') 
            
            spc_a = smoothAndDownsampleSPCByVoltage(spc_a,mv_lo,smoothSeconds/3.)
            spc_b = smoothAndDownsampleSPCByVoltage(spc_b,mv_lo,smoothSeconds/3.)
            spc_c = smoothAndDownsampleSPCByVoltage(spc_c,mv_lo,smoothSeconds/3.)
            spc_d = smoothAndDownsampleSPCByVoltage(spc_d,mv_lo,smoothSeconds/3.)
            
            mv_lo = spc_a.property(QDataSet.DEPEND_1)
            mv_hi = synchronize(mv_lo,mv_hi)
            
        
        print 'Smoothing and downsampling data took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        monitor.setLabel('Flow Angles') 
        spc_list = [spc_a,spc_b,spc_c,spc_d]
        del(spc_a,spc_b,spc_c,spc_d)
        
        totalFlux = sum(spc_list)
        
        fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
        fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])
        
        U = (fluxDifference_scy/totalFlux)/0.035
        V = (fluxDifference_scx/totalFlux)/0.035
        
        U.putProperty(QDataSet.VALID_MIN,None)
        V.putProperty(QDataSet.VALID_MIN,None)
        U.putProperty(QDataSet.VALID_MAX,None)
        V.putProperty(QDataSet.VALID_MAX,None)
        

        # This part is in there to match Mike's measurement of Bulk Flow Directions, 
        # but we should pull it out for our fitting, right? - Yes, right now it filters over index for rank2 instead of DEPEND_1 so you get bad results
#        for j in xrange(len(U[0,:])):
#            try:
#                U[:,j] = medianFilter(U[:,j],3)
#            except:
#                continue
#            try:
#                V[:,j] = medianFilter(V[:,j],3)
#            except:
#                continue
        
        U.putProperty(QDataSet.UNITS,Units.degrees)
        V.putProperty(QDataSet.UNITS,Units.degrees)
        
        
        
        #Are you measuring the slope near the peak in current or near the peak in the velocity distribution function? 
        #(the VDF goes like current divided by speed time window width in speed units)
        
        print 'Calculating Flow Angles took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        
        monitor.setLabel('Defining VDF')
        vdfList = list() 
        v_z = sqrt( (2./m_p) * q*(mv_lo + (mv_hi-mv_lo)/2.) ) / 1.E5   # in km/s
        windowWidths = sqrt( (2./m_p) * q*(mv_hi-mv_lo)/2.) / 1.E5
        vdf_full = totalFlux/(v_z*windowWidths)*1.66667E3 #This factor seems arbitrary, but is necessary to line up with Mike's L3 values.
        vdf_full.putProperty(QDataSet.DEPEND_1,v_z)
        vdfList.append('vdf_full')
        del(windowWidths,mv_hi)
        
        # This step is meant to be a further step in removing full scans, but is probably not set properly
#        if manuallyRemoveFullScans == True:
#            for i in xrange(len(v_z)):
#                if gt(v_z[i,max(where(valid(v_z[i,:])))] - v_z[i,min(where(valid(v_z[i,:])))],500):
#                    vdf[i,:] = -1E38
        
        totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
        #peaks = reduceMax(totalFlux,1)
        #r = where(eq(totalFlux,peaks))
        peaks = reduceMax(vdf_full,1)
        r = where(eq(vdf_full,peaks))
        
        print 'Defining VDF took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        # If we want to use the peaks as weights in fitting, import L3 data and build model distributions
        if separatePeaksWithL3Values == True:
            sweap_spc_file = 'http://sweap.cfa.harvard.edu/data/sci/sweap/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf'
            
            DQF = getDataSet(sweap_spc_file+'?DQF',tr)
            goodFlags = where(eq(DQF[:,0],0))

            np_fit = getDataSet(sweap_spc_file+'?np_fit',tr)[goodFlags]
            wp_fit = getDataSet(sweap_spc_file+'?wp_fit',tr)[goodFlags]
            vp_fit_SC = getDataSet(sweap_spc_file+'?vp_fit_SC',tr)[goodFlags]
            vp_fit = magnitude(vp_fit_SC)
            spc_time = np_fit.property(QDataSet.DEPEND_0)
            
            np1_fit = getDataSet(sweap_spc_file+'?np1_fit',tr)[goodFlags]
            wp1_fit = getDataSet(sweap_spc_file+'?wp1_fit',tr)[goodFlags]
            vp1_fit_SC = getDataSet(sweap_spc_file+'?vp1_fit_SC',tr)[goodFlags]
            vp1_fit = magnitude(vp1_fit_SC)
            
            n3_fit = getDataSet(sweap_spc_file+'?n3_fit',tr)[goodFlags]
            w3_fit = getDataSet(sweap_spc_file+'?w3_fit',tr)[goodFlags]
            v3_fit_SC = getDataSet(sweap_spc_file+'?v3_fit_SC',tr)[goodFlags]
            v3_fit = magnitude(v3_fit_SC)
            
            na_fit = getDataSet(sweap_spc_file+'?na_fit',tr)[goodFlags]
            wa_fit = getDataSet(sweap_spc_file+'?wa_fit',tr)[goodFlags]
            va_fit_SC = getDataSet(sweap_spc_file+'?va_fit_SC',tr)[goodFlags]
            va_fit = magnitude(va_fit_SC)
            
            # Define Gaussian parameters
            cp = wp_fit            
            ap = np_fit / (cp*sqrt(PI))         
            bp = vp_fit
            
            cp1 = wp1_fit     
            ap1 = np1_fit / (cp1*sqrt(PI))                
            bp1 = vp1_fit
            
            c3 = w3_fit     
            a3 = n3_fit / (c3*sqrt(PI))                
            b3 = v3_fit
            
            ca = wa_fit    
            aa = (na_fit/2.) / (ca*sqrt(PI))                 
            ba = va_fit * sqrt(2.)
            
            (ap,bp,cp) = synchronize(v_z,[ap,bp,cp])
            (ap1,bp1,cp1) = synchronize(v_z,[ap1,bp1,cp1])
            (a3,b3,c3) = synchronize(v_z,[a3,b3,c3])
            (aa,ba,ca) = synchronize(v_z,[aa,ba,ca])
            
            
            v_space = copy(v_z)
            v_space_time = v_space.property(QDataSet.DEPEND_0)
            vdf_p  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_p1 = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_3  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_a  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            v_index = 0
            for v_index in xrange(len(v_space[0,:])):
                
                #peak_p[:,v_index]  = ap*exp(-((v_space[:,v_index] - bp)**2 / (2*cp**2)))
                #peak_p1[:,v_index] = ap1*exp(-((v_space[:,v_index] - bp1)**2 / (2*cp1**2)))
                #peak_a[:,v_index]  = aa*exp(-((v_space_a[:,v_index] - ba)**2 / (2*ca**2)))
                
                vdf_p[:,v_index]  = ap *exp(-((v_space[:,v_index]   - bp )**2 / (cp**2)))
                vdf_p1[:,v_index] = ap1*exp(-((v_space[:,v_index]   - bp1)**2 / (cp1**2)))
                vdf_3[:,v_index]  = a3 *exp(-((v_space[:,v_index]   - b3 )**2 / (c3**2)))
                vdf_a[:,v_index]  = aa *exp(-((v_space[:,v_index]   - ba )**2 / (ca**2)))
                #v_index+=1
            
            vdf_p.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_p.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_p.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_p.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_p1.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_p1.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_p1.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_p1.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_3.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_3.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_3.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_3.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_a.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_a.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_a.putProperty(QDataSet.VALID_MIN,0)
            vdf_a.putProperty(QDataSet.VALID_MAX,1E20)
            
            plot(0,vdf_p1)
            plot(1,vdf_3)
            plot(2,vdf_a)
            
            vdfList.append('vdf_p1')
            vdfList.append('vdf_3')
            vdfList.append('vdf_a')
            #stop
            
            print 'Building Peaks took:',TimeUtil.now()-time_last
            time_last = TimeUtil.now()
        
        
        vz_tanTheta = v_z * tan(toRadians(V))     # Vx
        vz_tanPhi   = v_z * tan(toRadians(U))     # Vy
        #plot(vz_tanPhi)
        #stop
        
        # Define background flow to avoid weird slope values?
        u_x = vz_tanTheta[r]
        u_y = vz_tanPhi[r]
        u_z = v_z[r]
        
        if 'alreadyPlottedOnce' not in globals():
            #setLayoutOverplot(4) 
            load(googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/anisotropyFromMath_DayOverviewPlotter.vap')
        
        #plot(0,totalFlux)
        plot(0,vdf_full,xrange=tr, colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle='VDF (cm!U-3!N km!U-1!N s)',zlog=True)
        plot(1,v_z[r])
        alreadyPlottedOnce = True
        #stop
        #plot(0,vz_tanTheta-synchronize(vz_tanTheta,u_x))
        
        #####
        ##########
        #################
        try:
            mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/sweap/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
            mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
            print 'Used mag data from:',mag_datafile
        except:
            try:
                mag_datafile = googleDrive_path+'Research/Data/AutoplotCache/http/w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
                mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
                print 'Used mag data from:',mag_datafile
            except:
                mag_datafile = 'http://research.ssl.berkeley.edu/data/spp/data/sci/fields/staging/l2/mag_SC/$Y/$m/psp_fld_l2_mag_SC_$Y$m$d$(H,span=6)_v$v.cdf'
                mag = getDataSet(mag_datafile+'?psp_fld_l2_mag_SC',tr)
                print 'Used mag data from:',mag_datafile
                
        #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
        mag = trim(mag,tr)
        
        mag_time = mag.property(QDataSet.DEPEND_0)
        
        pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/sweap/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
        pos_time = pos.property(QDataSet.DEPEND_0)
        
        Bx = mag[:,0]
        By = mag[:,1]
        Bz = mag[:,2]
        Btotal = magnitude(mag)
        
        # These inputs are arbitrary since we don't really care what the B_perp directions are for now. Does not affect outcome
        TEMP_Rx = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Ry = putProperty(-1*ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Rz = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        
        
        ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
        
        #################
        ##########
        #####
        
        print 'Downloading MAG Data took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        
        
        
        for vdf in vdfList:
            if vdf == 'vdf_full':
                vdf_in = vdf_full
                u_x_in = u_x
                u_y_in = u_y
                u_z_in = u_z
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BTot.!N (cm!U-3!N km!U-1!N s)' 
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True, xrange=tr)
                (chiline, psiline, chiSquaredReduced_chi, chiSquaredReduced_psi,
                    rSquared_chi, rSquared_psi, slopeError_chi, slopeError_psi,
                    epsilon_chi, epsilon_psi, anisotropy_chi, anisotropy_psi, 
                    epsilonEpoch, anisotropy_chi_deltaPlus,
                    anisotropy_chi_deltaMinus, anisotropy_psi_deltaPlus,
                    anisotropy_psi_deltaMinus) = findVDFAnisotropy(v_z, vz_tanPhi, vz_tanTheta, 
                                                 u_x_in, u_y_in, u_z_in, vdf_in, Nx_temp, 
                                                 Ny_temp, Nz_temp)
                plot(5,bundle(anisotropy_chi,anisotropy_psi),ylog=True,ytitle='%s!Canisotropy'%(vdf))
                
            elif vdf == 'vdf_p1':
                vdf_in = vdf_p1
                vp1_fit_SC = synchronize(vdf_p1,vp1_fit_SC)
                u_x_in = vp1_fit_SC[:,0]
                u_y_in = vp1_fit_SC[:,1]
                u_z_in = vp1_fit_SC[:,2]
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BCore!N (cm!U-3!N km!U-1!N s)'
                minFluxValueForFit = 0
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
                (chiline_p1, psiline_p1, chiSquaredReduced_chi_p1, chiSquaredReduced_psi_p1,
                    rSquared_chi_p1, rSquared_psi_p1, slopeError_chi_p1, slopeError_psi_p1,
                    epsilon_chi_p1, epsilon_psi_p1, anisotropy_chi_p1, anisotropy_psi_p1, 
                    epsilonEpoch_p1, anisotropy_chi_deltaPlus_p1, anisotropy_chi_deltaMinus_p1,
                    anisotropy_psi_deltaPlus_p1,anisotropy_psi_deltaMinus_p1) = findVDFAnisotropy(v_z, vz_tanPhi,
                                                 vz_tanTheta, u_x_in, u_y_in, u_z_in, vdf_in, 
                                                 Nx_temp, Ny_temp, Nz_temp)
            elif vdf == 'vdf_3':
                vdf_in = vdf_3
                v3_fit_SC = synchronize(vdf_3,v3_fit_SC)
                u_x_in = v3_fit_SC[:,0]
                u_y_in = v3_fit_SC[:,1]
                u_z_in = v3_fit_SC[:,2]
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BBeam!N (cm!U-3!N km!U-1!N s)'
                minFluxValueForFit = 0
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
                (chiline_3, psiline_3, chiSquaredReduced_chi_3, chiSquaredReduced_psi_3,
                    rSquared_chi_3, rSquared_psi_3, slopeError_chi_3, slopeError_psi_3,
                    epsilon_chi_3, epsilon_psi_3, anisotropy_chi_3, anisotropy_psi_3, 
                    epsilonEpoch_3, anisotropy_chi_deltaPlus_3, anisotropy_chi_deltaMinus_3,
                    anisotropy_psi_deltaPlus_3,anisotropy_psi_deltaMinus_3) = findVDFAnisotropy(v_z, vz_tanPhi,
                                                 vz_tanTheta, u_x_in, u_y_in, u_z_in, vdf_in, 
                                                 Nx_temp, Ny_temp, Nz_temp)
            elif vdf == 'vdf_a':
                vdf_in = vdf_a
                va_fit_SC = synchronize(vdf_a,va_fit_SC)
                u_x_in = va_fit_SC[:,0]
                u_y_in = va_fit_SC[:,1]
                u_z_in = va_fit_SC[:,2]
                (Nx_temp,Ny_temp,Nz_temp) = synchronize(vdf_in,[Nx,Ny,Nz])
                vdf_label = 'VDF!BAlpha!N (cm!U-3!N km!U-1!N s)'
                minFluxValueForFit = 0
                
                plot(0,vdf_in,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
                (chiline_a, psiline_a, chiSquaredReduced_chi_a, chiSquaredReduced_psi_a,
                    rSquared_chi_a, rSquared_psi_a, slopeError_chi_a, slopeError_psi_a,
                    epsilon_chi_a, epsilon_psi_a, anisotropy_chi_a, anisotropy_psi_a, 
                    epsilonEpoch_a, anisotropy_chi_deltaPlus_a, anisotropy_chi_deltaMinus_a,
                    anisotropy_psi_deltaPlus_a,anisotropy_psi_deltaMinus_a) = findVDFAnisotropy(v_z, vz_tanPhi,
                                                 vz_tanTheta, u_x_in, u_y_in, u_z_in, vdf_in, 
                                                 Nx_temp, Ny_temp, Nz_temp)
              
                plot(6,bundle(anisotropy_chi_a,anisotropy_psi_a),ylog=True)
        
        
        #Bunit = bundle(Nx,Ny,Nz)
        
        # ###
        # ### WRITE STUFF
        # ###
        
        if writeStuff == True:
            if analyzingTimeWidthComparisons == True:
                output_file = output_folder+'SPC_Anisotropy_%s_v%s_%ssec.cdf'%(timeTitle,version,str(fitSeconds))
            elif analyzingTimeWidthComparisons == False:
                output_file = output_folder+'SPC_Anisotropy_%s_v%s.cdf'%(timeTitle,version)
            
            
            for vdf in vdfList:
                time_write_begin = TimeUtil.now()
                print 'writing %s file'%(vdf)
                if vdf == 'vdf_full':
                    tempB = synchronize(chiline,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal, chiline, psiline, 
                         chiSquaredReduced_chi, chiSquaredReduced_psi,
                         rSquared_chi, rSquared_psi, slopeError_chi, slopeError_psi,
                         epsilon_chi, epsilon_psi, anisotropy_chi, anisotropy_psi, 
                         epsilonEpoch, anisotropy_chi_deltaPlus,
                         anisotropy_chi_deltaMinus, anisotropy_psi_deltaPlus,
                         anisotropy_psi_deltaMinus)
                         
                elif vdf == 'vdf_p1':
                    tempB = synchronize(chiline_p1,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch_p1)
                    output_file = output_folder+'SPC_Anisotropy_p1_%s_v%s.cdf'%(timeTitle,version)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal, chiline_p1, psiline_p1, 
                        chiSquaredReduced_chi_p1, chiSquaredReduced_psi_p1,
                        rSquared_chi_p1, rSquared_psi_p1, slopeError_chi_p1, slopeError_psi_p1,
                        epsilon_chi_p1, epsilon_psi_p1, anisotropy_chi_p1, anisotropy_psi_p1, 
                        epsilonEpoch_p1, anisotropy_chi_deltaPlus_p1, anisotropy_chi_deltaMinus_p1,
                        anisotropy_psi_deltaPlus_p1,anisotropy_psi_deltaMinus_p1)
                        
                elif vdf == 'vdf_3':
                    tempB = synchronize(chiline_3,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch_3)
                    output_file = output_folder+'SPC_Anisotropy_3_%s_v%s.cdf'%(timeTitle,version)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal, chiline_3, psiline_3, 
                        chiSquaredReduced_chi_3, chiSquaredReduced_psi_3,
                        rSquared_chi_3, rSquared_psi_3, slopeError_chi_3, slopeError_psi_3,
                        epsilon_chi_3, epsilon_psi_3, anisotropy_chi_3, anisotropy_psi_3, 
                        epsilonEpoch_3, anisotropy_chi_deltaPlus_3, anisotropy_chi_deltaMinus_3,
                        anisotropy_psi_deltaPlus_3,anisotropy_psi_deltaMinus_3)
                                                     
                elif vdf == 'vdf_a':
                    tempB = synchronize(chiline_a,[Nx,Ny,Nz])
                    Bunit = bundle(tempB[0],tempB[1],tempB[2])
                    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch_a)
                    output_file = output_folder+'SPC_Anisotropy_a_%s_v%s.cdf'%(timeTitle,version)
                    writeAnisotropyL0(time_write_begin, output_file, Bunit, Btotal, chiline_a, psiline_a, 
                        chiSquaredReduced_chi_a, chiSquaredReduced_psi_a,
                        rSquared_chi_a, rSquared_psi_a, slopeError_chi_a, slopeError_psi_a,
                        epsilon_chi_a, epsilon_psi_a, anisotropy_chi_a, anisotropy_psi_a, 
                        epsilonEpoch_a, anisotropy_chi_deltaPlus_a, anisotropy_chi_deltaMinus_a,
                        anisotropy_psi_deltaPlus_a,anisotropy_psi_deltaMinus_a)
            
    except:
        import traceback
        traceback.print_exc()
        continue
