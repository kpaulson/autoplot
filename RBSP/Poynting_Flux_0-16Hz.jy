
####################################################
###                                              ###
###  Transform GSE files to mGSE and calculate   ###    
###           Poynting Flux Parameters           ###
###                                              ###
####################################################

import java
from org.das2.math.filter import Butterworth
from org.virbo.dsops.Ops import FFTFilterType
from org.das2.datum.Units import *
from org.virbo.dsutil import LinFit
from org.das2.graph.DasColorBar.Type import *
from org.virbo.autoplot.RenderType import *


# ###
# ### USER INPUT PARAMETERS
# ###

SC = getParam( 'S/C', 'A', 'the spacecraft name', ['A','B'] )

starttime_input = getParam( 'Start Date and Time' , '2013-03-20 8:30' , 'Any format you want, really' )
endtime_input = getParam( 'End Date and Time' , '2013-03-20 8:55' , 'End of wave activity' )

freq_min = getParam( 'Minimum Frequency' , 1.9 , 'The minimum frequency kept after the fft of the data is taken' )
freq_max = getParam( 'Maximum Frequency' , 2.6 , 'The maximum frequency kept after the fft of the data is taken' )

window = getParam('FFT WIndow Size' , 2048 , 'The number of points in the fft window' , [128,512,1024,2048,4096,8192,16384] )
slide = getParam('Slide' , 8 , 'The reciprocal of the fraction of the window that is not overlapped by the previous fft' , [1,2,4,8,16,32] )

logyn = getParam( 'Logarithmic yes/no', 'F' , 'Whether or not to display the frequency axis in logarithmic scale' , ['T' , 'F'] )

ratios_or_angles = getParam('Ratios or Angles' , 'Angles' , 'Do you want to display Poynting Flux as a ratio in a given direction or by angles?' , ['Ratios','Angles','Components'] )

write_file_yn = getParam( 'Write Output File?' , 'T' , 'Do you want to write the polarization data out to a file?' , ['T' , 'F'] )
if( write_file_yn == 'T' ):
    output_file = getParam( 'Output File' , 'C:/Users/krist/Desktop/'+'TEMP_RBSP-%s_SCM-Poynting.cdf'%SC , 'Output file to be written' )

# ###
# ### INPUT DEFINITIONS
# ###

sample = 64

wave_power_max = getParam('Maximum Flux' , 1E1 , 'Upper end of color bar scale in the Poynting magnitude plot')
wave_power_min = getParam('Minimum Flux' , 0.005 , 'Lower end of scale, throws out lower values in other plots (set to 0 to disable)')
poynting_min = wave_power_min

sample = 64 # number of samples per second in data (64 for hires rbsp)

random_power = 0# probably stupid, adds random noise to the data set to make polarizations standout and cut down on bleeding - set to 0 to disable

spacecraft = SC.lower()
SPACECRAFT = SC.upper()

tp= TimeParser.create('$Y-$m-$dT$H:$M:$S.$(milli)$(micro)')
tp_title= TimeParser.create('$Y-$m-$dT$H:$M')
starttime =  timegen(starttime_input,'1 ns',1)[0]
endtime =  timegen(endtime_input,'1 ns',1)[0]
file_start = starttime_input
file_end = endtime_input

low_freq = freq_min
high_freq = freq_max

wave = 0
poynting_flux_relative_to_equator = 'F'
use_backup_poynting_method = 'F'
    
# ###
# ### FILENAMES AND LOCATIONS
# ###

efield_root = 'http://rbsp.space.umn.edu/data/rbsp/rbsp'+spacecraft+'/l2/esvy_despun/$Y/'
efield_file = efield_root+'rbsp'+spacecraft+'_efw-l2_esvy_despun_$Y$m$d_v$v.cdf?timerange='+str(file_start)+'through'+str(file_end)

mag_root = 'http://emfisis.physics.uiowa.edu/Flight/RBSP-'+SPACECRAFT+'/L3/$Y/$m/$d/'
mag_file = mag_root+'rbsp-'+spacecraft+'_magnetometer_hires-gse_emfisis-L3_$Y$m$d_v$(v,sep).cdf?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)

spinning_mag_root = 'http://emfisis.physics.uiowa.edu/Flight/RBSP-'+SPACECRAFT+'/L2/$Y/$m/$d/'
spinning_mag_file = spinning_mag_root+'rbsp-'+spacecraft+'_magnetometer_uvw_emfisis-L2_$Y$m$d_v$(v,sep).cdf?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)

bckg_root = 'http://emfisis.physics.uiowa.edu/Flight/RBSP-'+SPACECRAFT+'/L3/$Y/$m/$d/'
bckg_file = bckg_root+'rbsp-'+spacecraft+'_magnetometer_4sec-gse_emfisis-L3_$Y$m$d_v$(v,sep).cdf?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)

#ephem_root =  'http://www.rbsp-ect.lanl.gov/data_pub/rbsp'+spacecraft+'/MagEphem/$Y/'
ephem_root =  'http://emfisis.physics.uiowa.edu/Flight/RBSP-'+SPACECRAFT+'/LANL/MagEphem/$Y/'
ephem_file = ephem_root+'rbsp'+spacecraft+'_def_MagEphem_TS04D_$Y$m$d_v$(v,sep).txt?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)
ephem_file_T89D = ephem_root+'rbsp'+spacecraft+'_def_MagEphem_T89D_$Y$m$d_v$(v,sep).txt?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)
ephem_file_T89Q = ephem_root+'rbsp'+spacecraft+'_def_MagEphem_T89Q_$Y$m$d_v$(v,sep).txt?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)
ephem_file_OP77Q = ephem_root+'rbsp'+spacecraft+'_def_MagEphem_OP77Q_$Y$m$d_v$(v,sep).txt?depend0=IsoDateTime&timerange='+str(file_start)+'through'+str(file_end)
ephem_file_backup = 'file:/D:/Research/EMIC/EMIC%20Catalog/RBSP_'+spacecraft+'_ephemeris-OLD.txt?skipLines=1&depend0=field0'

spin_axis_file = 'vap+cdaweb:ds=RBSP'+SPACECRAFT+'_EFW-L2_E-HIRES-UVW&id=L_vector&filter=uvw&timerange='+str(file_start)+'through'+str(file_end)



#############################################################################################

def putProps( dss, name='DEPEND_0', value=None ):
    for ds in dss:
        ds.putProperty( name, value )
        
        
#############################################################################################   

def RBSP_FAC( bckg_file , ephem_file , Btime , lead_time , excess_time):    
       
    # ###
    # ### FEED IN LOW-CADENCE MAG DATA
    # ###
    
    
    Bx_GSE_bckg = getDataSet(bckg_file+'&Mag&slice1=0')
    By_GSE_bckg = getDataSet(bckg_file+'&Mag&slice1=1')
    Bz_GSE_bckg = getDataSet(bckg_file+'&Mag&slice1=2')
    Bmag_GSE_bckg = getDataSet(bckg_file+'&Magnitude')
    
    Btimelow = Bmag_GSE_bckg.property(QDataSet.DEPEND_0)
    
    if ( len(Btimelow) != len(uniq(Btimelow)) ):
        low_mag_uniqueness = uniq(Btimelow)
        Bx_GSE_bckg = Bx_GSE_bckg[low_mag_uniqueness]
        By_GSE_bckg = By_GSE_bckg[low_mag_uniqueness]
        Bz_GSE_bckg = Bz_GSE_bckg[low_mag_uniqueness]
        Bmag_GSE_bckg = Bmag_GSE_bckg[low_mag_uniqueness]
        
    
    # ###
    # ### TAKE AVERAGES
    # ###
    
    monitor.setProgressMessage('Smoothing 4-second MAG Data')
    
    seconds = 12 #number of seconds over which field is averaged to create background field (use multiples of 4)
    points = seconds / 4
    
    TEMP_Bx_GSE_bckg_smooth = smooth ( Bx_GSE_bckg , points )
    TEMP_By_GSE_bckg_smooth = smooth ( By_GSE_bckg , points )
    TEMP_Bz_GSE_bckg_smooth = smooth ( Bz_GSE_bckg , points )
    TEMP_Bmag_smooth = smooth ( Bmag_GSE_bckg , points )
    
    del ( [ Bx_GSE_bckg , By_GSE_bckg , Bz_GSE_bckg , Bmag_GSE_bckg ] )
      
    r = where( Btimelow.ge( lead_time ).and( Btimelow.le( excess_time ) ) ) #Defines subset of data based on timestamps
    
    Bx_GSE_bckg_smooth = TEMP_Bx_GSE_bckg_smooth[r]
    By_GSE_bckg_smooth = TEMP_By_GSE_bckg_smooth[r]
    Bz_GSE_bckg_smooth = TEMP_Bz_GSE_bckg_smooth[r]
    Bmag_smooth = TEMP_Bmag_smooth[r]
    Btimelow = Bmag_smooth.property(QDataSet.DEPEND_0)
    
    del ( [ TEMP_Bx_GSE_bckg_smooth , TEMP_By_GSE_bckg_smooth , TEMP_Bz_GSE_bckg_smooth , TEMP_Bmag_smooth ] )
        
        
    # ###
    # ### DEFINE FIELD-ALIGNED VECTOR
    # ###
    
    monitor.setProgressMessage('Defining the Field-aligned vector')
    
    Nx_low = Bx_GSE_bckg_smooth / Bmag_smooth
    Ny_low = By_GSE_bckg_smooth / Bmag_smooth
    Nz_low = Bz_GSE_bckg_smooth / Bmag_smooth
      
    
    # ###
    # ### DOWNLOAD EPHEMERIS AND CALCULATE FIELD-ALIGNED COORDINATE VECTORS
    # ###
    
    monitor.setProgressMessage('Downloading Ephemeris Data')
    
    try:
        TEMP_Rx_GSE = getDataSet(local_ephem_file+'&column=Rgse_x') # should be pointing radially outward?
        TEMP_Ry_GSE = getDataSet(local_ephem_file+'&column=Rgse_y')
        TEMP_Rz_GSE = getDataSet(local_ephem_file+'&column=Rgse_z')
        #raise java.io.FileNotFoundException()
    except:
        try:
            TEMP_Rx_GSE = getDataSet(ephem_file+'&column=Rgse_x') # should be pointing radially outward?
            TEMP_Ry_GSE = getDataSet(ephem_file+'&column=Rgse_y')
            TEMP_Rz_GSE = getDataSet(ephem_file+'&column=Rgse_z')
        except:
            try:
                TEMP_Rx_GSE = getDataSet(ephem_file_T89D+'&column=Rgse_x') # should be pointing radially outward?
                TEMP_Ry_GSE = getDataSet(ephem_file_T89D+'&column=Rgse_y')
                TEMP_Rz_GSE = getDataSet(ephem_file_T89D+'&column=Rgse_z')
            except:
                try:
                    TEMP_Rx_GSE = getDataSet(ephem_file_T89Q+'&column=Rgse_x') # should be pointing radially outward?
                    TEMP_Ry_GSE = getDataSet(ephem_file_T89Q+'&column=Rgse_y')
                    TEMP_Rz_GSE = getDataSet(ephem_file_T89Q+'&column=Rgse_z')
                except:
                    try:
                        TEMP_Rx_GSE = getDataSet(ephem_file_OP77Q+'&column=Rgse_x') # should be pointing radially outward?
                        TEMP_Ry_GSE = getDataSet(ephem_file_OP77Q+'&column=Rgse_y')
                        TEMP_Rz_GSE = getDataSet(ephem_file_OP77Q+'&column=Rgse_z')
                    except:
                        pass
    
    if( 'TEMP_Rx_GSE' in locals() ):
        ephem_time = TEMP_Rx_GSE.property(QDataSet.DEPEND_0)
    else:
        print 'No MagEphem data found'
        raise java.io.FileNotFoundException()
    Rmag = sqrt( TEMP_Rx_GSE**2 + TEMP_Ry_GSE**2 + TEMP_Rz_GSE**2 )
    
    monitor.setProgressMessage('Interpolating Ephemeris up to full cadence')
    
    try:
        ephem_to_b_time_ratio = findex( ephem_time , Btime ) # Interpolate onto mag cadence
        
    except(java.lang.IllegalArgumentException):
        uniqueness = uniq( ephem_time )
        
        ephem_time = ephem_time[uniqueness]
        TEMP_Rx_GSE = TEMP_Rx_GSE[uniqueness]
        TEMP_Ry_GSE = TEMP_Ry_GSE[uniqueness]
        TEMP_Rz_GSE = TEMP_Rz_GSE[uniqueness]
        Rmag = Rmag[uniqueness]
        
        ephem_to_b_time_ratio = findex( ephem_time , Btime ) # Interpolate onto mag cadence
    
        
    Rx_GSE =  interpolate ( ( TEMP_Rx_GSE / Rmag ) , ephem_to_b_time_ratio ) #No need to take subset, since this interpolation will throw out excess data. BUT it may save a little time if we do it 10 lines up
    Ry_GSE =  interpolate ( ( TEMP_Ry_GSE / Rmag ) , ephem_to_b_time_ratio )
    Rz_GSE =  interpolate ( ( TEMP_Rz_GSE / Rmag ) , ephem_to_b_time_ratio )
    
    del ( [ TEMP_Rx_GSE , TEMP_Ry_GSE , TEMP_Rz_GSE , Rmag ] )
    
    monitor.setProgressMessage('Creating Radial and Azimuthal vectors')
    
    low_to_raw_ratio = findex( Btimelow , Btime )
    Nx = interpolate( Nx_low , low_to_raw_ratio ) #Interpolating field-aligned vector to mag cadence
    Ny = interpolate( Ny_low , low_to_raw_ratio )
    Nz = interpolate( Nz_low , low_to_raw_ratio )
    
    TEMP_Px = -( Ny * Rz_GSE ) + ( Nz * Ry_GSE ) #Negative to preserve right-handedness
    TEMP_Py = -( Nz * Rx_GSE ) + ( Nx * Rz_GSE )
    TEMP_Pz = -( Nx * Ry_GSE ) + ( Ny * Rx_GSE )
          
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity
    
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Eastward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
    
    Qx = -( Py * Nz ) + ( Pz * Ny ) # ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    return ( Nx , Ny , Nz , Rx_GSE , Ry_GSE , Rz_GSE )#Px , Py , Pz , Qx , Qy , Qz , Btimelow )


#############################################################################################

def trim_it_merge_it(ds,ds_time,processed_ds,window,leading_points):
    
    
    ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    
    trimmed_ds = trim(ds,int(leading_points),int(len(ds)))
    trimmed_ds.putProperty( QDataSet.DEPEND_0 , trim(ds_time,int(leading_points),int(len(ds))) )
    
    processed_ds_too = hanning( trimmed_ds , window )
    processed_ds_too.putProperty( QDataSet.DEPEND_1 , ds.property(QDataSet.DEPEND_1) )
    
    processed_ds_time = processed_ds.property( QDataSet.DEPEND_0 )
    processed_ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    processed_ds.putProperty( QDataSet.DEPEND_0 , processed_ds_time )
    
    result = merge( processed_ds , processed_ds_too )
    
    return( result )


# ############################################################################################

def Hanningfft( ds , freq_min , freq_max , window , slide ):
    """FFT routine employing sliding Hanning window function while preserving both real and imaginary components. 
    
    Parameters:
        ds = The rank1 time-series input data.
        freq_min = Lower end of frequency range to be preserved (excess thrown out to speed up subsequent processing).
        freq_max = Upper end of frequency range.
        window = Length of window to be taken measured in number of data points.
        slide = Window overlap size, expressed as a fraction of the length (1 for no slide, 2 for half steps, 4 for quarters)
        
    Returns:
        waveform_fft = The rank3 fft result of both real and imaginary components trimmed to frequency range."""
    
    ds_time = ds.property(QDataSet.DEPEND_0)
    
    ds_cadence = convertUnitsTo((ds_time[1]-ds_time[0]),Units.seconds)
    per_sec = int(1./ds_cadence)
    T = float( window * 1. / per_sec )
    
    processed_ds = hanning(ds,window)

    for i in xrange( slide ):
        try:
            processed_ds = trim_it_merge_it(ds,ds_time,processed_ds,window,window*(i+1)/slide)
        except( java.lang.ArrayIndexOutOfBoundsException ):
            pass

    TEMP_waveform_fft = dblarr( len(processed_ds[:,0]) , len(processed_ds[0,:]) , 2 )

    for i in xrange( len(processed_ds[:,0]) ):
        processed_ds_fft = fft( processed_ds[i,:] )
        TEMP_waveform_fft[i,:,:] = processed_ds_fft

    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_0 , processed_ds.property(QDataSet.DEPEND_0) )
    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_1 , processed_ds_fft[:,0].property(QDataSet.DEPEND_0)*per_sec )
    TEMP_waveform_fft.property(QDataSet.DEPEND_1).putProperty( QDataSet.UNITS , Units.hertz )

    frequency_range = where( TEMP_waveform_fft.property(QDataSet.DEPEND_1).ge(freq_min).and(TEMP_waveform_fft.property(QDataSet.DEPEND_1).le(freq_max)) )
    waveform_fft = TEMP_waveform_fft[:,frequency_range,:]*sqrt(T)*1.155
    waveform_fft.putProperty( QDataSet.DEPEND_1 , TEMP_waveform_fft.property(QDataSet.DEPEND_1)[frequency_range] )
    del ( TEMP_waveform_fft )
    
    uniqueness = uniq( waveform_fft.property(QDataSet.DEPEND_0) )
    waveform_fft_time = waveform_fft.property(QDataSet.DEPEND_0)[uniqueness]
    waveform_fft = waveform_fft[uniqueness,:,:]
    waveform_fft.putProperty( QDataSet.DEPEND_0 , waveform_fft_time )
    
    return ( waveform_fft )
        

# ############################################################################################ 

def Butterworth_Bandpassify( Component , polynomial_order , low_frequency , high_frequency , pass_or_reject ):
    Component_bandpass_coefficients = Butterworth( Component , polynomial_order , low_frequency , high_frequency , pass_or_reject )
    Component_bandpass = Component_bandpass_coefficients.filter()
    
    return ( Component_bandpass )
      
      
#############################################################################################   
        
def Poyntingify( Bn_fft , Bp_fft , Bq_fft , En_fft , Ep_fft , Eq_fft , poynting_min ):
    """3D Poynting analysis performed on spectral components.
    
    Parameters:
        Bn_fft = rank3 fft of field-aligned magnetic component.
        Bp_fft = rank3 fft of first perpendicular magnetic component.
        Bq_fft = rank3 fft of second perpendicular magnetic component.
        En_fft = rank3 fft of field-aligned electric component.
        Ep_fft = rank3 fft of first perpendicular electric component.
        Eq_fft = rank3 fft of second perpendicular electric component.
        poynting_min = minimum value of Poynting flux to be kept in mW/m/Hz (all lower values discarded).
    
    Returns:
        Smag , Poynting_theta, Poynting_phi, Sn, Sp, Sq, TEMP_Sn, TEMP_Sp, TEMP_Sq"""
    
    ###
    ### RUN POYNTING FLUX ANALYSIS
    ###
    
    monitor.setProgressMessage('Calculating Poynting Flux')
    try:
          TEMP_MLat = getDataSet( ephem_file+'&column=EDMAG_MLAT' )
    except:
        try:
            TEMP_MLat = getDataSet(ephem_file_T89D+'&column=EDMAG_MLAT') 
        except:
            try:
                TEMP_MLat = getDataSet(ephem_file_T89Q+'&column=EDMAG_MLAT') 
            except:
                TEMP_MLat = getDataSet(ephem_file_OP77Q+'&column=EDMAG_MLAT')
                    
    ephem_time = TEMP_MLat.property(QDataSet.DEPEND_0)
    
    if ( len(ephem_time) != len(uniq(ephem_time)) ):
        uniqueness = uniq(ephem_time)
        ephem_time = ephem_time[uniqueness] 
        TEMP_MLat = TEMP_MLat[uniqueness] 
    
    fft_time = Bn_fft.property( QDataSet.DEPEND_0 )       
    frequency_axis = Bn_fft.property( QDataSet.DEPEND_1 )  
        
    ephem_to_fft_time_ratio = findex( ephem_time , fft_time )
    MLat_fftcadence = interpolate ( TEMP_MLat , ephem_to_fft_time_ratio )
    del ( TEMP_MLat )

    TEMP_Sn = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )
    TEMP_Sp = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )
    TEMP_Sq = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )

    TEMP_Sp = ( ( (En_fft[:,:,0]*Bq_fft[:,:,0]) + (En_fft[:,:,1]*Bq_fft[:,:,1]) ) - ( (Eq_fft[:,:,0]*Bn_fft[:,:,0]) + (Eq_fft[:,:,1]*Bn_fft[:,:,1]) ) ) / 2
    TEMP_Sq = ( ( (Ep_fft[:,:,0]*Bn_fft[:,:,0]) + (Ep_fft[:,:,1]*Bn_fft[:,:,1]) ) - ( (En_fft[:,:,0]*Bp_fft[:,:,0]) + (En_fft[:,:,1]*Bp_fft[:,:,1]) ) ) / 2
    
    if( poynting_flux_relative_to_equator == 'T' ):
        for i in xrange( len(Bn_fft[:,1,0]) ):
            if ( MLat_fftcadence[i] < 0 ):
                TEMP_Sn[i,:] = -( ( (Ep_fft[i,:,0]*Bq_fft[i,:,0]) + (Ep_fft[i,:,1]*Bq_fft[i,:,1]) ) - ( (Eq_fft[i,:,0]*Bp_fft[i,:,0]) + (Eq_fft[i,:,1]*Bp_fft[i,:,1]) ) ) / 2
            else:
                TEMP_Sn[i,:] = ( ( (Ep_fft[i,:,0]*Bq_fft[i,:,0]) + (Ep_fft[i,:,1]*Bq_fft[i,:,1]) ) - ( (Eq_fft[i,:,0]*Bp_fft[i,:,0]) + (Eq_fft[i,:,1]*Bp_fft[i,:,1]) ) ) / 2
    else:
        TEMP_Sn = ( ( (Ep_fft[:,:,0]*Bq_fft[:,:,0]) + (Ep_fft[:,:,1]*Bq_fft[:,:,1]) ) - ( (Eq_fft[:,:,0]*Bp_fft[:,:,0]) + (Eq_fft[:,:,1]*Bp_fft[:,:,1]) ) ) / 2

    
    #etrace = ( (Ep_fft[:,:,0]*Ep_fft[:,:,0]) + (Ep_fft[:,:,1]*Ep_fft[:,:,1]) ) + ( (Eq_fft[:,:,0]*Eq_fft[:,:,0]) + (Eq_fft[:,:,1]*Eq_fft[:,:,1]) ) + ( (En_fft[:,:,0]*En_fft[:,:,0]) + (En_fft[:,:,1]*En_fft[:,:,1]) )

    del ( [ En_fft , Ep_fft , Eq_fft ] )

    Smag = sqrt(TEMP_Sn**2 + TEMP_Sp**2 + TEMP_Sq**2)

    putProps( [ Smag ], QDataSet.DEPEND_0, fft_time )
    putProps( [ Smag ], QDataSet.DEPEND_1, frequency_axis )
    
    putProps( [ TEMP_Sn ], QDataSet.DEPEND_0, fft_time )
    putProps( [ TEMP_Sn ], QDataSet.DEPEND_1, frequency_axis )
    putProps( [ TEMP_Sp ], QDataSet.DEPEND_0, fft_time )
    putProps( [ TEMP_Sp ], QDataSet.DEPEND_1, frequency_axis )
    putProps( [ TEMP_Sq ], QDataSet.DEPEND_0, fft_time )
    putProps( [ TEMP_Sq ], QDataSet.DEPEND_1, frequency_axis )
    
    Smag.putProperty( QDataSet.UNITS , wpm2 )

    Sn = TEMP_Sn / Smag
    Sp = TEMP_Sp / Smag
    Sq = TEMP_Sq / Smag

    Poynting_theta = acos( Sn ) * ( 180 / PI )
    Poynting_phi = atan2( Sp , Sq ) * ( 180 / PI )

    if (wave_power_min > 0 ): # this executes a step function zero-ing out poynting flux where there are no waves, since I am plotting it as a factor of total flux
          for j in xrange( len(Sn[1,:]) ):
                for i in xrange( len(Sn[:,1]) ):
                      if ( Smag[i,j] < poynting_min ):
                            Poynting_theta[i,j] = -1
                            Poynting_phi[i,j] = -181
                            Sn[i,j] = -1E38
                            Sp[i,j] = -1E38
                            Sq[i,j] = -1E38
                            TEMP_Sn[i,j] = -1E38
                            TEMP_Sp[i,j] = -1E38
                            TEMP_Sq[i,j] = -1E38

    #del ( [ Sn , Sp , Sq , TEMP_Sn , TEMP_Sp , TEMP_Sq ] )
    
    Poynting_theta.putProperty ( QDataSet.DEPEND_0 , fft_time )
    Poynting_theta.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    Poynting_theta.putProperty ( QDataSet.VALID_MIN , 0 )
   
    Poynting_phi.putProperty ( QDataSet.DEPEND_0 , fft_time )
    Poynting_phi.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    Poynting_phi.putProperty ( QDataSet.VALID_MIN , -180 ) 
    
    ###
    ### SPIT OUT RESULTS
    ###
    
    return ( Smag , Poynting_theta, Poynting_phi, Sn, Sp, Sq, TEMP_Sn, TEMP_Sp, TEMP_Sq ) 
      
      
#############################################################################################   
        
def PoyntingifyBackup( E_p1_fft, B_p1_fft, B_p2_fft, poynting_min ):
    """Poynting analysis to be employed when errors in E-field data render E.B=0 assumption/method invalid.
    This only looks at half of the field-aligned poynting flux, from which direction can be assumed.
    
    Parameters:
        E_p1_fft = rank3 fft of electric field data in the p1 perpendicular direction (spin plane)
        B_p2_fft = rank3 fft of magnetic field data in the p2 perpendicular direction (spin axis)
    
    Returns:
        TEMP_Sn = rank2 spectral representation of one half of the poynting flux calculation along B"""
    
    ###
    ### RUN POYNTING FLUX ANALYSIS
    ###
    
    monitor.setProgressMessage('Calculating Poynting Flux')
    try:
          TEMP_MLat = getDataSet( ephem_file+'&column=EDMAG_MLAT' )
    except:
        try:
            TEMP_MLat = getDataSet(ephem_file_T89D+'&column=EDMAG_MLAT') 
        except:
            try:
                TEMP_MLat = getDataSet(ephem_file_T89Q+'&column=EDMAG_MLAT') 
            except:
                TEMP_MLat = getDataSet(ephem_file_OP77Q+'&column=EDMAG_MLAT')
                    
    ephem_time = TEMP_MLat.property(QDataSet.DEPEND_0)
    
    if ( len(TEMP_MLat) != len(ephem_time) ):
        TEMP_MLat = TEMP_MLat[uniqueness] 

    if ( len(ephem_time) != len(uniq(ephem_time)) ):
        uniqueness = uniq(ephem_time)
        TEMP_MLat = TEMP_MLat[uniqueness] 
        ephem_time = ephem_time[uniqueness]
    
    fft_time = E_p1_fft.property( QDataSet.DEPEND_0 )       
    frequency_axis = E_p1_fft.property( QDataSet.DEPEND_1 )  
        
    ephem_to_fft_time_ratio = findex( ephem_time , fft_time )
    MLat_fftcadence = interpolate ( TEMP_MLat , ephem_to_fft_time_ratio )
    del ( TEMP_MLat )

    TEMP_Sn = dblarr( len(E_p1_fft[:,1,0]) , len(E_p1_fft[1,:,0]) )
    Sn = dblarr( len(E_p1_fft[:,1,0]) , len(E_p1_fft[1,:,0]) )
    #TEMP_Sp = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )
    #TEMP_Sq = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )

    if( poynting_flux_relative_to_equator == 'T' ):
        for i in xrange( len(E_p1_fft[:,1,0]) ):
            if ( MLat_fftcadence[i] < 0 ):
                Sn[i,:] = -(1./2.) * ( (E_p1_fft[i,:,0]*B_p2_fft[i,:,0]) + (E_p1_fft[i,:,1]*B_p2_fft[i,:,1]) ) * ( ((B_p1_fft[i,:,0]**2 + B_p1_fft[i,:,1]**2) / (B_p2_fft[i,:,0]**2 + B_p2_fft[i,:,1]**2)) - 1 )
            else:
                Sn[i,:] =  (1./2.) * ( (E_p1_fft[i,:,0]*B_p2_fft[i,:,0]) + (E_p1_fft[i,:,1]*B_p2_fft[i,:,1]) ) * ( ((B_p1_fft[i,:,0]**2 + B_p1_fft[i,:,1]**2) / (B_p2_fft[i,:,0]**2 + B_p2_fft[i,:,1]**2)) - 1 )
    else:
        Sn = (1./2.) * ( (E_p1_fft[:,:,0]*B_p2_fft[:,:,0]) + (E_p1_fft[:,:,1]*B_p2_fft[:,:,1]) ) * ( ((B_p1_fft[:,:,0]**2 + B_p1_fft[:,:,1]**2) / (B_p2_fft[:,:,0]**2 + B_p2_fft[:,:,1]**2)) - 1 )
    
    TEMP_Sn = Sn # Not sure why I still have a TEMP_Sn component, but it will break mroe than it fixes to get rid of it for now
    
    putProps( [ TEMP_Sn ], QDataSet.DEPEND_0, fft_time )
    putProps( [ TEMP_Sn ], QDataSet.DEPEND_1, frequency_axis )
                
    #Smag.putProperty( QDataSet.UNITS , wpm2 )

    #Sn = TEMP_Sn / Smag

    #Poynting_theta = acos( Sn ) * ( 180 / PI )

#    if (wave_power_min > 0 ): # this executes a step function zero-ing out poynting flux where there are no waves, since I am plotting it as a factor of total flux
#          for j in xrange( len(Sn[1,:]) ):
#                for i in xrange( len(Sn[:,1]) ):
#                      if ( Smag[i,j] < poynting_min ):
#                            Poynting_theta[i,j] = -1
#                            Poynting_phi[i,j] = -181
#                            Sn[i,j] = -1E38
#                            Sp[i,j] = -1E38
#                            Sq[i,j] = -1E38
#                            TEMP_Sn[i,j] = -1E38
#                            TEMP_Sp[i,j] = -1E38
#                            TEMP_Sq[i,j] = -1E38
    
    #Poynting_theta.putProperty ( QDataSet.DEPEND_0 , fft_time )
    #Poynting_theta.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    #Poynting_theta.putProperty ( QDataSet.VALID_MIN , 0 )
    
    ###
    ### SPIT OUT RESULTS
    ###
    
    return ( TEMP_Sn , Sn ) 
      
      
#############################################################################################

def backupFAC(Nx, Ny, Nz, spin_x, spin_y, spin_z):
    
    TEMP_p1x_GSE = -( Ny * spin_z ) + ( Nz * spin_y )
    TEMP_p1y_GSE = -( Nz * spin_x ) + ( Nx * spin_z )
    TEMP_p1z_GSE = -( Nx * spin_y ) + ( Ny * spin_x )
          
    
    Pmag = sqrt( TEMP_p1x_GSE**2 + TEMP_p1y_GSE**2 + TEMP_p1z_GSE**2 ) #Have to normalize, since previous definition does not imply unitarity
    
    p1x_GSE = TEMP_p1x_GSE / Pmag # ~spin-plane - direction for RBSP will tend to be positive towards -GSEy
    p1y_GSE = TEMP_p1y_GSE / Pmag
    p1z_GSE = TEMP_p1z_GSE / Pmag
    
    p2x_GSE = ( p1z_GSE * Ny ) - ( p1y_GSE * Nz ) # ~spin-axis - positive is along spin axis (not good for E-field data)
    p2y_GSE = ( p1x_GSE * Nz ) - ( p1z_GSE * Nx )
    p2z_GSE = ( p1y_GSE * Nx ) - ( p1x_GSE * Ny )
     
    return (p1x_GSE,p1y_GSE,p1z_GSE,p2x_GSE,p2y_GSE,p2z_GSE)


#############################################################################################    
########################################################################################################## 

def MAIN():
        
              
    # ###  
    # ### GET DESPUN MAG DATA
    # ###
    
    diff_seconds = (((window)/2)*(1.0/64.0)) #Defines the number of seconds on either side of desired data subset to perform a full fft
    starttime.putProperty( QDataSet.UNITS , None )
    endtime.putProperty( QDataSet.UNITS , None )
        
    lead_time =  tp.format( Units.us2000.createDatum(QDataSet.value( starttime - diff_seconds*1E6 )) , None )
    excess_time =  tp.format( Units.us2000.createDatum(QDataSet.value( endtime + diff_seconds*1E6 )) , None )
     
    monitor.setProgressMessage('Downloading Hi-res MAG Data')
    
    TEMP_Bx_GSE_raw = getDataSet(mag_file+'&Mag&slice1=0') #Pull raw Bx data
    TEMP_By_GSE_raw = getDataSet(mag_file+'&Mag&slice1=1')
    TEMP_Bz_GSE_raw = getDataSet(mag_file+'&Mag&slice1=2')
    Btime_total = TEMP_Bx_GSE_raw.property(QDataSet.DEPEND_0)
    
              
    # ###  
    # ### GET DESPUN E-FIELD DATA
    # ###
    
    
    monitor.setProgressMessage('Downloading Hi-res EFW Data')
    
    try:
        TEMP_Ey_mGSE_raw = getDataSet(efield_file+'&efield_mgse&slice1=1') #Pull Ey mGSE Data
        TEMP_Ez_mGSE_raw = getDataSet(efield_file+'&efield_mgse&slice1=2') #Pull Ez mGSE Data
    except:
        TEMP_Ey_mGSE_raw = getDataSet(efield_file+'&esvy_vxb_mgse&slice1=1') #Pull Ey mGSE Data (Old File Format)
        TEMP_Ez_mGSE_raw = getDataSet(efield_file+'&esvy_vxb_mgse&slice1=2') #Pull Ez mGSE Data (Old File Format)
    
    TEMP_Ex_mGSE = dblarr( len(TEMP_Ez_mGSE_raw) )
    
    Etime = TEMP_Ey_mGSE_raw.property(QDataSet.DEPEND_0)
    
    
    # ###  
    # ### PERFORM BUTTERWORTH FILTER & PULL SUBSET OF VALUES
    # ###
    
    TEMP_Bx_GSE_detrend = Butterworth_Bandpassify( TEMP_Bx_GSE_raw , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )# Detrends data for fft use
    TEMP_By_GSE_detrend = Butterworth_Bandpassify( TEMP_By_GSE_raw , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )
    TEMP_Bz_GSE_detrend = Butterworth_Bandpassify( TEMP_Bz_GSE_raw , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )
       
    r = where( Btime_total.ge( lead_time ).and( Btime_total.le( excess_time ) ) )
    Bx_GSE_detrend = TEMP_Bx_GSE_detrend[r]
    By_GSE_detrend = TEMP_By_GSE_detrend[r]
    Bz_GSE_detrend = TEMP_Bz_GSE_detrend[r]
    Btime = Btime_total[r]
    Btime.putProperty(QDataSet.NAME,'B_time')
    
    putProps( [ Bx_GSE_detrend , By_GSE_detrend , Bz_GSE_detrend ] , QDataSet.DEPEND_0 , Btime )
    
    Bx_GSE_raw = TEMP_Bx_GSE_raw[r]# Hold on to raw data for E*B=0 calculation
    By_GSE_raw = TEMP_By_GSE_raw[r]
    Bz_GSE_raw = TEMP_Bz_GSE_raw[r]
    
    putProps( [ Bx_GSE_raw , By_GSE_raw , Bz_GSE_raw ] , QDataSet.DEPEND_0 , Btime )
    
    del( [ TEMP_Bx_GSE_raw , TEMP_By_GSE_raw , TEMP_Bz_GSE_raw , TEMP_Bx_GSE_detrend , TEMP_By_GSE_detrend , TEMP_Bz_GSE_detrend ] )
    
    
    if ( len(Btime) != len(uniq(Btime)) ):# This is used to solve the problem of two 00:00 timestamps when spanning multiple days
        raw_mag_uniqueness = uniq( Btime )
        Btime = Btime[raw_mag_uniqueness]
        Bx_GSE_detrend = Bx_GSE_detrend[raw_mag_uniqueness]
        By_GSE_detrend = By_GSE_detrend[raw_mag_uniqueness]
        Bz_GSE_detrend = Bz_GSE_detrend[raw_mag_uniqueness]
        
    else:
        pass
      
    monitor.setProgressMessage('Interpolating Hi-res EFW Data')
    
    ### The Butterworth filter does not work for E-field data... not sure why not, but might be because it is not a continuous dataset (change fill values to 0?)
    #TEMP_Ey_mGSE_detrend = Butterworth_Bandpassify( TEMP_Ey_mGSE_raw , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )
    #TEMP_Ez_mGSE_detrend = Butterworth_Bandpassify( TEMP_Ez_mGSE_raw , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )
    
    e_to_b_time_ratio = findex ( Etime , Btime )
    
    Ex_mGSE = interpolate ( TEMP_Ex_mGSE , e_to_b_time_ratio )
    Ey_mGSE = interpolate ( TEMP_Ey_mGSE_raw , e_to_b_time_ratio )
    Ez_mGSE = interpolate ( TEMP_Ez_mGSE_raw , e_to_b_time_ratio )
    
    del( [ TEMP_Ex_mGSE , TEMP_Ey_mGSE_raw , TEMP_Ez_mGSE_raw ] )  
        
       
    # ###
    # ### GET SPIN AXIS VALUES AND INTERPOLATE
    # ###
    
    
    monitor.setProgressMessage('Downloading Spin Axis Values')
    
    TEMP_spin_x = getDataSet(spin_axis_file+'&slice1=0')
    TEMP_spin_y = getDataSet(spin_axis_file+'&slice1=1')
    TEMP_spin_z = getDataSet(spin_axis_file+'&slice1=2')
    spin_time = TEMP_spin_x.property(QDataSet.DEPEND_0)
    
    monitor.setProgressMessage('Interpolating Spin Axis Values')
    
    spin_to_data_ratio = findex ( spin_time , Btime )
    
    spin_x = interpolate ( TEMP_spin_x , spin_to_data_ratio )
    spin_y = interpolate ( TEMP_spin_y , spin_to_data_ratio )
    spin_z = interpolate ( TEMP_spin_z , spin_to_data_ratio ) 
    
          
    # ###
    # ### DEFINE TRANSITION FROM GSE TO mGSE
    # ###
    
    monitor.setProgressMessage('Defining Rotation Vectors')
    
    Y_mGSE_x = -spin_y / sqrt( spin_x**2 + spin_y**2 )
    Y_mGSE_y = spin_x / sqrt( spin_x**2 + spin_y**2 )
    Y_mGSE_z = dblarr( len( Y_mGSE_x ) )
    
    Z_mGSE_x = -Y_mGSE_y * spin_z
    Z_mGSE_y = Y_mGSE_x * spin_z
    Z_mGSE_z = sqrt( spin_x**2 + spin_y**2 )   
        
        
    # ###
    # ### ROTATE B-FIELD INTO mGSE AND TAKE E*B=0
    # ###
    
    monitor.setProgressMessage('Rotating MAG data into mGSE')
    
    Bx_mGSE = ( Bx_GSE_raw * spin_x ) + ( By_GSE_raw * spin_y ) + ( Bz_GSE_raw * spin_z )
    By_mGSE = ( Bx_GSE_raw * Y_mGSE_x ) + ( By_GSE_raw * Y_mGSE_y ) + ( Bz_GSE_raw * Y_mGSE_z )
    Bz_mGSE = ( Bx_GSE_raw * Z_mGSE_x ) + ( By_GSE_raw * Z_mGSE_y ) + ( Bz_GSE_raw * Z_mGSE_z )
    
    Bx_mGSE_detrend = ( Bx_GSE_detrend * spin_x ) + ( By_GSE_detrend * spin_y ) + ( Bz_GSE_detrend * spin_z )
    By_mGSE_detrend = ( Bx_GSE_detrend * Y_mGSE_x ) + ( By_GSE_detrend * Y_mGSE_y ) + ( Bz_GSE_detrend * Y_mGSE_z )
    Bz_mGSE_detrend = ( Bx_GSE_detrend * Z_mGSE_x ) + ( By_GSE_detrend * Z_mGSE_y ) + ( Bz_GSE_detrend * Z_mGSE_z )
    
    monitor.setProgressMessage('Calculating Ex mGSE using E*B=0')
    
    Ex_mGSE = - ( ( Ey_mGSE * By_mGSE ) + ( Ez_mGSE * Bz_mGSE ) ) / Bx_mGSE
    
    Ex_mGSE.putProperty(QDataSet.UNITS , Ey_mGSE.property(QDataSet.UNITS))
    
    Bx_mGSE_smoothed = smooth( Bx_mGSE , 640 )
    Bx_mGSE_smoothed.putProperty( QDataSet.DEPEND_0 , Btime )
    By_mGSE_smoothed = smooth( By_mGSE , 640 )
    By_mGSE_smoothed.putProperty( QDataSet.DEPEND_0 , Btime )
    Bz_mGSE_smoothed = smooth( Bz_mGSE , 640 )
    Bz_mGSE_smoothed.putProperty( QDataSet.DEPEND_0 , Btime )
       
       
    # ###
    # ### GENERATE ORTHOGONAL VECTORS
    # ###  
    
    ( Nx , Ny , Nz , Rx_GSE , Ry_GSE , Rz_GSE ) = RBSP_FAC( bckg_file , ephem_file , Btime , lead_time , excess_time)
    
    monitor.setProgressMessage('Creating Radial and Azimuthal vectors')
    
    Rx_mGSE = ( Rx_GSE * spin_x ) + ( Ry_GSE * spin_y ) + ( Rz_GSE * spin_z ) # Redefine R_GSE vector in terms of mGSE (rather than rotate everything else back to GSE)
    Ry_mGSE = ( Rx_GSE * Y_mGSE_x ) + ( Ry_GSE * Y_mGSE_y ) + ( Rz_GSE * Y_mGSE_z )
    Rz_mGSE = ( Rx_GSE * Z_mGSE_x ) + ( Ry_GSE * Z_mGSE_y ) + ( Rz_GSE * Z_mGSE_z )
    
    TEMP_Px = -( Ny * Rz_mGSE ) + ( Nz * Ry_mGSE )
    TEMP_Py = -( Nz * Rx_mGSE ) + ( Nx * Rz_mGSE )
    TEMP_Pz = -( Nx * Ry_mGSE ) + ( Ny * Rx_mGSE )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 )
    
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    Qx = -( Py * Nz ) + ( Pz * Ny ) # ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx ) 
     
    # ###
    # ### WYGANT ERROR
    # ###  
     
    if( use_backup_poynting_method == 'T' ):
        for i in xrange( len( By_mGSE_smoothed ) ):
            if( abs( By_mGSE_smoothed[i]/Bx_mGSE_smoothed[i] ) > 5 or abs( Bz_mGSE_smoothed[i]/Bx_mGSE_smoothed[i] ) > 5 ):
                if( 'wygant_error_counter' not in locals() ):
                    wygant_error_counter = 1
                    print 'The Wygant error conditions for Ey,Ez have kicked in'
                    break
    
        if( 'wygant_error_counter' in locals() ):     
            monitor.setProgressMessage('Calculating Partial Poynting Flux')       
            (p1x_GSE,p1y_GSE,p1z_GSE,p2x_GSE,p2y_GSE,p2z_GSE) = backupFAC(Nx, Ny, Nz, spin_x, spin_y, spin_z)
            
            p1x_mGSE = ( p1x_GSE * spin_x   ) + ( p1y_GSE * spin_y   ) + ( p1z_GSE * spin_z   ) # Redefine p1_GSE vector in terms of mGSE
            p1y_mGSE = ( p1x_GSE * Y_mGSE_x ) + ( p1y_GSE * Y_mGSE_y ) + ( p1z_GSE * Y_mGSE_z )
            p1z_mGSE = ( p1x_GSE * Z_mGSE_x ) + ( p1y_GSE * Z_mGSE_y ) + ( p1z_GSE * Z_mGSE_z )
            
            p2x_mGSE = ( p2x_GSE * spin_x   ) + ( p2y_GSE * spin_y   ) + ( p2z_GSE * spin_z   ) # Redefine p1_GSE vector in terms of mGSE
            p2y_mGSE = ( p2x_GSE * Y_mGSE_x ) + ( p2y_GSE * Y_mGSE_y ) + ( p2z_GSE * Y_mGSE_z )
            p2z_mGSE = ( p2x_GSE * Z_mGSE_x ) + ( p2y_GSE * Z_mGSE_y ) + ( p2z_GSE * Z_mGSE_z )
        
            E_p1 = (Ex_mGSE * p1x_mGSE) + (Ey_mGSE * p1y_mGSE) + (Ez_mGSE * p1z_mGSE)
            B_p1 = (Bx_mGSE_detrend * p1x_mGSE) + (By_mGSE_detrend * p1y_mGSE) + (Bz_mGSE_detrend * p1z_mGSE)
            B_p2 = (Bx_mGSE_detrend * p2x_mGSE) + (By_mGSE_detrend * p2y_mGSE) + (Bz_mGSE_detrend * p2z_mGSE)
            
            E_p1.putProperty( QDataSet.LABEL, 'RBSP-'+SPACECRAFT+'   E!D&perp;1!N' )
            B_p1.putProperty( QDataSet.LABEL, 'RBSP-'+SPACECRAFT+'   B!D&perp;1!N' )
            B_p2.putProperty( QDataSet.LABEL, 'RBSP-'+SPACECRAFT+'   B!D&perp;2!N' )
            putProps( [ E_p1 , B_p1 , B_p2 ] , QDataSet.DEPEND_0 , Btime )
            
            E_p1_fft = Hanningfft( E_p1 , low_freq , high_freq , window , slide )
            B_p1_fft = Hanningfft( B_p1 , low_freq , high_freq , window , slide )
            B_p2_fft = Hanningfft( B_p2 , low_freq , high_freq , window , slide )
            
            fft_time = E_p1_fft.property(QDataSet.DEPEND_0)
            frequency_axis = E_p1_fft.property(QDataSet.DEPEND_1)
            
            (TEMP_Sn_partial , Sn_partial ) = PoyntingifyBackup( E_p1_fft, B_p1_fft, B_p2_fft, poynting_min )
            
            Sn_partial[0,:] = -1E6
            for i in xrange(len(Sn_partial[:,0])):
                for j in xrange(len(Sn_partial[0,:])):
                    if( i == 0 ):
                        Sn_partial[i,j] = -1E6
                        TEMP_Sn_partial[i,j] = -1E6
                    if( Sn_partial[i,j] > 0 ):
                        Sn_partial[i,j] = log(Sn_partial[i,j])
                    elif( Sn_partial[i,j] < 0 ):
                        Sn_partial[i,j] = -log(-Sn_partial[i,j])
                    if( TEMP_Sn_partial[i,j] > 0 ):
                        TEMP_Sn_partial[i,j] = log(TEMP_Sn_partial[i,j])
                    elif( TEMP_Sn_partial[i,j] < 0 ):
                        TEMP_Sn_partial[i,j] = -log(-TEMP_Sn_partial[i,j])
            Sn_partial.putProperty(QDataSet.DEPEND_0,fft_time)
            Sn_partial.putProperty(QDataSet.DEPEND_1,frequency_axis)
            Sn_partial.putProperty(QDataSet.VALID_MIN,-999999)
            Sn_partial.putProperty(QDataSet.VALID_MAX,999999)
            
            #plot(5,Sn_partial)
            #print max(abs(Sn_partial))
            #dat = DatumRange( Units.us2000.createDatum(QDataSet.value( starttime[wave] - diff_seconds )*1E6) , Units.us2000.createDatum(QDataSet.value( endtime[wave] + diff_seconds )*1E6) )
            #dom.plots[5].xaxis.setRange( dat )
           
    # ###
    # ### FIELD-ALIGN  DATA
    # ###
    
    monitor.setProgressMessage('Rotating into Field-Aligned Coordinates')
    
    Bn = (Bx_mGSE_detrend * Nx) + (By_mGSE_detrend * Ny) + (Bz_mGSE_detrend * Nz)
    Bp = (Bx_mGSE_detrend * Px) + (By_mGSE_detrend * Py) + (Bz_mGSE_detrend * Pz)
    Bq = (Bx_mGSE_detrend * Qx) + (By_mGSE_detrend * Qy) + (Bz_mGSE_detrend * Qz)
    
    Bn.putProperty ( QDataSet.LABEL , 'RBSP-'+SPACECRAFT+'   B!D||!N' )
    Bp.putProperty ( QDataSet.LABEL , 'RBSP-'+SPACECRAFT+'   B!D&perp;az!N' )
    
    En = (Ex_mGSE * Nx) + (Ey_mGSE * Ny) + (Ez_mGSE * Nz)
    Ep = (Ex_mGSE * Px) + (Ey_mGSE * Py) + (Ez_mGSE * Pz)
    Eq = (Ex_mGSE * Qx) + (Ey_mGSE * Qy) + (Ez_mGSE * Qz)
       
    putProps( [ Bn , Bp , Bq , En , Ep , Eq ] , QDataSet.DEPEND_0 , Btime )
       
       
    # ###
    # ### THROW OUT DATA THAT DOES NOT SATISFY CLUSTER CONDITIONS (THETA>15, Bx>2nT)
    # ###
    
    monitor.setProgressMessage('Throwing Out Bad Data (Bx mGSE < 2 nT)')
    
    for i in xrange( len( Bx_mGSE ) ):
        if ( abs( Bx_mGSE_smoothed[i] ) < 2 ): # This throws out all data when Bx_mGSE < 2 nT (as per CLUSTER definitions of good data)
            print 'Bx_mGSE is less than 2nT'
            Bn[i] = Bp[i] = Bq[i] = En[i] = Ep[i] = Eq[i] = 0
        elif ( abs( acos( spin_x[i] ) ) < 0.262 ): # This throws out all data when theta < 15 degrees (again as per CLUSTER definitions of good data)
            print 'Spin axis angle with sun-earth line is too small'
            Bn[i] = Bp[i] = Bq[i] = En[i] = Ep[i] = Eq[i] = 0
        elif ( abs( By_mGSE_smoothed[i]/Bx_mGSE_smoothed[i] ) > 5 or abs( Bz_mGSE_smoothed[i]/Bx_mGSE_smoothed[i] ) > 5 ): # This throws out all data when the ratio of By/Bx or Bz/Bx is greater than 5, since the errors in Ey,Ez will be overmagnified (John Wygant requirement)
            print 'The Wygant error conditions for Ey,Ez have kicked in'
            Bn[i] = Bp[i] = Bq[i] = En[i] = Ep[i] = Eq[i] = 0
        elif ( Ey_mGSE[i] == -1E31 ): # These two throw out all data when fill values for EFW are detected (had a bunch of array length errors otherwise)
            print 'Ey mGSE is all fill data'
            Bn[i] = Bp[i] = Bq[i] = En[i] = Ep[i] = Eq[i] = 0
        elif ( Ez_mGSE[i] == -1E31 ):
            print 'Ez mGSE is all fill data'
            Bn[i] = Bp[i] = Bq[i] = En[i] = Ep[i] = Eq[i] = 0
    
    del ( Bx_mGSE , By_mGSE , Bz_mGSE , Bx_mGSE_detrend , By_mGSE_detrend , Bz_mGSE_detrend , Ex_mGSE , Ey_mGSE , Ez_mGSE )
    
    
    # ###
    # ### GENERATE B&E FIELD FFTS
    # ###
    
    Bn_fft = Hanningfft( Bn , freq_min , freq_max , window , slide )
    Bp_fft = Hanningfft( Bp , freq_min , freq_max , window , slide )
    Bq_fft = Hanningfft( Bq , freq_min , freq_max , window , slide )
    
    En_fft = Hanningfft( En , freq_min , freq_max , window , slide )
    Ep_fft = Hanningfft( Ep , freq_min , freq_max , window , slide )
    Eq_fft = Hanningfft( Eq , freq_min , freq_max , window , slide )
    
    fft_time = Bn_fft.property(QDataSet.DEPEND_0)
    frequency_axis = Bn_fft.property(QDataSet.DEPEND_1)
    
    fft_time.putProperty(QDataSet.NAME,'fft_time')
    
    
    # ###
    # ### CALCULATE POYNTING FLUX
    # ###
    
    ( Smag , Poynting_theta, Poynting_phi, Sn, Sp, Sq, TEMP_Sn, TEMP_Sp, TEMP_Sq ) = Poyntingify( Bn_fft , Bp_fft , Bq_fft , En_fft , Ep_fft , Eq_fft , wave_power_min )
    
    
    ###
    ### WRITE RESULTS
    ###
    
    temp_output_file = 'C:/Users/krist/Desktop/TEMP_poynting.cdf'
    b_mfa = putProperty(bundle(Bn,Bp,Bq),QDataSet.DEPEND_0,Btime)
    b_mfa.putProperty(QDataSet.LABEL,'B_MFA')
    #b_mfa.putProperty( QDataSet.DEPEND_1,labelsDataset(['B!B||!N','B!B&perp;east!N','B!B&perp;rad!N'] , 'MFA') )
    e_mfa = putProperty(bundle(En,Ep,Eq),QDataSet.DEPEND_0,Btime)
    e_mfa.putProperty(QDataSet.LABEL,'E_MFA')
    #e_mfa.putProperty(QDataSet.DEPEND_1,labelsDataset(['E!B||!N','E!B&perp;east!N','E!B&perp;rad!N'] , 'MFA') )
    
    if( write_file_yn == 'T' ):
      formatDataSet(b_mfa,output_file+'?b_mfa')
      formatDataSet(e_mfa,output_file+'?e_mfa&append=T')
      formatDataSet(Smag,output_file+'?Smag&append=T')
      formatDataSet(Poynting_theta,output_file+'?S_theta&append=T')
      formatDataSet(Poynting_phi,output_file+'?S_phi&append=T')
      formatDataSet(Sn,output_file+'?Sn_parallel&append=T')
      formatDataSet(Sp,output_file+'?Sp_perp_az&append=T')
      formatDataSet(Sq,output_file+'?Sq_perp_rad&append=T')
    
    # ###
    # ### PLOT STUFF
    # ###
          
    reset()
          
    background_grey = java.awt.Color(216,216,216,255)
    
    monitor.setProgressMessage('Generating Plots')
    
    from org.das2.graph.DasColorBar.Type import BLUE_WHITE_RED_WEDGE
    from org.das2.graph.DasColorBar.Type import WRAPPED_COLOR_WEDGE
    
    if( ratios_or_angles == 'Angles' ):
        plotx ( 0 , Smag , ytitle='Frequency (Hz)', ylog=0 , yrange=[freq_min, freq_max] , zlog=1, zrange=[wave_power_min , wave_power_max], ztitle='Poynting Flux !C   Magnitude!C     (&mu;W/m!U2!N)' , title = 'Poynting Vector Analysis for Van Allen Probe-'+SPACECRAFT)
        if( 'wygant_error_counter' not in locals() ):
            plotx ( 1 , Poynting_theta , ylog=0 , yrange=[freq_min, freq_max] , ztitle='            Angle &theta;!C!DToward                                   Toward!C!D  Pole                                        Equator' , zlog=0, zrange=[ 0 , 180 ] )
        elif( 'wygant_error_counter' in locals() ):
            plotx ( 1 , Sn_partial , ylog=0 , yrange=[freq_min, freq_max] , ztitle='            Angle &theta;!C!DToward                                   Toward!C!D  Pole                                        Equator' , zlog=0, zrange=[ -2 , 2 ] )
        plotx ( 2 , Poynting_phi , ylog=0 , yrange=[freq_min, freq_max] , ztitle='Angle &phi; (deg.)!C!D0 = Radially Outward!C!D90 = Eastward' , zlog=0, zrange=[ -180 , 180 ] )
    
        dom.plots[0].xaxis.drawTickLabels = 0
        dom.plots[0].controller.dasColorBar.setFillColor(background_grey)
        
        dom.plots[1].xaxis.drawTickLabels = 0
        dom.plots[1].displayTitle = 0
        #dom.plots[1].setColortable(GRAYSCALE)
        dom.plots[1].setColortable(BLUE_WHITE_RED_WEDGE)
        dom.plots[1].controller.dasColorBar.setFillColor(background_grey)
        
        dom.plots[2].xaxis.drawTickLabels = 1
        dom.plots[2].displayTitle = 0
        #dom.plots[2].setColortable(GRAYSCALE)
        dom.plots[2].setColortable(WRAPPED_COLOR_WEDGE)
        dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
        dom.plots[2].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SPACECRAFT+'.dsdf&interval=60'
        #dom.plots[2].xaxis.controller.dasAxis.useDomainDivider = 1
        
        fixLayout()
        
        dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more compact
        dom.plots[1].controller.dasPlot.row.ptMaximum = 10
        dom.plots[2].controller.dasPlot.row.ptMaximum = 10
        
        dom.controller.bind( dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
        dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE )
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )
    
    elif( ratios_or_angles == 'Ratios' ):
        plotx ( 0 , Smag , ytitle='Frequency (Hz)', ylog=0 , yrange=[freq_min, freq_max] , zlog=1, zrange=[wave_power_min , wave_power_max], ztitle='Poynting Flux Magnitude!C          (&mu;W/m!U2!N)' , title = 'Poynting Vector Analysis for Van Allen Probe-'+SPACECRAFT)
        plotx ( 1 , Sn , ylog=0 , yrange=[freq_min, freq_max] , ztitle='           Poynting flux!C              Along B!C!DTowards                              Towards!N!C!D   Pole                                 Equator!N' , zlog=0, zrange=[ -1 , 1 ] )
        plotx ( 2 , Sp , ylog=0 , yrange=[freq_min, freq_max] , ztitle='           Poynting flux!C             Azimuthal!C!DEastward                           Westward' , zlog=0, zrange=[ -1 , 1 ] )
        plotx ( 3 , Sq , ylog=0 , yrange=[freq_min, freq_max] , ztitle='       Poynting flux!C            Radial!C!DOutward                        Inward' , zlog=0, zrange=[ -1 , 1 ] )

        dom.plots[0].xaxis.drawTickLabels = 0
        dom.plots[0].controller.dasColorBar.setFillColor(background_grey)

        dom.plots[1].xaxis.drawTickLabels = 0
        dom.plots[1].displayTitle = 0
        dom.plots[1].setColortable(BLUE_WHITE_RED_WEDGE)
        dom.plots[1].controller.dasColorBar.setFillColor(background_grey)

        dom.plots[2].xaxis.drawTickLabels = 0
        dom.plots[2].displayTitle = 0
        dom.plots[2].setColortable(BLUE_WHITE_RED_WEDGE)
        dom.plots[2].controller.dasColorBar.setFillColor(background_grey)

        #dom.plots[3].xaxis.drawTickLabels = 0
        dom.plots[3].displayTitle = 0
        dom.plots[3].setColortable(BLUE_WHITE_RED_WEDGE)
        dom.plots[3].controller.dasColorBar.setFillColor(background_grey)
        dom.plots[3].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SPACECRAFT+'.dsdf&interval=60'

        fixLayout()

        dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more compact
        dom.plots[1].controller.dasPlot.row.ptMaximum = 10
        dom.plots[2].controller.dasPlot.row.ptMaximum = 10
        dom.plots[3].controller.dasPlot.row.ptMaximum = 10

        dom.controller.bind( dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
        dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE )
        dom.controller.bind( dom.plots[3].yaxis, dom.plots[3].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE )
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[3].xaxis, dom.plots[3].xaxis.PROP_RANGE )
        dom.controller.bind( dom.plots[2].zaxis, dom.plots[2].zaxis.PROP_RANGE,  dom.plots[1].zaxis, dom.plots[1].zaxis.PROP_RANGE ) #adds binding along Poynting Flux ratio between plots
        dom.controller.bind( dom.plots[3].zaxis, dom.plots[3].zaxis.PROP_RANGE,  dom.plots[1].zaxis, dom.plots[1].zaxis.PROP_RANGE )
    
    elif( ratios_or_angles == 'Components' ):
        
        plotx ( 0 , TEMP_Sn , ylog=0 , yrange=[freq_min, freq_max] , ztitle='           Poynting flux!C              Along B!C!DTowards                              Towards!N!C!D   Pole                                 Equator!N' , zlog=1, zrange=[wave_power_min , wave_power_max] , title = 'Poynting Vector Analysis for Van Allen Probe-'+SPACECRAFT )
        plotx ( 1 , TEMP_Sp , ylog=0 , yrange=[freq_min, freq_max] , ztitle='           Poynting flux!C             Azimuthal!C!DEastward                           Westward' , zlog=1, zrange=[wave_power_min , wave_power_max] )
        plotx ( 2 , TEMP_Sq , ylog=0 , yrange=[freq_min, freq_max] , ztitle='       Poynting flux!C            Radial!C!DOutward                        Inward' , zlog=1, zrange=[wave_power_min , wave_power_max] )

        dom.plots[0].xaxis.drawTickLabels = 0
        dom.plots[0].setColortable(COLOR_WEDGE)
        dom.plots[0].controller.dasColorBar.setFillColor(background_grey)

        dom.plots[1].xaxis.drawTickLabels = 0
        dom.plots[1].displayTitle = 0
        dom.plots[1].setColortable(COLOR_WEDGE)
        dom.plots[1].controller.dasColorBar.setFillColor(background_grey)
 
        dom.plots[2].xaxis.drawTickLabels = 1
        dom.plots[2].displayTitle = 0
        dom.plots[2].setColortable(COLOR_WEDGE)
        dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
        dom.plots[2].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SPACECRAFT+'.dsdf&interval=60'

        fixLayout()
        
        dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more compact
        dom.plots[1].controller.dasPlot.row.ptMaximum = 10
        dom.plots[2].controller.dasPlot.row.ptMaximum = 10

        dom.controller.bind( dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
        dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE ) 
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )
        dom.controller.bind( dom.plots[2].zaxis, dom.plots[2].zaxis.PROP_RANGE,  dom.plots[0].zaxis, dom.plots[0].zaxis.PROP_RANGE ) #adds binding along Poynting Flux ratio between plots
        dom.controller.bind( dom.plots[1].zaxis, dom.plots[1].zaxis.PROP_RANGE,  dom.plots[0].zaxis, dom.plots[0].zaxis.PROP_RANGE )

    dom.canvases[0].setFitted(False)
    dom.canvases[0].setHeight(924)
    dom.canvases[0].setWidth(924)
    
    #      png_out_file = 'D:\Research\EMIC\Pearl\\'+timerange+'_RBSP-'+spacecraft+'_Poynting_Angles'#Change this location for plot output or else comment it out
    
    #      if ( exists(png_out_file+'.png') ):
    #          writeToPng(png_out_file+'-TEMP.png')
    #      else:
    #          writeToPng(png_out_file+'.png')
    
       
   
##########################################################################################################  
########################################################################################################## 
   
   


# ###
# ### EXECUTE SCRIPT
# ###


reset()
monitor.started()

MAIN()

monitor.finished()



# elif (ratios_or_angles == 'Components'):

      # if (wave_power_min > 0 ): # this executes a step function zero-ing out poynting flux where there are no waves, since I am plotting it as a factor of total flux
        # for j in xrange( len(Sn[1,:]) ):
          # for i in xrange( len(Sn[:,1]) ):
            # if ( Smag[i,j] < wave_power_min):
              # aSn[i,j] = -1E39
              # aSp[i,j] = -1E39
              # aSq[i,j] = -1E39

      # aSn.putProperty ( QDataSet.DEPEND_0 , fft_time )
      # aSn.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
      # aSn.putProperty ( QDataSet.VALID_MIN , -1E38 )

      # aSp.putProperty ( QDataSet.DEPEND_0 , fft_time )
      # aSp.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
      # aSp.putProperty ( QDataSet.VALID_MIN , -1E38 )

      # aSq.putProperty ( QDataSet.DEPEND_0 , fft_time )
      # aSq.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
      # aSq.putProperty ( QDataSet.VALID_MIN , -1E38 )



      # ###
      # ### PLOT STUFF
      # ###
      # background_grey = java.awt.Color(216,216,216,255)

      # monitor.setTaskProgress(48)
      # monitor.setProgressMessage('Generating Plots')


      # from org.das2.graph.DasColorBar.Type import COLOR_WEDGE

      # plotx ( 0 , aSn , ylog=0 , yrange=[freq_min, freq_max] , ztitle='           Poynting flux!C              Along B!C!DTowards                              Towards!N!C!D   Pole                                 Equator!N' , zlog=1, zrange=[wave_power_min , wave_power_max] , title = 'Poynting Vector Analysis for RBSP S/C-'+SC_upper+' ~ '+timerange+'T'+str(int(start_hour))+'-'+str(int(end_hour) ) )
      # plotx ( 1 , aSp , ylog=0 , yrange=[freq_min, freq_max] , ztitle='           Poynting flux!C             Azimuthal!C!DEastward                           Westward' , zlog=1, zrange=[wave_power_min , wave_power_max] )
      # plotx ( 2 , aSq , ylog=0 , yrange=[freq_min, freq_max] , ztitle='       Poynting flux!C            Radial!C!DOutward                        Inward' , zlog=1, zrange=[wave_power_min , wave_power_max] )

      # dom.plots[0].xaxis.drawTickLabels = 0
      # dom.plots[0].setColortable(COLOR_WEDGE)
      # dom.plots[0].controller.dasColorBar.setFillColor(background_grey)

      # dom.plots[1].xaxis.drawTickLabels = 0
      # dom.plots[1].displayTitle = 0
      # #dom.plots[1].setColortable(GRAYSCALE)
      # dom.plots[1].setColortable(COLOR_WEDGE)
      # dom.plots[1].controller.dasColorBar.setFillColor(background_grey)

      # dom.plots[2].xaxis.drawTickLabels = 1
      # dom.plots[2].displayTitle = 0
      # #dom.plots[2].setColortable(GRAYSCALE)
      # dom.plots[2].setColortable(COLOR_WEDGE)
      # dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
      # dom.plots[2].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SC_upper+'.dsdf&timerange='+timerange+'&interval=60'


      # import org.virbo.autoplot.dom.DomOps.newCanvasLayout
      # org.virbo.autoplot.dom.DomOps.newCanvasLayout(dom) #Applies "Fix Layout" tool after eliminating axes

      # dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more compact
      # dom.plots[1].controller.dasPlot.row.ptMaximum = 10
      # dom.plots[2].controller.dasPlot.row.ptMaximum = 10

      # dom.controller.bind( dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
      # dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[0].yaxis, dom.plots[0].yaxis.PROP_RANGE )

      # dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
      # dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )

      # dom.controller.bind( dom.plots[2].zaxis, dom.plots[2].zaxis.PROP_RANGE,  dom.plots[0].zaxis, dom.plots[0].zaxis.PROP_RANGE ) #adds binding along Poynting Flux ratio between plots
      # dom.controller.bind( dom.plots[1].zaxis, dom.plots[1].zaxis.PROP_RANGE,  dom.plots[0].zaxis, dom.plots[0].zaxis.PROP_RANGE )

      # print 'END POYNTING FLUX ROUTINE'
      # monitor.finished()

