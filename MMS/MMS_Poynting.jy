
# ##########################################################
# #                                                        #
# #             POLARIZATION ROUTINE FOR MMS               # 
# #                                                        #
# #             KRISTOFF PAULSON - JULY 2015               #
# #                                                        #
# ##########################################################


import java
from org.das2.math.filter import Butterworth
from org.virbo.dsops.Ops import FFTFilterType
from org.das2.datum.Units import *
from org.virbo.dsutil import LinFit
from org.das2.graph.DasColorBar.Type import *
from org.virbo.autoplot.RenderType import *
from org.das2.datum import *


# ############################################################################################

def putProps( dss, name='DEPEND_0', value=None ):
    for ds in dss:
        ds.putProperty( name, value )

# ############################################################################################

def trim_it_merge_it(ds,ds_time,processed_ds,window,leading_points):
    """Integral part of Hanningfft subroutine, makes the slide function possible by trimming off the beginning of the data set and reapplying the Hanning windowing function, then resorting the result back into the dataset. 
    
    Parameters:
        ds = The rank1 dataset upon which to perform trimming and windowing.
        ds_time = The DEPEND_0 component of ds (often stripped off when performing the Hanningfft routine).
        processed_ds = The already windowed rank2 version of ds from previous iterations.
        window = Size of window to be taken measured in number of data points.
        leading_points = The number of points to be trimmed from beginning of ds (typically iterated over window*(i+1)/slide)
        
    Outputs:
        result = merged processed rank2 version of ds."""
    
    ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    
    trimmed_ds = trim(ds,int(leading_points),int(len(ds)))
    trimmed_ds.putProperty( QDataSet.DEPEND_0 , trim(ds_time,int(leading_points),int(len(ds))) )
    
    processed_ds_too = hanning( trimmed_ds , window )
    processed_ds_too.putProperty( QDataSet.DEPEND_1 , ds.property(QDataSet.DEPEND_1) )
    
    processed_ds_time = processed_ds.property( QDataSet.DEPEND_0 )
    processed_ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    processed_ds.putProperty( QDataSet.DEPEND_0 , processed_ds_time )
    
    result = merge( processed_ds , processed_ds_too )
    return( result )

# ############################################################################################

def Hanningfft( ds , freq_min , freq_max , window , slide ):
    """FFT routine employing sliding Hanning window function while preserving both real and imaginary components. 
    
    Parameters:
        ds = The rank1 time-series input data.
        freq_min = Lower end of frequency range to be preserved (excess thrown out to speed up subsequent processing).
        freq_max = Upper end of frequency range.
        window = Length of window to be taken measured in number of data points.
        slide = Window overlap size, expressed as a fraction of the length (1 for no slide, 2 for half steps, 4 for quarters)
        
    Returns:
        waveform_fft = The rank3 fft result of both real and imaginary components trimmed to frequency range."""
    
    ds_time = ds.property(QDataSet.DEPEND_0)
    
    ds_cadence = convertUnitsTo((ds_time[1]-ds_time[0]),Units.seconds)
    per_sec = int(1./ds_cadence)
    
    processed_ds = hanning(ds,window)

    for i in xrange( slide ):
        try:
            processed_ds = trim_it_merge_it(ds,ds_time,processed_ds,window,window*(i+1)/slide)
        except( java.lang.ArrayIndexOutOfBoundsException ):
            pass

    TEMP_waveform_fft = dblarr( len(processed_ds[:,0]) , len(processed_ds[0,:]) , 2 )

    for i in xrange( len(processed_ds[:,0]) ):
        processed_ds_fft = 2 * fft( processed_ds[i,:] )
        TEMP_waveform_fft[i,:,:] = processed_ds_fft * sqrt(float(window)/per_sec) / 1.725

    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_0 , processed_ds.property(QDataSet.DEPEND_0) )
    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_1 , processed_ds_fft[:,0].property(QDataSet.DEPEND_0)*per_sec )
    TEMP_waveform_fft.property(QDataSet.DEPEND_1).putProperty( QDataSet.UNITS , Units.hertz )

    frequency_range = where( TEMP_waveform_fft.property(QDataSet.DEPEND_1).ge(freq_min).and(TEMP_waveform_fft.property(QDataSet.DEPEND_1).le(freq_max)) )
    waveform_fft = TEMP_waveform_fft[:,frequency_range,:]
    waveform_fft.putProperty( QDataSet.DEPEND_1 , TEMP_waveform_fft.property(QDataSet.DEPEND_1)[frequency_range] )
    del ( TEMP_waveform_fft )
    
    uniqueness = uniq( waveform_fft.property(QDataSet.DEPEND_0) )
    waveform_fft_time = waveform_fft.property(QDataSet.DEPEND_0)[uniqueness]
    waveform_fft = waveform_fft[uniqueness,:,:]
    waveform_fft.putProperty( QDataSet.DEPEND_0 , waveform_fft_time )
    
    return ( waveform_fft )
        

# ############################################################################################ 

def fft_power( ds_fft , fft_time , frequency_axis ):
    ds_fft_power = ds_fft[:,:,0]**2 + ds_fft[:,:,1]**2
    ds_fft_power.putProperty(QDataSet.DEPEND_0,fft_time)
    ds_fft_power.putProperty(QDataSet.DEPEND_1,frequency_axis)
    
    return(ds_fft_power)

# ############################################################################################ 

def Butterworth_Bandpassify( ds , polynomial_order , freq_min , freq_max , pass_or_reject ):
    """Butterworth bandwidth filter. 
    
    Parameters:
        ds = The rank1 time-series input data.
        polynomial_order = Order of Butterworth function to be fit to data (0, 1, or 2). Higher orders are more accurate but more expensive.
        freq_min = Lower end of frequency range to be preserved (excess thrown out to speed up subsequent processing).
        freq_max = Upper end of frequency range.
        pass_or_reject = True/False boolean input on whether keep/reject input frequency range 
        
    Returns:
        ds_bandfilter = The rank1 dataset either limited to or excluding frequency range."""
        
    ds_bandfilter = butterworth( ds , polynomial_order , freq_min , freq_max , pass_or_reject )
    
    return ( ds_bandfilter )
      
      
# ############################################################################################   

def Butterworth_Bandpassify_zeroPhase( ds , polynomial_order , freq_min , freq_max , pass_or_reject ):
    """Butterworth bandwidth filter guaranteed to preserve original waveform phase by running dataset through filter both forwards and backwards. 
    
    Parameters:
        ds = The rank1 time-series input data.
        polynomial_order = Order of Butterworth function to be fit to data (0, 1, or 2). Higher orders are more accurate but more expensive.
        freq_min = Lower end of frequency range to be preserved (excess thrown out to speed up subsequent processing).
        freq_max = Upper end of frequency range.
        pass_or_reject = True/False boolean input on whether keep/reject input frequency range 
        
    Returns:
        ds_bandfilter = The rank1 dataset either limited to or excluding frequency range."""
        
    ds_bandfilter = butterworth( ds , polynomial_order , freq_min , freq_max , pass_or_reject )
    ds_bandfilter_reversed = copy(reverse(ds_bandfilter))
    ds_bandfilter_reversed.putProperty(QDataSet.DEPEND_0,ds.property(QDataSet.DEPEND_0))
    ds_bandfilter = copy(reverse(butterworth( ds_bandfilter_reversed , polynomial_order , freq_min , freq_max , pass_or_reject )))
    ds_bandfilter.putProperty(QDataSet.DEPEND_0,ds.property(QDataSet.DEPEND_0))
    
    return ( ds_bandfilter )
      
      
# ######################################################################################################### 

def fieldAligner_BxVxB( Bx_GSE , By_GSE, Bz_GSE , Vx_GSE , Vy_GSE , Vz_GSE , trend_seconds ):
        
    # ###
    # ### BOXCAR SMOOTH RAW MAG and ELEC DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    Btotal = sqrt(Bx_GSE**2 + By_GSE**2 + Bz_GSE**2)        
    mag_time = Btotal.property(QDataSet.DEPEND_0)
    
    if( len(mag_time) != len(uniq(mag_time)) ):
        uniqueness = uniq(mag_time)
        mag_time = mag_time[uniqueness]
        Bx_GSE = Bx_GSE[uniqueness]
        By_GSE = By_GSE[uniqueness]
        Bz_GSE = Bz_GSE[uniqueness]
        Btotal = Btotal[uniqueness]
    
    Vtotal = sqrt(Vx_GSE**2 + Vy_GSE**2 + Vz_GSE**2)        
    veloc_time = Vtotal.property(QDataSet.DEPEND_0)
    
    if( len(veloc_timeec_time) != len(uniq(veloc_time)) ):
        uniqueness = uniq(veloc_time)
        veloc_time = elec_time[uniqueness]
        Vx_GSE = Vx_GSE[uniqueness]
        Vy_GSE = Vy_GSE[uniqueness]
        Vz_GSE = Vz_GSE[uniqueness]
        Vtotal = Vtotal[uniqueness]
    
    if( trend_seconds == 0 ):
        Bx_GSE_smooth = Bx_GSE
        By_GSE_smooth = By_GSE
        Bz_GSE_smooth = Bz_GSE
        Btotal_smooth = Btotal
        Vx_GSE_smooth = Vx_GSE
        Vy_GSE_smooth = Vy_GSE
        Vz_GSE_smooth = Vz_GSE
        Vtotal_smooth = Vtotal
    else:
        smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
        Bx_GSE_smooth = smooth(Bx_GSE,smooth_points)
        By_GSE_smooth = smooth(By_GSE,smooth_points)
        Bz_GSE_smooth = smooth(Bz_GSE,smooth_points)
        Btotal_smooth = smooth(Btotal,smooth_points)
        smooth_points = int(round(trend_seconds*1./convertUnitsTo(elec_time[1]-elec_time[0],Units.seconds),0))
        Vx_GSE_smooth = smooth(Vx_GSE,smooth_points)
        Vy_GSE_smooth = smooth(Vy_GSE,smooth_points)
        Vz_GSE_smooth = smooth(Vz_GSE,smooth_points)
        Vtotal_smooth = smooth(Vtotal,smooth_points)
    
    Nx = Bx_GSE_smooth / Btotal_smooth
    Ny = By_GSE_smooth / Btotal_smooth
    Nz = Bz_GSE_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
        
    veloc_to_mag_ratio = findex(veloc_time,mag_time)
    
    Vx_GSE_smooth = interpolate( (Vx_GSE_smooth/Vtotal_smooth) , veloc_to_mag_ratio )
    Vy_GSE_smooth = interpolate( (Vy_GSE_smooth/Vtotal_smooth) , veloc_to_mag_ratio )
    Vz_GSE_smooth = interpolate( (Vz_GSE_smooth/Vtotal_smooth) , veloc_to_mag_ratio )
    
    BxVx = ( Vz_GSE_smooth * Ny ) - ( Vy_GSE_smooth * Nz ) # BxV
    BxVy = ( Vx_GSE_smooth * Nz ) - ( Vz_GSE_smooth * Nx )
    BxVz = ( Vy_GSE_smooth * Nx ) - ( Vx_GSE_smooth * Ny )
    TEMP_Px = ( BxVy * Nz ) - ( BxVz * Ny ) # (BxV)xB 
    TEMP_Py = ( BxVz * Nx ) - ( BxVx * Nz ) 
    TEMP_Pz = ( BxVx * Ny ) - ( BxVy * Nx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # (BxV)xB  direction (Vperp)
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = ( Pz * Ny ) - ( Py * Nz ) # ~Eperp Direction (NxP)
    Qy = ( Px * Nz ) - ( Pz * Nx )
    Qz = ( Py * Nx ) - ( Px * Ny )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx_GSE * Nx) + (By_GSE * Ny) + (Bz_GSE * Nz)
    Bp = (Bx_GSE * Px) + (By_GSE * Py) + (Bz_GSE * Pz)
    Bq = (Bx_GSE * Qx) + (By_GSE * Qy) + (Bz_GSE * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
           
                             
    # ###
    # ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    # ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N (%{UNITS})')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
    Bn.putProperty(QDataSet.UNITS,Units.nT)
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;ExB!N (%{UNITS})')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;ExB!N')
    Bp.putProperty(QDataSet.UNITS,Units.nT)
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;~E!N (%{UNITS})')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;~E!N')
    Bq.putProperty(QDataSet.UNITS,Units.nT)
    Btotal.putProperty(QDataSet.LABEL,'|B| (%{UNITS})')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    Btotal.putProperty(QDataSet.UNITS,Units.nT)
    
    Bn.putProperty(QDataSet.DEPEND_0,mag_time)
    Bp.putProperty(QDataSet.DEPEND_0,mag_time)
    Bq.putProperty(QDataSet.DEPEND_0,mag_time)
    Nx.putProperty(QDataSet.DEPEND_0,mag_time)
    Ny.putProperty(QDataSet.DEPEND_0,mag_time)
    Nz.putProperty(QDataSet.DEPEND_0,mag_time)
    Px.putProperty(QDataSet.DEPEND_0,mag_time)
    Py.putProperty(QDataSet.DEPEND_0,mag_time)
    Pz.putProperty(QDataSet.DEPEND_0,mag_time)
    Qx.putProperty(QDataSet.DEPEND_0,mag_time)
    Qy.putProperty(QDataSet.DEPEND_0,mag_time)
    Qz.putProperty(QDataSet.DEPEND_0,mag_time)
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )


# #########################################################################################################           
    
def field_aligner( Bx_GSE , By_GSE, Bz_GSE , Btotal , TEMP_Rx_GSE , TEMP_Ry_GSE , TEMP_Rz_GSE , trend_seconds ):
    
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_GSE_smooth = smooth(Bx_GSE,smooth_points)
    By_GSE_smooth = smooth(By_GSE,smooth_points)
    Bz_GSE_smooth = smooth(Bz_GSE,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_GSE_smooth / Btotal_smooth
    Ny = By_GSE_smooth / Btotal_smooth
    Nz = Bz_GSE_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    

    TEMP_Rmag = sqrt(TEMP_Rx_GSE**2 + TEMP_Ry_GSE**2 + TEMP_Rz_GSE**2)
    
    ephem_time = TEMP_Rx_GSE.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    Rx_GSE = interpolate( (TEMP_Rx_GSE/TEMP_Rmag) , ephem_to_mag_ratio )
    Ry_GSE = interpolate( (TEMP_Ry_GSE/TEMP_Rmag) , ephem_to_mag_ratio )
    Rz_GSE = interpolate( (TEMP_Rz_GSE/TEMP_Rmag) , ephem_to_mag_ratio )
    
    TEMP_Px = -( Ny * Rz_GSE ) + ( Nz * Ry_GSE ) # RxN ~Westwards
    TEMP_Py = -( Nz * Rx_GSE ) + ( Nx * Rz_GSE )
    TEMP_Pz = -( Nx * Ry_GSE ) + ( Ny * Rx_GSE )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # NxP ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx_GSE * Nx) + (By_GSE * Ny) + (Bz_GSE * Nz)
    Bp = (Bx_GSE * Px) + (By_GSE * Py) + (Bz_GSE * Pz)
    Bq = (Bx_GSE * Qx) + (By_GSE * Qy) + (Bz_GSE * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )


     
## #########################################################################################################
#
#def Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min , freq_avg ):
#
#    # ###
#    # ### RUN POLARIZATION ANALYSIS
#    # ###
#
#    # ###
#    # ### DEFINE J_PRIME (INPUT) MATRIX ELEMENTS
#    # ###
#
#    monitor.setLabel('Polarization')
#    monitor.setProgressMessage('Defining J-Prime Matrix Components')
#
#    Jxx_prime = ( (Bp_fft[:,:,0]*Bp_fft[:,:,0]) + (Bp_fft[:,:,1]*Bp_fft[:,:,1]) )
#    Jyy_prime = ( (Bq_fft[:,:,0]*Bq_fft[:,:,0]) + (Bq_fft[:,:,1]*Bq_fft[:,:,1]) )
#    Jzz_prime = ( (Bn_fft[:,:,0]*Bn_fft[:,:,0]) + (Bn_fft[:,:,1]*Bn_fft[:,:,1]) )
#
#    Jxy_prime_real = ( (Bp_fft[:,:,0]*Bq_fft[:,:,0]) + (Bp_fft[:,:,1]*Bq_fft[:,:,1]) )
#    Jxy_prime_img = ( (Bq_fft[:,:,0]*Bp_fft[:,:,1]) - (Bp_fft[:,:,0]*Bq_fft[:,:,1]) )
#
#    Jxz_prime_real = ( (Bp_fft[:,:,0]*Bn_fft[:,:,0]) + (Bp_fft[:,:,1]*Bn_fft[:,:,1]) )
#    Jxz_prime_img = ( (Bn_fft[:,:,0]*Bp_fft[:,:,1]) - (Bp_fft[:,:,0]*Bn_fft[:,:,1]) )
#
#    Jyz_prime_real = ( (Bn_fft[:,:,0]*Bq_fft[:,:,0]) + (Bn_fft[:,:,1]*Bq_fft[:,:,1]) )
#    Jyz_prime_img = ( (Bq_fft[:,:,0]*Bn_fft[:,:,1]) - (Bn_fft[:,:,0]*Bq_fft[:,:,1]) )
#
#    fft_time = Jxx_prime.property(QDataSet.DEPEND_0)
#    frequency_axis = Jxx_prime.property(QDataSet.DEPEND_1)
#
#
#    # ###
#    # ### DEFINE K-HAT VECTOR (MEANS - IMAGINARY COMPONENTS)
#    # ###
#
#    monitor.setProgressMessage('Finding Wave-Normal Direction (Means)')
#
#    img_mag = sqrt( Jxy_prime_img**2 + Jxz_prime_img**2 + Jyz_prime_img**2 )
#
#    trace = Jxx_prime + Jyy_prime + Jzz_prime
#
#    kx =  Jyz_prime_img / img_mag #kp
#    ky = -Jxz_prime_img / img_mag #kq
#    kz =  Jxy_prime_img / img_mag #kn
#
#    kx_linear = sqrt( Jxx_prime / trace )
#    ky_linear = Jxy_prime_real / ( trace * Jxx_prime )
#    kz_linear = Jxz_prime_real / ( trace * Jxx_prime )
#
#    r = where(lt( abs(img_mag) , 1E-5 )) # linear polarizations will have zero off-diagonal imaginary components
#    kx[r] = kx_linear[r]
#    ky[r] = ky_linear[r]
#    kz[r] = kz_linear[r]
#
#    trace.putProperty ( QDataSet.DEPEND_0 , fft_time )
#    trace.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
#
#    del ( img_mag , kx_linear , ky_linear , kz_linear )
#
#    lowering_ratio = findex( Nx.property( QDataSet.DEPEND_0 ) , fft_time )
#
#    Nx_fftcadence = interpolate ( Nx , lowering_ratio )
#    Ny_fftcadence = interpolate ( Ny , lowering_ratio )
#    Nz_fftcadence = interpolate ( Nz , lowering_ratio )
#
#    Nx_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#    Ny_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#    Nz_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#
#    for j in xrange( len( kx[1,:] ) ): # magnetic field direction is same at all times, so turn vector into an array where DEPEND_1 is constant
#          Nx_fftarray[:,j] = Nx_fftcadence
#          Ny_fftarray[:,j] = Ny_fftcadence
#          Nz_fftarray[:,j] = Nz_fftcadence
#
#    del ( [ Nx_fftcadence , Ny_fftcadence , Nz_fftcadence ] )
#
#    Nx_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
#    Nx_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
#    Ny_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
#    Ny_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
#    Nz_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
#    Nz_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
#
#    r = where(lt(kz,0)) #This is necessary because the direction of k is ambiguous, but the definition of wave polarization is specifically relative to |B| (Look up the Means paper if confused, this took a while to understand)
#    kx[r] = -kx[r] # Basically, aligns the ambiguity of k so that we look at it relative to the magnetic field direction
#    ky[r] = -ky[r]
#    kz[r] = -kz[r]
#
#    # ###
#    # ### DEFINE WAVE-NORMAL COORDINATES AND ROTATE J-PRIME - DEFINE J MATRIX IN _|_ DIRECTIONS
#    # ###
#
#    monitor.setProgressMessage('Creating Wave-Normal Coordinate System')
#
#    theta = acos( kz ) #Fixed from previous, kz is the Nth component (is really kn)
#    factor = sin( theta )
#
#    r = where(gt(theta,(PI/2.)))
#    theta[r] = PI - theta[r]
#
#
##    Rx = (ky * ones(len(kx))) / factor # R_hat = k_hat x N_hat so is perpendicular to plane of wave normal and magnetic field
##    Ry = -(kx * ones(len(kx))) / factor # THIS IS WRONG!! I can't figure out why, but Jzz has too much power if I use this rotation.
##    Rz = zeros(len(kx))
#
#    Rx = -(ky * ones(len(kx))) / factor # R_hat = N_hat x k_hat so is perpendicular to plane of wave normal and magnetic field
#    Ry = (kx * ones(len(kx))) / factor
#    Rz = zeros(len(kx))
#
#    Sx = -(Ry * kz) + (Rz * ky)# S_hat = k_hat x R_hat so is in plane of wave normal and magnetic field
#    Sy = -(Rz * kx) + (Rx * kz)
#    Sz = -(Rx * ky) + (Ry * kx)
#
#    Jxx = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#    Jyy = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#    Jzz = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#    Jxy_real = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#    Jxy_img = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
#
#    monitor.setProgressMessage('Rotating J-Prime into Wave-Normal')
#
#
#    # ###
#    # ### BELOW ROTATION VECTOR TAKES UNIT VECTORS  AS COLUMNS  - correct, at least on paper I think
#    # ###
#
#    Jxx = (Jxx_prime * (Rx**2)) + (Jyy_prime * (Sx**2)) + (Jzz_prime * (kx**2)) + 2*(Jxy_prime_real*Rx*Sx + Jxz_prime_real*Rx*kx + Jyz_prime_real*Sx*kx)
#    Jyy = (Jxx_prime * (Ry**2)) + (Jyy_prime * (Sy**2)) + (Jzz_prime * (ky**2)) + 2*(Jxy_prime_real*Ry*Sy + Jxz_prime_real*Ry*ky + Jyz_prime_real*Sy*ky)
#    Jzz = (Jxx_prime * (Rz**2)) + (Jyy_prime * (Sz**2)) + (Jzz_prime * (kz**2)) + 2*(Jxy_prime_real*Rz*Sz + Jxz_prime_real*Rz*kz + Jyz_prime_real*Sz*kz)
#
#    Jxy_real = Jxx_prime*Rx*Ry + Jyy_prime*Sx*Sy + Jzz_prime*kx*ky + Jxy_prime_real*(Rx*Sy + Sx*Ry) + Jxz_prime_real*(Rx*ky + Ry*kx) + Jyz_prime_real*(ky*Sx + Sy*kx)
#    Jxy_img = Jxy_prime_img*(Rx*Sy - Sx*Ry) + Jxz_prime_img*(Rx*ky - kx*Ry) + Jyz_prime_img*(ky*Sx - Sy*kx)
#
#    Wave_Power = Jxx + Jyy
#
#    del ( [ factor , kx , ky , kz , Nx , Ny , Nz , Rx , Ry , Rz , Sx , Sy , Sz , Jxy_prime_real , Jxz_prime_real , Jyz_prime_real , Jxy_prime_img , Jxz_prime_img , Jyz_prime_img ] )
#
#    # ###
#    # ### SMOOTHING OVER FREQUENCY BINS (NECESSARY FOR POLARIZATION COMPARISON ANALYSIS)
#    # ###
#
#    monitor.setProgressMessage('Smoothing Across Frequency Bins')
#
#    if ( len( Jxx[1,:] ) < 5 ):
#          freq_avg = 3 #number of frequency bins to average over for polarization, must be odd (is 5 too much? It's what is in Means paper)
#    elif ( len( Jxx[1,:] ) < 7 ):
#          freq_avg = 5
#    else:
#          pass#freq_avg = 5
#
#    #putProps( [ Jxx, Jyy, Jzz, Jxy_real, Jxy_img  ], QDataSet.VALID_MIN, -1E30 )
#    #putProps( [ Jxx, Jyy, Jzz, Jxy_real, Jxy_img  ], QDataSet.VALID_MAX, 1E30 )
#
#    try:
#        Jxx = smooth1( Jxx , freq_avg )
#        Jyy = smooth1( Jyy , freq_avg )
#        Jzz = smooth1( Jzz , freq_avg )
#        Jxy_real = smooth1( Jxy_real , freq_avg )
#        Jxy_img = smooth1( Jxy_img , freq_avg )
#    except:
#        try:
#            Jxx = transpose( smoothFit( frequency_axis , transpose(Jxx) , freq_avg ) )
#            Jyy = transpose( smoothFit( frequency_axis , transpose(Jyy) , freq_avg ) )
#            Jzz = transpose( smoothFit( frequency_axis , transpose(Jzz) , freq_avg ) )
#            Jxy_real = transpose( smoothFit( frequency_axis , transpose(Jxy_real) , freq_avg ) )
#            Jxy_img = transpose( smoothFit( frequency_axis , transpose(Jxy_img) , freq_avg ) )
#        except:
#            Jxx = transpose( smooth( transpose(Jxx) , freq_avg ) )
#            Jyy = transpose( smooth( transpose(Jyy) , freq_avg ) )
#            Jzz = transpose( smooth( transpose(Jzz) , freq_avg ) )
#            Jxy_real = transpose( smooth( transpose(Jxy_real) , freq_avg ) )
#            Jxy_img = transpose( smooth( transpose(Jxy_img) , freq_avg ) )
#
#    v = valid(Jxx)*valid(Jyy)*valid(Jzz)*valid(Jxy_real)*valid(Jxy_img)
#    v.putProperty(QDataSet.DEPEND_0,fft_time)
#    v.putProperty(QDataSet.DEPEND_1,frequency_axis)
#
#    J_det = ( Jxx*Jyy - (Jxy_real*Jxy_real + Jxy_img*Jxy_img) )
#
#    ###
#    ### POWER IN MAGNETIC FIELD DIRECTIONS
#    ###
#
#    #monitor.setTaskProgress(75)
#    #monitor.setProgressMessage('Defining Wave Intensity')
#
#    #Power_compressional = Jzz_prime
#    #Power_perp = sqrt(Jxx**2 + Jyy**2)
#    #Power_transverse = Jxx_prime + Jyy_prime # upon recommendation from Chuck, this is the wave intensity rather than magnitude of diagonal elements
#
#
#    # ###
#    # ### DEFINE POLARIZATION PARAMETERS USING J MATRIX
#    # ###
#
#    monitor.setProgressMessage('Calculating Degree of Polarization')
#    Deg_Polarization = sqrt( 1 - ( (4 * J_det) / ( (Jxx + Jyy)**2 ) ) ) * v
#    Deg_Polarization.putProperty( QDataSet.VALID_MIN , 0 )
#
#    monitor.setProgressMessage('Calculating Coherency')
#    Coherency = sqrt( (Jxy_real*Jxy_real + Jxy_img*Jxy_img) / (Jxx * Jyy) ) * v
#    Coherency.putProperty ( QDataSet.VALID_MIN , 0 )
#
#    Angle_Polarization = toDegrees( 0.5 * atan((2 * Jxx) / (Jxx - Jyy)) ) * v # sure Jxx isn't supposed to be Jxy_real?
#
#    monitor.setProgressMessage('Calculating Ellipticity and Handedness')
#    Handedness = ( (1 * (2 * Jxy_img) / sqrt( (Jxx + Jyy)**2 - (4 * J_det) ) )) * v
#    Ellipticity = ( tan ( 0.5 * asin( Handedness ) ))
#    Ellipticity.putProperty ( QDataSet.VALID_MIN , -1 )
#
#    monitor.setProgressMessage('Definining Wave-Normal angle relative to |B|')
#    Angle_Normal = toDegrees( theta )
#    Angle_Normal.putProperty ( QDataSet.VALID_MIN , 0 )
#
#    del ( [ Jxx , Jyy , Jzz , Jxy_real , Jxy_img , theta ] )
#
#
#    ###
#    ### ONLY KEEPING TERMS WITH WAVE POWER ASSOCIATED
#    ###
#
#    monitor.setProgressMessage('Throwing out Values of Low Wave Power')
#    if ( wave_power_min > 0 ): # this executes a step function zero-ing out spectra where there are no waves (to make it easier to see what is happening)
#        r = where(lt(Wave_Power,wave_power_min))
#        Angle_Normal[r] = -1
#        Ellipticity[r]  = -2
#        Coherency[r]    = -1
#
#    # ###
#    # ### SPIT OUT RESULTS
#    # ###
#
#    return ( Wave_Power , Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_Polarization )
#
#
## ##################################################################################

def mms_ephemerizer( mms_sc ):
    from org.das2.datum.Units import *
    
    starttime_input = getParam( 'Start Date and Time' , dom.plots[0].xaxis.range.min() , 'Any format you want, really' )
    endtime_input = getParam( 'End Date and Time' , dom.plots[0].xaxis.range.max() , 'End of wave activity' )
    
    plot_number = getParam( 'Plot Number' , 1 , 'Which plot do you want to add ephem data to?' )
    
    timerange = str(starttime_input)+' through '+str(endtime_input)
    
    try:
        mms_MLat = getDataSet('file:///D:/Research/MMS/Ephem_Data/MMS1_ephemeris.txt?depend0=data0&column=MLat')
        mms_MLT = getDataSet('file:///D:/Research/MMS/Ephem_Data/MMS1_ephemeris.txt?depend0=data0&column=MLT')
        mms_r = getDataSet('file:///D:/Research/MMS/Ephem_Data/MMS1_ephemeris.txt?depend0=data0&column=Re')
        ephem_time = mms_MLat.property(QDataSet.DEPEND_0)
        
        if( len(mms_r) < 1 ):
            raise java.io.fileNotFound
    except:
      try:
          mms_pos_sm = getDataSet('http://mmsdata.sr.unh.edu/%s/mec/srvy/l2/ephts04d/$Y/$m/%s_mec_srvy_l2_ephts04d_$Y$m$d_v$(v,sep).cdf?%s_mec_r_sm&timerange=%s'%(mms_sc,mms_sc,mms_sc,timerange))
          ephem_time = mms_pos_sm.property(QDataSet.DEPEND_0)
          
          uniqueness = uniq(ephem_time)
          mms_pos_sm = mms_pos_sm[uniqueness]
          ephem_time = ephem_time[uniqueness]
          
          Re = 6378.137
          mms_r = magnitude(mms_pos_sm)/Re
          theta = asin(mms_pos_sm[:,2]/magnitude(mms_pos_sm))
          phi = atan2(mms_pos_sm[:,1],mms_pos_sm[:,0])
          L_dipole_dwell = (magnitude(mms_pos_sm)/6371.)/(cos(theta)**2)
          if( (phi+PI).gt(0) ):
              MLT_dwell = mod((phi+PI)*12/PI,dataset(24))#(phi+PI)*12/PI
          elif( (phi+PI).le(0) ):
              MLT_dwell = mod(-(phi+PI)*12/PI,dataset(24))#-(phi+PI)*12/PI
      except:
          mms_pos_gsm = getDataSet('http://mmsdata.sr.unh.edu/%s/afg/srvy/ql/$Y/$m/%s_afg_srvy_ql_$Y$m$d_v$(v,sep).cdf?%s_ql_pos_gsm&timerange=%s'%(mms_sc,mms_sc,mms_sc,timerange))
          ephem_time = mms_pos_gsm.property(QDataSet.DEPEND_0)
      
          uniqueness = uniq(ephem_time)
          mms_pos_gsm = mms_pos_gsm[uniqueness]
          ephem_time = ephem_time[uniqueness]
          
          Re = 6378.137
          mms_r = mms_pos_gsm[:,3]/Re
          theta = asin(mms_pos_gsm[:,2]/mms_pos_gsm[:,3])
          phi = atan2(mms_pos_gsm[:,1],mms_pos_gsm[:,0])
          L_dipole_dwell = (mms_pos_gsm[:,3]/6371.)/(cos(theta)**2)
          if( (phi+PI).gt(0) ):
              MLT_dwell = mod((phi+PI)*12/PI,dataset(24))#(phi+PI)*12/PI
          elif( (phi+PI).le(0) ):
              MLT_dwell = mod(-(phi+PI)*12/PI,dataset(24))#-(phi+PI)*12/PI
      
      
      mms_MLat = round(toDegrees(theta),3)
      mms_MLT = round(copy(MLT_dwell),3)
      mms_r = round(copy(mms_r),3)
      mms_MLT.putProperty(QDataSet.NAME,'MLT')
      mms_MLat.putProperty(QDataSet.NAME,'MLat')
      mms_r.putProperty(QDataSet.NAME,'Re')
      
      r = where(mms_MLT.ge(0).and(mms_MLT.le(24)))
      mms_MLT = mms_MLT[r]
      mms_MLat = mms_MLat[r]
      mms_r = mms_r[r]
    
    mms_ephem = bundle(mms_MLT,mms_MLat,mms_r)
    mms_ephem.putProperty(QDataSet.DEPEND_0,ephem_time)
    mms_ephem.putProperty(QDataSet.NAME,'mms_ephem')
    #filename = 'C:/Users/Kristoff/Desktop/TEMP2.cdf'
    
    #filename = 'C:/Users/Kristoff/Desktop/TEMP.csv'
    #formatDataSet(mms1_ephem,filename)
    #dom.plots[0].setTicksURI(filename+'?bundle=field1-field2&depend0=Epoch&validMin=0&validMax=24')
    
    filename = 'C:/Users/Kristoff/Desktop/TEMP.txt'
    formatDataSet(mms_ephem,filename)
    #dom.plots[1].setTicksURI(filename+'?bundle=MLT-Re&depend0=field0&validMin=0&validMax=24')
    dom.plots[4].setTicksURI(filename+'?bundle=field1-field3&depend0=field0')


# ##################################################################################
   
def Poyntingify( Bn_fft , Bp_fft , Bq_fft , En_fft , Ep_fft , Eq_fft , TEMP_MLat , poynting_min ):
    
    ###
    ### RUN POYNTING FLUX ANALYSIS
    ###
    
#    monitor.setTaskProgress(40)
    monitor.setProgressMessage('Calculating Poynting Flux')
#    try:
#          TEMP_MLat = getDataSet( ephem_file+'&column=EDMAG_MLAT' )
#    except:
#        try:
#            TEMP_MLat = getDataSet(ephem_file_T89D+'&column=EDMAG_MLAT')
#        except:
#            try:
#                TEMP_MLat = getDataSet(ephem_file_T89Q+'&column=EDMAG_MLAT')
#            except:
#                TEMP_MLat = getDataSet(ephem_file_OP77Q+'&column=EDMAG_MLAT')
##          TEMP_MLat = getDataSet( ephem_file_backup+'&column=EDMAG_MLAT' )

    ephem_time = TEMP_MLat.property( QDataSet.DEPEND_0)
    if ( len(ephem_time) != len(uniq(ephem_time)) ):
        uniqueness = uniq(ephem_time)
        TEMP_MLat = TEMP_MLat[uniqueness] 
        ephem_time = ephem_time[uniqueness]
        
    fft_time = Bn_fft.property( QDataSet.DEPEND_0 )
    frequency_axis = Bn_fft.property( QDataSet.DEPEND_1 )
             
    ephem_to_fft_time_ratio = findex( ephem_time , fft_time )
    MLat_fftcadence = interpolate ( TEMP_MLat , ephem_to_fft_time_ratio )
    del ( TEMP_MLat )

#    TEMP_Sn = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )
#    TEMP_Sp = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )
#    TEMP_Sq = dblarr( len(Bn_fft[:,1,0]) , len(Bn_fft[1,:,0]) )

    TEMP_Sp = ( ( (En_fft[:,:,0]*Bq_fft[:,:,0]) + (En_fft[:,:,1]*Bq_fft[:,:,1]) ) - ( (Eq_fft[:,:,0]*Bn_fft[:,:,0]) + (Eq_fft[:,:,1]*Bn_fft[:,:,1]) ) ) / 4
    TEMP_Sq = ( ( (Ep_fft[:,:,0]*Bn_fft[:,:,0]) + (Ep_fft[:,:,1]*Bn_fft[:,:,1]) ) - ( (En_fft[:,:,0]*Bp_fft[:,:,0]) + (En_fft[:,:,1]*Bp_fft[:,:,1]) ) ) / 4
    TEMP_Sn = ( ( (Ep_fft[:,:,0]*Bq_fft[:,:,0]) + (Ep_fft[:,:,1]*Bq_fft[:,:,1]) ) - ( (Eq_fft[:,:,0]*Bp_fft[:,:,0]) + (Eq_fft[:,:,1]*Bp_fft[:,:,1]) ) ) / 4
    
    #etrace = ( (Ep_fft[:,:,0]*Ep_fft[:,:,0]) + (Ep_fft[:,:,1]*Ep_fft[:,:,1]) ) + ( (Eq_fft[:,:,0]*Eq_fft[:,:,0]) + (Eq_fft[:,:,1]*Eq_fft[:,:,1]) ) + ( (En_fft[:,:,0]*En_fft[:,:,0]) + (En_fft[:,:,1]*En_fft[:,:,1]) )

    del ( [ En_fft , Ep_fft , Eq_fft ] )

    Smag = sqrt(TEMP_Sn**2 + TEMP_Sp**2 + TEMP_Sq**2)

    putProps( [ Smag ], QDataSet.DEPEND_0, fft_time )
    putProps( [ Smag ], QDataSet.DEPEND_1, frequency_axis )

    Sn = TEMP_Sn / Smag
    Sp = TEMP_Sp / Smag
    Sq = TEMP_Sq / Smag

    Poynting_theta = acos( Sn ) * ( 180. / PI )
    Poynting_phi = atan2( Sp , Sq ) * ( 180. / PI )

    if (wave_power_min > 0 ): # this executes a step function zero-ing out poynting flux where there are no waves, since I am plotting it as a factor of total flux
        r = where(lt(Smag,poynting_min))
        Poynting_theta[r] = -1
        Poynting_phi[r]   = -181
#        for j in xrange( len(Sn[1,:]) ):
#                for i in xrange( len(Sn[:,1]) ):
#                      if ( Smag[i,j] < poynting_min ):
#                            Poynting_theta[i,j] = -1
#                            Poynting_phi[i,j] = -181

    #del ( [ Sn , Sp , Sq , TEMP_Sn , TEMP_Sp , TEMP_Sq ] )
    
    Poynting_theta.putProperty ( QDataSet.DEPEND_0 , fft_time )
    Poynting_theta.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    Poynting_theta.putProperty ( QDataSet.VALID_MIN , 0 )
   
    Poynting_phi.putProperty ( QDataSet.DEPEND_0 , fft_time )
    Poynting_phi.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    Poynting_phi.putProperty ( QDataSet.VALID_MIN , -180 ) 
    
    ###
    ### SPIT OUT RESULTS
    ###
    
    return ( Smag , Poynting_theta, Poynting_phi , Sn , Sp , Sq )
    
    
# ##################################################################################
# ##################################################################################

def MAIN():

    # ###
    # ### CHOOSE TIME ON EITHER SIDE OF INPUT TO ACCOUNT FOR FFT WINDOW SIZE
    # ###        
    
    diff_seconds = (((window)/2.)*(1./16.)) #Defines the number of seconds on either side of desired data subset to perform a full fft
    tp= TimeParser.create('$Y-$m-$dT$H:$M:$S.$(milli)$(micro)')   
    tp_title= TimeParser.create('$Y-$m-$dT$H:$M')
    
    starttime =  timegen(starttime_input,'1 ns',1)[0]
    endtime =  timegen(endtime_input,'1 ns',1)[0] 
    starttime.putProperty( QDataSet.UNITS , None )
    endtime.putProperty( QDataSet.UNITS , None )
    
    lead_time =  tp.format( Units.us2000.createDatum(QDataSet.value( starttime - (diff_seconds*1E6) )) , None )
    excess_time =  tp.format( Units.us2000.createDatum(QDataSet.value( endtime + (diff_seconds*1E6) )) , None )
    #timerange = lead_time+' through '+excess_time
    timerange = starttime_input+' to '+endtime_input
    
    #reset()
   
    ###
    ### PULL MAG DATA AND DEFINE FIELD-ALIGNED VECTOR
    ###
    
    monitor.setLabel('Downloading Mag File')       
    try:
        mag_data = getDataSet(mag_file_cdaweb+'&id=%s_fgm_b_gse_srvy_l2_clean&timerange=%s'%(mms_sc,timerange))
        TEMP_R_GSE = getDataSet(mag_file_cdaweb+'&id=%s_fgm_r_gse_srvy_l2&timerange=%s'%(mms_sc,timerange))
        if( len(mag_data) == 0 ):
            raise( noDataAvailable )
    except:
        try:
            mag_data = getDataSet(mag_file_lasp+'?%s_fgm_b_gse_srvy_l2&timerange=%s'%(mms_sc,timerange))
            TEMP_R_GSE = getDataSet(mag_file_lasp+'?%s_fgm_r_gse_srvy_l2&timerange=%s'%(mms_sc,timerange))
        except:
            try:
                mag_data = getDataSet(mag_file_unh+'?%s_afg_srvy_l2pre_gse&timerange=%s'%(mms_sc,timerange))
                TEMP_R_GSE = getDataSet(mag_file_unh+'?%s_pos_gse&timerange=%s'%(mms_sc,timerange))
            except:
                try:
                    mag_data = getDataSet(mag_file_unh_backup+'?%s_afg_b_gse_srvy_l2pre&timerange=%s'%(mms_sc,timerange))
                    TEMP_R_GSE = getDataSet(mag_file_unh_backup+'?%s_afg_r_gse_srvy_l2pre&timerange=%s'%(mms_sc,timerange))
                except:
                    mag_data = getDataSet(mag_local_file+'?%s_afg_srvy_dmpa&timerange=%s'%(mms_sc,timerange))
                    TEMP_R_GSE = getDataSet(mag_local_file+'?%s_ql_pos_gse&timerange=%s'%(mms_sc,timerange))
    
    mag_time = mag_data[:,3].property(QDataSet.DEPEND_0)
    
    TEMP_MLat = getDataSet(cdaweb_mag_ephem_file+'&id=%s_mec_mlat&timerange=%s'%(mms_sc,timerange))
    ephem_time = TEMP_MLat.property(QDataSet.DEPEND_0)
    
    ephem_time_to_mag_time_ratio = findex(ephem_time,mag_time)
    TEMP_MLat = interpolate(TEMP_MLat,ephem_time_to_mag_time_ratio)
    
    monitor.setLabel('Calculating FAC') 
    ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( mag_data[:,0] , mag_data[:,1], mag_data[:,2] , mag_data[:,3] , TEMP_R_GSE[:,0] , TEMP_R_GSE[:,1] , TEMP_R_GSE[:,2] , trend_seconds )
    #plot(0,Bn)
    #plot(1,Bp)
    #stop

    ###
    ### PULL WAVE DATA FOR CORRECT FREQUENCY RANGE IN FIELD-ALIGNED COORDINATES
    ###
    
    if( scm_or_fluxgate == 'scm' ):
        if( srvy_or_brst == 'srvy' ):
            scm_x = getDataSet(scm_srvy_file+'?%s_scm_scsrvy_scm123&slice1=0&timerange=%s'%(mms_sc,timerange))
            scm_y = getDataSet(scm_srvy_file+'?%s_scm_scsrvy_scm123&slice1=1&timerange=%s'%(mms_sc,timerange))
            scm_z = getDataSet(scm_srvy_file+'?%s_scm_scsrvy_scm123&slice1=2&timerange=%s'%(mms_sc,timerange))
            scm_time = scm_x.property(QDataSet.DEPEND_0)
        if( srvy_or_brst == 'slow' ):
            scm_x = getDataSet(scm_slow_file+'?%s_scm_scs_gse&slice1=0&timerange=%s'%(mms_sc,timerange))
            scm_y = getDataSet(scm_slow_file+'?%s_scm_scs_gse&slice1=1&timerange=%s'%(mms_sc,timerange))
            scm_z = getDataSet(scm_slow_file+'?%s_scm_scs_gse&slice1=2&timerange=%s'%(mms_sc,timerange))
            scm_time = scm_x.property(QDataSet.DEPEND_0)
        if( srvy_or_brst == 'fast' ):
            scm_x = getDataSet(scm_fast_file+'?%s_scm_scf_gse&slice1=0&timerange=%s'%(mms_sc,timerange))
            scm_y = getDataSet(scm_fast_file+'?%s_scm_scf_gse&slice1=1&timerange=%s'%(mms_sc,timerange))
            scm_z = getDataSet(scm_fast_file+'?%s_scm_scf_gse&slice1=2&timerange=%s'%(mms_sc,timerange))
            scm_time = scm_x.property(QDataSet.DEPEND_0)
        elif( srvy_or_brst == 'schb_brst' or srvy_or_brst == 'scb_brst' ):
            try:
                edp_burst = getDataSet(cdaweb_edp_burst_file+'&timerange=%s'%(timerange))
                if len(edp_burst) == 0:
                    raise noCDAWebFileException
            except:
                if( local_team_data_yn == 'T' ):
                    edp_burst = getDataSet(local_edp_burst_file+'&timerange=%s'%(timerange))
            edp_x = edp_burst[:,0]
            edp_y = edp_burst[:,1]
            edp_z = edp_burst[:,2]
            edp_time = edp_burst.property(QDataSet.DEPEND_0)
            if( srvy_or_brst == 'schb_brst' ):
                scm_burst = getDataSet(scm_schb_burst_file+'?%s_scm_schb_123&timerange=%s'%(mms_sc,timerange))
                scm_x = scm_burst[:,0]
                scm_y = scm_burst[:,1]
                scm_z = scm_burst[:,2]
                scm_time = scm_burst.property(QDataSet.DEPEND_0)
            elif( srvy_or_brst == 'scb_brst' ):
                if( local_team_data_yn == 'F' ):
                    try:
                        scm_scb_burst_file_cdaweb = 'vap+cdaweb:ds=%s_SCM_BRST_L2_SCB'%mms_sc.upper()
                        print 'scm_file:',scm_scb_burst_file_cdaweb+'?id=%s_scm_acb_gse_scb_brst_l2&timerange=%s'%(mms_sc,timerange)
                        scm_burst = getDataSet(scm_scb_burst_file_cdaweb+'?id=%s_scm_acb_gse_scb_brst_l2&timerange=%s'%(mms_sc,timerange))
                        scm_x = scm_burst[:,0]
                        scm_y = scm_burst[:,1]
                        scm_z = scm_burst[:,2]
                        scm_time = scm_burst.property(QDataSet.DEPEND_0)
                        if(len(scm_x)==0):
                            raise(zeroFileLengthException)
                    except:
                        scm_burst = getDataSet(scm_scb_burst_file+'?%s_scm_acb_gse_scb_brst_l2&timerange=%s'%(mms_sc,timerange))
                        scm_x = scm_burst[:,0]
                        scm_y = scm_burst[:,1]
                        scm_z = scm_burst[:,2]
                        scm_time = scm_burst.property(QDataSet.DEPEND_0)
                else:
                    scm_burst = getDataSet(scm_scb_burst_local_file+'?%s_scm_acb_gse_scb_brst_l2&timerange=%s'%(mms_sc,timerange))
                    scm_x = scm_burst[:,0]
                    scm_y = scm_burst[:,1]
                    scm_z = scm_burst[:,2]
                    scm_time = scm_burst.property(QDataSet.DEPEND_0)
            
            
        ###
        ### ROTATE SCM DATA INTO FIELD-ALIGNED COORDINATES
        ###
    
        mag_time_to_scm_time = findex( mag_time , scm_time )
        Nx = interpolate( Nx , mag_time_to_scm_time )
        Ny = interpolate( Ny , mag_time_to_scm_time )
        Nz = interpolate( Nz , mag_time_to_scm_time )
        Px = interpolate( Px , mag_time_to_scm_time )
        Py = interpolate( Py , mag_time_to_scm_time )
        Pz = interpolate( Pz , mag_time_to_scm_time )
        Qx = interpolate( Qx , mag_time_to_scm_time )
        Qy = interpolate( Qy , mag_time_to_scm_time )
        Qz = interpolate( Qz , mag_time_to_scm_time )
        TEMP_MLat = interpolate( TEMP_MLat , mag_time_to_scm_time )
    
        del( Bn , Bp , Bq )
        Bn = (scm_x*Nx) + (scm_y*Ny) + (scm_z*Nz)
        Bp = (scm_x*Px) + (scm_y*Py) + (scm_z*Pz)
        Bq = (scm_x*Qx) + (scm_y*Qy) + (scm_z*Qz)
    
        mag_time = copy(scm_time)
    
        edp_time_to_scm_time = findex( edp_time , scm_time )
        edp_x = interpolate( edp_x , edp_time_to_scm_time )
        edp_y = interpolate( edp_y , edp_time_to_scm_time )
        edp_z = interpolate( edp_z , edp_time_to_scm_time )
        
        En = (edp_x*Nx) + (edp_y*Ny) + (edp_z*Nz)
        Ep = (edp_x*Px) + (edp_y*Py) + (edp_z*Pz)
        Eq = (edp_x*Qx) + (edp_y*Qy) + (edp_z*Qz)
        
    if( scm_or_fluxgate == 'fluxgate' ):
        
        # Get Efield data
        #try:
        edp_dce_fast_file_lasp = 'https://lasp.colorado.edu/mms/sdc/public/data/mms1/edp/fast/l2/dce/$Y/$m/mms1_edp_fast_l2_dce_$Y$m$d_v$(v,sep).cdf'
        edp_fast = getDataSet(edp_dce_fast_file_lasp+'?%s_edp_dce_gse_fast_l2&timerange=%s'%(mms_sc,timerange))
        edp_x = edp_fast[:,0]
        edp_y = edp_fast[:,1]
        edp_z = edp_fast[:,2]
        
        # Interpolate MAG and coord vectors up to Efield cadence (avoids issues with aliased signals to do this and then throw out spectral data at higher frequencies)
        ( [Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz] ) = synchronize(edp_x,( [Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz] ))
        
        
        En = (edp_x*Nx) + (edp_y*Ny) + (edp_z*Nz)
        Ep = (edp_x*Px) + (edp_y*Py) + (edp_z*Pz)
        Eq = (edp_x*Qx) + (edp_y*Qy) + (edp_z*Qz)
        

    ###
    ### DEFINE DETRENDED DATA AND TRIM TO TIMERANGE
    ###
    
    Bn_detrend = Bn
    Bp_detrend = Bp
    Bq_detrend = Bq
    
    En_detrend = En
    Ep_detrend = Ep
    Eq_detrend = Eq
    
    del( Bn , Bp , Bq , Px , Py , Pz , Qx , Qy , Qz )
    
    try:
      Bn_detrend = trim(Bn_detrend,timerange)
      Bp_detrend = trim(Bp_detrend,timerange)
      Bq_detrend = trim(Bq_detrend,timerange)
      
      En_detrend = trim(En_detrend,timerange)
      Ep_detrend = trim(Ep_detrend,timerange)
      Eq_detrend = trim(Eq_detrend,timerange)
      
      mag_time = Bn_detrend.property(QDataSet.DEPEND_0)
    except:    
      #r = where( mag_time.ge( lead_time ).and( mag_time.le( excess_time ) ) )
      r = where( mag_time.ge( starttime_input ).and( mag_time.le( endtime_input ) ) )
      
      Bn_detrend = Bn_detrend[r]
      Bp_detrend = Bp_detrend[r]
      Bq_detrend = Bq_detrend[r]
      
      En_detrend = En_detrend[r]
      Ep_detrend = Ep_detrend[r]
      Eq_detrend = Eq_detrend[r]
      
      mag_time = mag_time[r]
        
    putProps( [ Bn_detrend , Bp_detrend , Bq_detrend , En_detrend , Ep_detrend , Eq_detrend ] , QDataSet.DEPEND_0 , mag_time )
    putProps( [ Bn_detrend , Bp_detrend , Bq_detrend ] , QDataSet.UNITS , Units.nT )
          
    if ( len(mag_time) != len(uniq(mag_time)) ):# This is used to solve the problem of two 00:00 timestamps when spanning multiple days
        raw_mag_uniqueness = uniq( mag_time )
        mag_time = mag_time[raw_mag_uniqueness]
        
        Bn_detrend = Bn_detrend[raw_mag_uniqueness]
        Bp_detrend = Bp_detrend[raw_mag_uniqueness]
        Bq_detrend = Bq_detrend[raw_mag_uniqueness]
        
        En_detrend = En_detrend[raw_mag_uniqueness]
        Ep_detrend = Ep_detrend[raw_mag_uniqueness]
        Eq_detrend = Eq_detrend[raw_mag_uniqueness]
    
    Bn_detrend.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn_detrend.putProperty(QDataSet.NAME,'B!B||!N')
    Bp_detrend.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
    Bp_detrend.putProperty(QDataSet.NAME,'B!B&perp;east!N')
    Bq_detrend.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
    Bq_detrend.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    
    En_detrend.putProperty(QDataSet.LABEL,'E!B||!N')
    En_detrend.putProperty(QDataSet.NAME,'E!B||!N')
    Ep_detrend.putProperty(QDataSet.LABEL,'E!B&perp;east!N')
    Ep_detrend.putProperty(QDataSet.NAME,'E!B&perp;east!N')
    Eq_detrend.putProperty(QDataSet.LABEL,'E!B&perp;rad!N')
    Eq_detrend.putProperty(QDataSet.NAME,'E!B&perp;rad!N')
    

    ###
    ### RUN FFT FOR EACH COMPONENT
    ###
    
    monitor.setLabel('Calculating FFTs') 
    monitor.setProgressMessage('Bn')
    Bn_fft = Hanningfft( Bn_detrend , freq_min , freq_max , window , slide ) # This applies the Hanning window and the performs an fft, see above
    monitor.setProgressMessage('Bp')
    Bp_fft = Hanningfft( Bp_detrend , freq_min , freq_max , window , slide )
    monitor.setProgressMessage('Bq')
    Bq_fft = Hanningfft( Bq_detrend , freq_min , freq_max , window , slide )
    
    monitor.setProgressMessage('En')
    En_fft = Hanningfft( En_detrend , freq_min , freq_max , window , slide ) # This applies the Hanning window and the performs an fft, see above
    monitor.setProgressMessage('Ep')
    Ep_fft = Hanningfft( Ep_detrend , freq_min , freq_max , window , slide )
    monitor.setProgressMessage('Eq')
    Eq_fft = Hanningfft( Eq_detrend , freq_min , freq_max , window , slide )
    
    fft_time = Bn_fft.property(QDataSet.DEPEND_0)
    frequency_axis = Bn_fft.property(QDataSet.DEPEND_1)
    

#    ###
#    ### PERFORM POLARIZATION ROUTINE
#    ###
#
#    monitor.setLabel('Polarization')
#    ( Wave_Power , Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization ) = Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min , freq_avg )
#
#    putProps( [ Wave_Power ] , QDataSet.DEPEND_0 , fft_time )
#    putProps( [ Wave_Power ] , QDataSet.DEPEND_1 , frequency_axis )
    
    ###
    ### PERFORM POYNTING ROUTINE
    ###
    
    monitor.setLabel('Poynting') 
    ( Smag , Poynting_theta, Poynting_phi , Sn , Sp , Sq ) = Poyntingify( Bn_fft , Bp_fft , Bq_fft , En_fft , Ep_fft , Eq_fft , TEMP_MLat , poynting_min )
    
    ###
    ### APPLY BUTTERWORTH (IF WANTED)
    ###
    
    if(skipButterworth == 'F'):
        monitor.setLabel('Butterworth Filter') 
        monitor.setProgressMessage('Bn')
        Bn_detrend = Butterworth_Bandpassify_zeroPhase( Bn_detrend , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )# Detrends data for fft use
        monitor.setProgressMessage('Bp')
        Bp_detrend = Butterworth_Bandpassify_zeroPhase( Bp_detrend , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )
        monitor.setProgressMessage('Bq')
        Bq_detrend = Butterworth_Bandpassify_zeroPhase( Bq_detrend , 2 , datum( str(freq_min)+' Hz' ) , datum( str(freq_max)+' Hz' ) , True )
    
    
    ###
    ### WRITE RESULTS
    ###
    
    temp_output_file = 'C:/Users/krist/Desktop/TEMP_poynting.cdf'
    b_mfa = putProperty(bundle(Bn_detrend,Bp_detrend,Bq_detrend),QDataSet.DEPEND_0,mag_time)
    b_mfa.putProperty(QDataSet.DEPEND_1,labels(['B!B||!N','B!B&perp;east!N','B!B&perp;rad!N']))
    e_mfa = putProperty(bundle(En_detrend,Ep_detrend,Eq_detrend),QDataSet.DEPEND_0,mag_time)
    e_mfa.putProperty(QDataSet.DEPEND_1,labels(['B!B||!N','B!B&perp;east!N','B!B&perp;rad!N']))
    
    if( write_file_yn == 'T' ):
      formatDataSet(b_mfa,output_file+'?b_mfa')
      formatDataSet(e_mfa,output_file+'?e_mfa&append=T')
      formatDataSet(Smag,output_file+'?Smag&append=T')
      formatDataSet(Poynting_theta,output_file+'?S_theta&append=T')
      formatDataSet(Poynting_phi,output_file+'?S_phi&append=T')
      formatDataSet(Sn,output_file+'?Sn_parallel&append=T')
      formatDataSet(Sp,output_file+'?Sp_perp_az&append=T')
      formatDataSet(Sq,output_file+'?Sq_perp_rad&append=T')
      
#      formatDataSet(Angle_Normal,output_file+'?Angle_Normal&append=T')
    
    
    ###
    ### PLOT RESULTS
    ###
    
    #starttitle =  tp_title.format( Units.us2000.createDatum(QDataSet.value(starttime)) , None )
    #endtitle =  tp_title.format( Units.us2000.createDatum(QDataSet.value(endtime)) , None )
    
    background_grey = java.awt.Color(216,216,216,255)
    
    if ( logyn == 'T'):
      logfreq = 1
    elif ( logyn == 'F'):
      logfreq = 0
    
    from org.das2.graph.DasColorBar.Type import APL_RAINBOW_BLACK0
    from org.das2.graph.DasColorBar.Type import BLUE_WHITE_RED_WEDGE
    from org.das2.graph.DasColorBar.Type import GRAYSCALE
    from org.das2.graph.DasColorBar.Type import INVERSE_GRAYSCALE
    from org.das2.graph.LegendPosition import *
    
    monitor.setLabel('Plotting Parameters')
    
    putProps([ Bp_detrend , Bq_detrend , Bn_detrend , Ep_detrend , Eq_detrend , En_detrend ] , QDataSet.VALID_MAX , valid_max )
    putProps([ Bp_detrend , Bq_detrend , Bn_detrend , Ep_detrend , Eq_detrend , En_detrend ] , QDataSet.VALID_MIN , valid_min )
    
    r = where(Bp_detrend.le(valid_max).and(Bp_detrend.ge(valid_min)).and(Bn_detrend.le(valid_max).and(Bn_detrend.ge(valid_min))))
    Bp_detrend = Bp_detrend[r]
    Bn_detrend = Bn_detrend[r]
    mag_time = mag_time[r]
    
    if( waveform_autoscale_yn == 'T' ):
        y_max = dataset( 1.1 * max( max(abs(Bp_detrend)) , max(abs(Bn_detrend)) ) )
    else:
        y_max = dataset( y_max_value )
        
    setLayoutOverplot(2)
    plotx ( 0 , mag_time , Bp_detrend , yrange=[-y_max.value(),y_max.value()] , title = 'Poynting Flux for '+MMS_SC , ytitle='Field!CCompnts. (nT)' )
    plotx ( 1 , mag_time , Bn_detrend , yrange=[-y_max.value(),y_max.value()] )
    dom.plotElements[0].setDisplayLegend(True)
    dom.plotElements[1].style.color= Color.BLUE
    dom.plotElements[1].setDisplayLegend(True)
    
    if( angles_or_ratios == 'angles' ):
        plotx ( 2 , fft_time , Smag           , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , zlog=1, zrange=[power_min , power_max], ztitle='Poynting Flux!C     (&mu;W/m)' )#, title = 'Polarization parameters for RBSP S/C-'+SC_upper+' - '+start_date+'T'+str(start_hour))
        plotx ( 3 , fft_time , Poynting_theta , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='Propagation Angle!CRelative to |B|', zlog=0, zrange=[0,180] )
        plotx ( 4 , fft_time , Poynting_phi   , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='Clock Angle', zrange=[-180, 180])
        #plotx ( 5 , fft_time , Ellipticity , ylog=logfreq , yrange=[freq_min, freq_max] , zrange=[-1 , 1], ztitle='     Ellipticity!CRH               LH')#, ztitle='              Ellipticity!C!BRight                         Left!C!BHand                       Hand!N' )
        
        monitor.setProgressMessage('Tweaking Plots')
        
        dom.plots[0].xaxis.drawTickLabels = 0
        dom.plots[0].controller.dasColorBar.setFillColor(background_grey)
        dom.plots[0].setDisplayLegend(True)
        dom.plots[0].setLegendPosition(OutsideNE)
        
        dom.plots[1].xaxis.drawTickLabels = 0
        dom.plots[1].displayTitle = 0
        dom.plots[1].setColortable(APL_RAINBOW_BLACK0)
        dom.plots[1].controller.dasColorBar.setFillColor(background_grey)
        
        dom.plots[2].xaxis.drawTickLabels = 0
        dom.plots[2].displayTitle = 0
        dom.plots[2].setColortable(BLUE_WHITE_RED_WEDGE)
        dom.plots[2].zaxis.setFlipped(True)
        dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
        
        
        dom.plots[3].xaxis.drawTickLabels = 1
        dom.plots[3].displayTitle = 0
        dom.plots[3].setColortable(APL_RAINBOW_BLACK0)
        dom.plots[3].controller.dasColorBar.setFillColor(background_grey)
        
    if( angles_or_ratios == 'ratios' ):
        plotx ( 2 , fft_time , Smag           , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , zlog=1, zrange=[power_min , power_max], ztitle='Poynting Flux!C     (&mu;W/m)' )#, title = 'Polarization parameters for RBSP S/C-'+SC_upper+' - '+start_date+'T'+str(start_hour))
        plotx ( 3 , fft_time , Sn , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='S!B||', zlog=0, zrange=[0,180] )
        plotx ( 4 , fft_time , Sp   , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='S!B&perp;az', zrange=[-180, 180])
        plotx ( 5 , fft_time , Sq   , ytitle='Frequency (Hz)', ylog=logfreq , yrange=[freq_min, freq_max] , ztitle='S!B&perp;rad', zrange=[-180, 180])
        #plotx ( 5 , fft_time , Ellipticity , ylog=logfreq , yrange=[freq_min, freq_max] , zrange=[-1 , 1], ztitle='     Ellipticity!CRH               LH')#, ztitle='              Ellipticity!C!BRight                         Left!C!BHand                       Hand!N' )
        
        monitor.setProgressMessage('Tweaking Plots')
        
        dom.plots[0].xaxis.drawTickLabels = 0
        dom.plots[0].controller.dasColorBar.setFillColor(background_grey)
        dom.plots[0].setDisplayLegend(True)
        dom.plots[0].setLegendPosition(OutsideNE)
        
        dom.plots[1].xaxis.drawTickLabels = 0
        dom.plots[1].displayTitle = 0
        dom.plots[1].setColortable(APL_RAINBOW_BLACK0)
        dom.plots[1].controller.dasColorBar.setFillColor(background_grey)
        
        dom.plots[2].xaxis.drawTickLabels = 0
        dom.plots[2].displayTitle = 0
        dom.plots[2].setColortable(BLUE_WHITE_RED_WEDGE)
        dom.plots[2].zaxis.setFlipped(True)
        dom.plots[2].controller.dasColorBar.setFillColor(background_grey)
        
        
        dom.plots[3].xaxis.drawTickLabels = 1
        dom.plots[3].displayTitle = 0
        dom.plots[3].setColortable(APL_RAINBOW_BLACK0)
        dom.plots[3].controller.dasColorBar.setFillColor(background_grey)
    
#    dom.plots[4].displayTitle = 0
#    dom.plots[4].setColortable(BLUE_WHITE_RED_WEDGE)
#    dom.plots[4].controller.dasColorBar.setFillColor(background_grey)
#    #dom.plots[4].ticksURI = 'vap+das2server:http://emfisis.physics.uiowa.edu/das/das2Server?dataset=rbsp/ephemeris'+SPACECRAFT+'.dsdf&timerange='+str(starttitle)+' through '+str(endtitle)+'&interval=60'
    number_of_plots = len(dom.getPlots())
    try:
        mms_ephemerizer( mms_sc )
    except:
        dom.plots[int(number_of_plots)-1].setTicksURI('file:///D:/Research/MMS/Ephem_Data/%s_ephemeris.txt?depend0=field0&rank2=MLT-Re'%MMS_SC)
    
    waitUntilIdle()
    fixLayout()
    
    for i in xrange(number_of_plots):
        dom.plots[i].controller.dasPlot.row.ptMaximum = 10
    for i in xrange(number_of_plots-1):
        dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[i+1].xaxis, dom.plots[i+1].xaxis.PROP_RANGE )
    for i in xrange(number_of_plots-2):
        dom.controller.bind( dom.plots[i+2].yaxis, dom.plots[i+2].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
    
    
    
    #dom.plots[0].controller.dasPlot.row.ptMaximum = 10 #closes in gaps between windows after "Fix Layout" to be a little more comapact
    #dom.plots[1].controller.dasPlot.row.ptMaximum = 10
    #dom.plots[2].controller.dasPlot.row.ptMaximum = 10
    #dom.plots[3].controller.dasPlot.row.ptMaximum = 10
    #dom.plots[4].controller.dasPlot.row.ptMaximum = 10
    
    #dom.controller.bind( dom.plots[2].yaxis, dom.plots[2].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE ) #adds binding along frequency axis between plots
    #dom.controller.bind( dom.plots[3].yaxis, dom.plots[3].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE )
    #dom.controller.bind( dom.plots[4].yaxis, dom.plots[4].yaxis.PROP_RANGE,  dom.plots[1].yaxis, dom.plots[1].yaxis.PROP_RANGE )
    
    #dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[1].xaxis, dom.plots[1].xaxis.PROP_RANGE ) #adds binding along time axis between plots
    #dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[2].xaxis, dom.plots[2].xaxis.PROP_RANGE )
    #dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[3].xaxis, dom.plots[3].xaxis.PROP_RANGE )
    #dom.controller.bind( dom.plots[0].xaxis, dom.plots[0].xaxis.PROP_RANGE,  dom.plots[4].xaxis, dom.plots[4].xaxis.PROP_RANGE )
    
    monitor.finished()

    
    
# ##################################################################################
# ##################################################################################



# ###
# ### DEFINE INPUT PARAMETERS
# ###        


local_team_data_yn = getParam( 'Team Data?', 'T' , 'Use locally stored data from Team site' , ['T' , 'F'] )

srvy_or_brst = getParam( 'Fluxgate, Survey or Burst Data?' , 'scb_brst' , 'Fluxgate runs up to 8Hz, Survey runs up to 16Hz, while Burst data operates to 8kHz' , [ 'fluxgate' , 'srvy' , 'slow' , 'fast' , 'scb_brst' , 'schb_brst' ] )

MMS_SC = getParam( 'Spacecraft?' , 'MMS1' , 'Run script for which spacecraft?' , [ 'MMS1' , 'MMS2' , 'MMS3' , 'MMS4' ] )
mms_sc = MMS_SC.lower()


if( srvy_or_brst == 'fluxgate' ):
    if( local_team_data_yn == 'F' ):
        #starttime_input = getParam( 'Start Date and Time' , '2015-06-25 11:35' , 'Any format you want, really' )
        #endtime_input = getParam( 'End Date and Time' , '2015-06-25 12:35'  , 'End of wave activity' )
        starttime_input = getParam( 'Start Date and Time' , '2016-05-20 19:00' , 'Any format you want, really' )
        endtime_input = getParam( 'End Date and Time' , '2016-05-20 20:45'  , 'End of wave activity' )
    
        freq_min = getParam( 'Minimum Frequency' , 2. , 'The minimum frequency kept after the fft of the data is taken' )
        freq_max = getParam( 'Maximum Frequency' , 8. , 'The maximum frequency kept after the fft of the data is taken' )
    
        window = getParam('FFT WIndow Size' , 256, 'The number of points in the fft window' , [128,256,512,1024,2048,4096,8192,16384] )
        slide = getParam('Slide' , 8 , 'The reciprocal of the fraction of the window that is not overlapped by the previous fft' , [1,2,4,8,16,32] )
        
        wave_power_min = 3E-4
        power_min = 1E-2
        power_max = 1E2
        poynting_min = wave_power_min
    else:
        starttime_input = getParam( 'Start Date and Time' , '2016-09-13 18:00' , 'Any format you want, really' )
        endtime_input = getParam( 'End Date and Time' , '2016-09-13 19:00'  , 'End of wave activity' )
    
        freq_min = getParam( 'Minimum Frequency' , 0.04 , 'The minimum frequency kept after the fft of the data is taken' )
        freq_max = getParam( 'Maximum Frequency' , 0.11 , 'The maximum frequency kept after the fft of the data is taken' )
    
        window = getParam('FFT WIndow Size' , 8192, 'The number of points in the fft window' , [128,256,512,1024,2048,4096,8192,16384] )
        slide = getParam('Slide' , 4 , 'The reciprocal of the fraction of the window that is not overlapped by the previous fft' , [1,2,4,8,16,32] )
        
        wave_power_min = 1E-1
        power_min = 1E-1
        power_max = 1E2
        poynting_min = wave_power_min

elif( srvy_or_brst == 'srvy' or srvy_or_brst == 'slow' or srvy_or_brst == 'fast' ):
    starttime_input = getParam( 'Start Date and Time' , '2015-08-15 8:45' , 'Any format you want, really' )
    endtime_input = getParam( 'End Date and Time' , '2015-08-15 9:25' , 'End of wave activity' )
    
    freq_min = getParam( 'Minimum Frequency' , 0.4 , 'The minimum frequency kept after the fft of the data is taken' )
    freq_max = getParam( 'Maximum Frequency' , 2.5 , 'The maximum frequency kept after the fft of the data is taken' )
    
    window = getParam('FFT WIndow Size' , 1024 , 'The number of points in the fft window' , [128,256,512,1024,2048,4096,8192,16384] )
    slide = getParam('Slide' , 8 , 'The reciprocal of the fraction of the window that is not overlapped by the previous fft' , [1,2,4,8,16,32] )
    
    wave_power_min = 3
    power_min = wave_power_min
    power_max = 40000
    poynting_min = wave_power_min

elif( srvy_or_brst == 'scb_brst' or srvy_or_brst == 'schb_brst' ):
    if( local_team_data_yn == 'F' ): #'2015-12-06 23:38:20'
        #starttime_input = getParam( 'Start Date and Time' , '2015-09-18 13:16:10' , 'Any format you want, really' )
        #endtime_input = getParam( 'End Date and Time' , '2015-09-18 13:16:40' , 'End of wave activity' )
        starttime_input = getParam( 'Start Date and Time' , '2016-10-17 16:36:29' , 'Any format you want, really' )
        endtime_input = getParam( 'End Date and Time' , '2016-10-17 16:37:12' , 'End of wave activity' )
        
        
        freq_min = getParam( 'Minimum Frequency' , 30 , 'The minimum frequency kept after the fft of the data is taken' )
        freq_max = getParam( 'Maximum Frequency' , 250 , 'The maximum frequency kept after the fft of the data is taken' )
        
        window = getParam('FFT WIndow Size' , 1024 , 'The number of points in the fft window' , [128,256,512,1024,2048,4096,8192,16384] )
        slide = getParam('Slide' , 8 , 'The reciprocal of the fraction of the window that is not overlapped by the previous fft' , [1,2,4,8,16,32] )
        
        wave_power_min = 1.5E-6#9E-7
        power_min = wave_power_min
        power_max = 40000
        poynting_min = wave_power_min
    else:
        starttime_input = getParam( 'Start Date and Time' , '2015-08-04 16:19' , 'Any format you want, really' )
        endtime_input = getParam( 'End Date and Time' , '2015-08-04 16:30' , 'End of wave activity' )
        
        freq_min = getParam( 'Minimum Frequency' , 10 , 'The minimum frequency kept after the fft of the data is taken' )
        freq_max = getParam( 'Maximum Frequency' , 150 , 'The maximum frequency kept after the fft of the data is taken' )
        
        window = getParam('FFT WIndow Size' , 4096 , 'The number of points in the fft window' , [128,256,512,1024,2048,4096,8192,16384] )
        slide = getParam('Slide' , 4 , 'The reciprocal of the fraction of the window that is not overlapped by the previous fft' , [1,2,4,8,16,32] )
        
        wave_power_min = 1.5E-6#9E-7
        power_min = wave_power_min
        power_max = 5E-3
        poynting_min = wave_power_min
        

skipButterworth = getParam( 'Skip Bandpass Filter yes/no', 'F' , 'Whether or not to skip the bandpass filtering portion' , ['T' , 'F'] )

freq_avg = getParam( 'Frequency Averaging Size' , 5 , 'The number of frequency bins averaged to determine relative coherency' , [3,5,7,9,11,13] )

logyn = getParam( 'Logarithmic yes/no', 'T' , 'Whether or not to display the frequency axis in logarithmic scale' , ['T' , 'F'] )

trend_seconds = getParam( 'Length of Field Trend' , 1 , 'The number of seconds to define the background field' )

waveform_autoscale_yn = getParam( 'Autoscale Waveform Panel?', 'T' , 'Whether or not to autoscale the top panel' , ['T' , 'F'] )
if( waveform_autoscale_yn == 'F' ):
    y_max_value = getParam( 'Panel 1 yrange' , 1.5 , 'The absolute max value of the waveform y-axis range' )

if( srvy_or_brst == 'fluxgate' ):
    scm_or_fluxgate = 'fluxgate'
else:
    scm_or_fluxgate = 'scm'

write_file_yn = getParam( 'Write Output File?' , 'F' , 'Do you want to write the polarization data out to a file?' , ['T' , 'F'] )
if( write_file_yn == 'T' ):
    output_file = getParam( 'Output File' , 'C:/Users/Kristoff/Desktop/'+'TEMP_%s_SCM-Poynting.cdf'%mms_sc , 'Output file to be written' )

angles_or_ratios = getParam( 'Angles or ratios?' , 'angles' , 'Plot the angles of the Poynting flux or the ratio of power in each direction?' , ['angles','ratios'] )

valid_max = 1E10
valid_min = -1E10
    
# ###
# ### DEFINE DATASET LOCATIONS
# ###        

http = 'http:/'
https = 'https:/'

mag_file_cdaweb = 'vap+cdaweb:ds=%s_FGM_SRVY_L2'%(mms_sc.upper())
mag_file_unh = http+'/mmsdata.sr.unh.edu/%s/afg/srvy/l2pre/$Y/$m/%s_afg_srvy_l2pre_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
mag_file_unh_backup = http+'/mmsdata.sr.unh.edu/%s/afg/srvy/l2pre/$Y/$m/%s_afg_srvy_l2pre_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
mag_file_lasp = https+'/lasp.colorado.edu/mms/sdc/public/data/%s/fgm/srvy/l2/$Y/12/%s_fgm_srvy_l2_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
epsd_fast_file = http+'/mmsdata.sr.unh.edu/%s/dsp/fast/l2/epsd/$Y/$m/%s_dsp_fast_l2_epsd_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
bpsd_fast_file = http+'/mmsdata.sr.unh.edu/%s/dsp/fast/l2/bpsd/$Y/$m/%s_dsp_fast_l2_bpsd_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)

scm_srvy_file = http+'/mmsdata.sr.unh.edu/%s/scm/srvy/l1a/scsrvy/$Y/$m/%s_scm_srvy_l1a_scsrvy_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
scm_fast_file = http+'/mmsdata.sr.unh.edu/%s/scm/fast/l2/scf/$Y/$m/%s_scm_fast_l2_scf_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
scm_slow_file = http+'/mmsdata.sr.unh.edu/%s/scm/slow/l2/scs/$Y/$m/%s_scm_slow_l2_scs_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
scm_schb_burst_file = http+'/mmsdata.sr.unh.edu/%s/scm/brst/l2/schb/$Y/$m/$d/%s_scm_brst_l2_schb_$Y$m$d$H$(M,span=5)$S_v$(v,sep).cdf'%(mms_sc,mms_sc)
unh_scm_scb_burst_file = http+'/mmsdata.sr.unh.edu/%s/scm/brst/l2/scb/$Y/$m/$d/%s_scm_brst_l2_scb_$Y$m$d$H$(M,span=5)$S_v$(v,sep).cdf'%(mms_sc,mms_sc)
scm_scb_burst_file = https+'/lasp.colorado.edu/mms/sdc/public/data/%s/scm/brst/l2/scb/$Y/$m/$d/%s_scm_brst_l2_scb_$Y$m$d$H$(M,span=5)$S_v$(v,sep).cdf'%(mms_sc,mms_sc)

cdaweb_edp_burst_file = 'vap+cdaweb:ds=%s_EDP_BRST_L2_DCE&id=%s_edp_dce_gse_brst_l2'%(mms_sc.upper(),mms_sc)
cdaweb_mag_ephem_file = 'vap+cdaweb:ds=%s_MEC_SRVY_L2_EPHTS04D'%(mms_sc.upper())

local_cache = 'D:/Software/Autoplot/fscache/https'
scm_scb_burst_local_file = local_cache+'/lasp.colorado.edu/mms/sdc/team/about/browse/%s/scm/brst/l2/scb/$Y/$m/$d/%s_scm_brst_l2_scb_$Y$m$d$H$(M,span=5)$S_v$(v,sep).cdf'%(mms_sc,mms_sc)
mag_local_file = local_cache+'/lasp.colorado.edu/mms/sdc/team/about/browse/%s/afg/srvy/ql/$Y/$m/%s_afg_srvy_ql_$Y$m$d_v$(v,sep).cdf'%(mms_sc,mms_sc)
local_edp_burst_file = local_cache+'/lasp.colorado.edu/mms/sdc/team/about/browse/%s/edp/brst/ql/dce/$Y/$m/$d/%s_edp_brst_ql_dce_$Y$m$d$H$(M,span=10)$S_v$(v,sep).cdf?%s_edp_dce_xyz_dsl'%(mms_sc,mms_sc,mms_sc)
                                
# ###
# ### RUN MAIN ROUTINE
# ###   

monitor.started()            
            
MAIN()            



