

############################################################################


def field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds ):
    """Routine used to define field-aligned coordinate system by smoothing over given magnetic field data.
	
	Parameters:
	    Bx = rank1 X component of magnetic field
		By = rank1 Y component of magnetic field
		Bz = rank1 Z component of magnetic field
		TEMP_Rx = rank1 X component of radial s/c position (in same coord system as B)
		TEMP_Ry = rank1 Y component of radial s/c position (in same coord system as B)
		TEMP_Rz = rank1 Z component of radial s/c position (in same coord system as B)
		trend_seconds = rank0 number of seconds over which to average B to define as background
		
    Returns:
	    (Bn , Bp , Bq) = rank1 collection of Magnetic Field components in field-aligned system.
		(Nx , Ny , Nz) = rank1 collection of Magnetic Field direction components in original coord system.
		(Px , Py , Pz) = rank1 collection of Quasi-Radial direction components in original coord system.
		(Qx , Qy , Qz) = rank1 collection of Quasi-Azimuthal direction components in original coord system.
	
	"""
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_smooth = smooth(Bx,smooth_points)
    By_smooth = smooth(By,smooth_points)
    Bz_smooth = smooth(Bz,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_smooth / Btotal_smooth
    Ny = By_smooth / Btotal_smooth
    Nz = Bz_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    
    ephem_time = TEMP_Rx.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    TEMP_Rx = interpolate( TEMP_Rx, ephem_to_mag_ratio )
    TEMP_Ry = interpolate( TEMP_Ry , ephem_to_mag_ratio )
    TEMP_Rz = interpolate( TEMP_Rz , ephem_to_mag_ratio )
    
    TEMP_Rmag = sqrt(TEMP_Rx**2 + TEMP_Ry**2 + TEMP_Rz**2)
    
    Rx = -(TEMP_Rx/TEMP_Rmag) #Negate R so that NxR is westwards (need this for right-handedness)
    Ry = -(TEMP_Ry/TEMP_Rmag) 
    Rz = -(TEMP_Rz/TEMP_Rmag) 
    
    TEMP_Px = ( Ny * Rz ) - ( Nz * Ry )
    TEMP_Py = ( Nz * Rx ) - ( Nx * Rz )
    TEMP_Pz = ( Nx * Ry ) - ( Ny * Rx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # N x P ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx * Nx) + (By * Ny) + (Bz * Nz)
    Bp = (Bx * Px) + (By * Py) + (Bz * Pz)
    Bq = (Bx * Qx) + (By * Qy) + (Bz * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )
    
    



############################################################################


        
def Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min ):
    """Polarization analysis performed on spectral components based on [Means 1972].
    
    Parameters:
        Bn_fft = rank3 fft of field-aligned magnetic component.
        Bp_fft = rank3 fft of first perpendicular magnetic component.
        Bq_fft = rank3 fft of second perpendicular magnetic component.
        Nx = rank1 X component of magnetic field direction in B_fft coordinate system.
        Ny = rank1 Y component of magnetic field direction in B_fft coordinate system.
        Nz = rank1 Z component of magnetic field direction in B_fft coordinate system.
        wave_power_min = minimum value of wave power at which to keep returned components (all lower values discarded).
    
    Returns:
        Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization"""
         
    ###
    ### RUN POLARIZATION ANALYSIS
    ###
  
    ###
    ### DEFINE J_PRIME (INPUT) MATRIX ELEMENTS
    ###

#    monitor.setTaskProgress(41)
    monitor.setProgressMessage('Defining J-Prime Matrix Components')

    #T = float( window * float(1.0/64.0) )
    #scale = float( 1.0 / T ) * 2

    Jxx_prime = ( (Bp_fft[:,:,0]*Bp_fft[:,:,0]) + (Bp_fft[:,:,1]*Bp_fft[:,:,1]) )
#    monitor.setTaskProgress(42)
    Jyy_prime = ( (Bq_fft[:,:,0]*Bq_fft[:,:,0]) + (Bq_fft[:,:,1]*Bq_fft[:,:,1]) )
#    monitor.setTaskProgress(43)
    Jzz_prime = ( (Bn_fft[:,:,0]*Bn_fft[:,:,0]) + (Bn_fft[:,:,1]*Bn_fft[:,:,1]) )
#    monitor.setTaskProgress(44)

    Jxy_prime_real = ( (Bp_fft[:,:,0]*Bq_fft[:,:,0]) + (Bp_fft[:,:,1]*Bq_fft[:,:,1]) )
#    monitor.setTaskProgress(45)
    Jxy_prime_img = ( (Bq_fft[:,:,0]*Bp_fft[:,:,1]) - (Bp_fft[:,:,0]*Bq_fft[:,:,1]) )
#    monitor.setTaskProgress(46)

    Jxz_prime_real = ( (Bp_fft[:,:,0]*Bn_fft[:,:,0]) + (Bp_fft[:,:,1]*Bn_fft[:,:,1]) )
#    monitor.setTaskProgress(47)
    Jxz_prime_img = ( (Bn_fft[:,:,0]*Bp_fft[:,:,1]) - (Bp_fft[:,:,0]*Bn_fft[:,:,1]) )
#    monitor.setTaskProgress(48)

    Jyz_prime_real = ( (Bn_fft[:,:,0]*Bq_fft[:,:,0]) + (Bn_fft[:,:,1]*Bq_fft[:,:,1]) )
#    monitor.setTaskProgress(49)
    Jyz_prime_img = ( (Bq_fft[:,:,0]*Bn_fft[:,:,1]) - (Bn_fft[:,:,0]*Bq_fft[:,:,1]) )
#    monitor.setTaskProgress(50)

    fft_time = Jxx_prime.property(QDataSet.DEPEND_0)
    frequency_axis = Jxx_prime.property(QDataSet.DEPEND_1)



    ###
    ### DEFINE K-HAT VECTOR (MEANS - IMAGINARY COMPONENTS)
    ###

#    monitor.setTaskProgress(51)
    monitor.setProgressMessage('Finding Wave-Normal Direction (Means)')

    img_mag = sqrt( Jxy_prime_img**2 + Jxz_prime_img**2 + Jyz_prime_img**2 )

    kx = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )
    ky = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )
    kz = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )
    trace = dblarr( len(Jxx_prime[:,1]) , len(Jxx_prime[1,:]) )

    # for j in xrange( len(Jxx_prime[1,:]) ):
          # for i in xrange( len(Jxx_prime[:,1]) ):
                # if ( abs(img_mag[i,j]) < 1E-5 ): # linear polarizations will have zero off-diagonal imaginary components
                      # trace[i,j] = Jxx_prime[i,j] + Jyy_prime[i,j] + Jzz_prime[i,j]
                      # kx[i,j] = sqrt( Jxx_prime[i,j] / trace[i,j] )
                      # ky[i,j] = Jxy_prime_real[i,j] / ( trace[i,j] * Jxx_prime[i,j] )
                      # kz[i,j] = Jxz_prime_real[i,j] / ( trace[i,j] * Jxx_prime[i,j] )
                # else: # for normal elliptical or circular polarizations
                      # trace[i,j] = Jxx_prime[i,j] + Jyy_prime[i,j] + Jzz_prime[i,j]
                      # kx[i,j] = Jyz_prime_img[i,j] / img_mag[i,j]
                      # ky[i,j] = -Jxz_prime_img[i,j] / img_mag[i,j]
                      # kz[i,j] = Jxy_prime_img[i,j] / img_mag[i,j]

    
    trace = Jxx_prime + Jyy_prime + Jzz_prime
    r = where(lt(abs(img_mag) , 1E-5))
    kx[r] = sqrt( Jxx_prime[r] / trace[r] )
    ky[r] = Jxy_prime_real[r] / ( trace[r] * Jxx_prime[r] )
    kz[r] = Jxz_prime_real[r] / ( trace[r] * Jxx_prime[r] )

    r0 = where(ge(abs(img_mag) , 1E-5))
    kx[r0] = Jyz_prime_img[r0] / img_mag[r0]
    ky[r0] = -Jxz_prime_img[r0] / img_mag[r0]
    kz[r0] = Jxy_prime_img[r0] / img_mag[r0]

    trace.putProperty ( QDataSet.DEPEND_0 , fft_time )
    trace.putProperty ( QDataSet.DEPEND_1 , frequency_axis )
    
    del ( img_mag )

    lowering_ratio = findex( Nx.property( QDataSet.DEPEND_0 ) , fft_time )

    Nx_fftcadence = interpolate ( Nx , lowering_ratio )
    Ny_fftcadence = interpolate ( Ny , lowering_ratio )
    Nz_fftcadence = interpolate ( Nz , lowering_ratio )

    Nx_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Ny_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Nz_fftarray = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )

    for j in xrange( len( kx[1,:] ) ): # magnetic field direction is same at all times, so turn vector into an array where DEPEND_1 is constant
          Nx_fftarray[:,j] = Nx_fftcadence
          Ny_fftarray[:,j] = Ny_fftcadence
          Nz_fftarray[:,j] = Nz_fftcadence

    del ( [ Nx_fftcadence , Ny_fftcadence , Nz_fftcadence ] )

    Nx_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
    Nx_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
    Ny_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
    Ny_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
    Nz_fftarray.putProperty(QDataSet.DEPEND_0,fft_time)
    Nz_fftarray.putProperty(QDataSet.DEPEND_1,frequency_axis)
    
    # for j in xrange( len(kx[1,:]) ): #This is necessary because the direction of k is not the same as the direction of the wave-normal, it will depend on |B| (Look up the Means paper if confused, this took a while to understand)
          # for i in xrange( len(kx[:,1]) ):
                # if ( ( (kx[i,j] * Nx_fftarray[i,j]) + (ky[i,j]* Ny_fftarray[i,j]) + (kz[i,j] * Nz_fftarray[i,j]) ) < 0):
                      # kx[i,j] = -kx[i,j]
                      # ky[i,j] = -ky[i,j]
                      # kz[i,j] = -kz[i,j]
    #This is necessary because the direction of k is not the same as the direction of the wave-normal, it will depend on |B| (Look up the Means paper if confused, this took a while to understand)
    r = where(lt( (kx * Nx_fftarray) + (ky* Ny_fftarray) + (kz * Nz_fftarray) , 0 ))
    kx[r] = -kx[r]
    ky[r] = -ky[r]
    kz[r] = -kz[r]
                
    ###
    ### DEFINE WAVE-NORMAL COORDINATES AND ROTATE J-PRIME - DEFINE J MATRIX IN _|_ DIRECTIONS
    ###

#    monitor.setTaskProgress(52)
    monitor.setProgressMessage('Creating Wave-Normal Coordinate System')
     
    theta = acos( kx*Nx_fftarray + ky*Ny_fftarray + kz*Nz_fftarray )
    factor = sin( theta )
#    monitor.setTaskProgress(53)
    
    r = where(gt(theta , (PI/2)))
    theta[r] = PI - theta[r]
    # for j in xrange( len(kx[1,:]) ):
          # for i in xrange( len(kx[:,1]) ):
                # if ( theta[i,j] > (PI/2) ):
                      # theta[i,j] = PI - theta[i,j]

    Rx = ((ky * Nz_fftarray) - (kz * Ny_fftarray)) / factor # R_hat = k_hat x N_hat so is perpendicular to plane of wave normal and magnetic field
    Ry = ((kz * Nx_fftarray) - (kx * Nz_fftarray)) / factor
    Rz = ((kx * Ny_fftarray) - (ky * Nx_fftarray)) / factor
#    monitor.setTaskProgress(70)
    Sx = (Ry * kz) - (Rz * ky)# S_hat = R_hat x k_hat so is in plane of wave normal and magnetic field
    Sy = (Rz * kx) - (Rx * kz)
    Sz = (Rx * ky) - (Ry * kx)
#    monitor.setTaskProgress(71)

    Jxx = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jyy = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jzz = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jxy_real = dblarr( len( kx[:,1] ) , len( kx[1,:] ) )
    Jxy_img = dblarr( len( kx[:,1] ) , len( kx[1,:] ) ) 

#    monitor.setTaskProgress(54)
    monitor.setProgressMessage('Rotating J-Prime into Wave-Normal')

    ###
    ### BELOW ROTATION VECTOR TAKES UNIT VECTORS  AS COLUMNS  - correct, at least on paper I think
    ###

#    Jxx = (Jxx_prime * (Rx**2)) + (Jyy_prime * (Sx**2)) + (Jzz_prime * (kx**2)) + 2*(Jxy_prime_real*Rx*Sx + Jxz_prime_real*Rx*kx + Jyz_prime_real*Sx*kx) # THIS IS WRONG... It fucked up a lot of things and results from taking [J]=[r][J'][r]^-1 instead of [J]=[r]^-1[J'][r] (or vice versa, I can't remember now)
#    Jyy = (Jxx_prime * (Ry**2)) + (Jyy_prime * (Sy**2)) + (Jzz_prime * (ky**2)) + 2*(Jxy_prime_real*Ry*Sy + Jxz_prime_real*Ry*ky + Jyz_prime_real*Sy*ky)
#    Jzz = (Jxx_prime * (Rz**2)) + (Jyy_prime * (Sz**2)) + (Jzz_prime * (kz**2)) + 2*(Jxy_prime_real*Rz*Sz + Jxz_prime_real*Rz*kz + Jyz_prime_real*Sz*kz)

    Jxx = (Jxx_prime * (Rx**2)) + (Jyy_prime * (Ry**2)) + (Jzz_prime * (Rz**2)) + 2*(Jxy_prime_real*Rx*Ry + Jxz_prime_real*Rx*Rz + Jyz_prime_real*Ry*Rz)
    Jyy = (Jxx_prime * (Sx**2)) + (Jyy_prime * (Sy**2)) + (Jzz_prime * (Sz**2)) + 2*(Jxy_prime_real*Sx*Sy + Jxz_prime_real*Sx*Sz + Jyz_prime_real*Sy*Sz)
    Jzz = (Jxx_prime * (kx**2)) + (Jyy_prime * (ky**2)) + (Jzz_prime * (kz**2)) + 2*(Jxy_prime_real*kx*ky + Jxz_prime_real*kx*kz + Jyz_prime_real*ky*kz)

    Jxy_real = Jxx_prime*Rx*Ry + Jyy_prime*Sx*Sy + Jzz_prime*kx*ky + Jxy_prime_real*(Rx*Sy + Sx*Ry) + Jxz_prime_real*(Rx*ky + Ry*kx) + Jyz_prime_real*(ky*Sx + Sy*kx) # These two parts of the rotation are the same no matter what
    Jxy_img = Jxy_prime_img*(Rx*Sy - Sx*Ry) + Jxz_prime_img*(Rx*ky - kx*Ry) + Jyz_prime_img*(ky*Sx - Sy*kx)

    Wave_Power = Jxx + Jyy

    del ( [ factor , kx , ky , kz , Nx , Ny , Nz , Rx , Ry , Rz , Sx , Sy , Sz , Jxy_prime_real , Jxz_prime_real , Jyz_prime_real , Jxy_prime_img , Jxz_prime_img , Jyz_prime_img ] )

    ###
    ### SMOOTHING OVER FREQUENCY BINS (NECESSARY FOR POLARIZATION COMPARISON ANALYSIS)
    ###

#    monitor.setTaskProgress(55)
    monitor.setProgressMessage('Smoothing Across Frequency Bins')

    # TEMP_Jxx = dblarr( len( Jxx[1,:] ) , len( Jxx[:,1] ) )
    # TEMP_Jyy = dblarr( len( Jxx[1,:] ) , len( Jxx[:,1] ) )
    # TEMP_Jzz = dblarr( len( Jxx[1,:] ) , len( Jxx[:,1] ) )
    # TEMP_Jxy_real = dblarr( len( Jxx[1,:] ) , len( Jxx[:,1] ) )
    # TEMP_Jxy_img = dblarr( len( Jxx[1,:] ) , len( Jxx[:,1] ) )
    
    
    if ( len( Jxx[1,:] ) < 5 ):
          freq_avg = 3 #number of frequency bins to average over for polarization, must be odd (is 5 too much? Its is what is in Means paper)
    else:
          freq_avg = 5

    # for i in xrange( len(Jxx[:,1]) ): #This is a pretty dumb way to do it, but I don't think boxcar average across y-axis is a function yet.
          # TEMP_Jxx[:,i] = smooth( transpose( Jxx )[:,i] , freq_avg )
          # TEMP_Jyy[:,i] = smooth( transpose(Jyy)[:,i] , freq_avg )
          # TEMP_Jzz[:,i] = smooth( transpose(Jzz)[:,i] , freq_avg )
          # TEMP_Jxy_real[:,i] = smooth( transpose(Jxy_real)[:,i] , freq_avg )
          # TEMP_Jxy_img[:,i] = smooth( transpose(Jxy_img)[:,i] , freq_avg )

# #    monitor.setTaskProgress(56)

    # Jxx = transpose( TEMP_Jxx )
    # Jyy = transpose( TEMP_Jyy )
    # Jzz = transpose( TEMP_Jzz )
    # Jxy_real = transpose( TEMP_Jxy_real )
    # Jxy_img = transpose( TEMP_Jxy_img )
    
    # del ( [ TEMP_Jxx , TEMP_Jyy , TEMP_Jzz , TEMP_Jxy_real , TEMP_Jxy_img ] )
    
    Jxx      = smooth1(Jxx     ,freq_avg)
    Jyy      = smooth1(Jyy     ,freq_avg)
    Jzz      = smooth1(Jzz     ,freq_avg)
    Jxy_real = smooth1(Jxy_real,freq_avg)
    Jxy_img  = smooth1(Jxy_img ,freq_avg)
    
    putProps( [ Jxx, Jyy, Jzz, Jxy_real, Jxy_img, theta  ], QDataSet.DEPEND_0, fft_time )
    putProps( [ Jxx, Jyy, Jzz, Jxy_real, Jxy_img, theta  ], QDataSet.DEPEND_1, frequency_axis )

    
    J_det =  ( Jxx*Jyy - (Jxy_real*Jxy_real + Jxy_img*Jxy_img) )

    ###
    ### POWER IN MAGNETIC FIELD DIRECTIONS
    ###

    #monitor.setTaskProgress(75)
    #monitor.setProgressMessage('Defining Wave Intensity')

    Power_compressional = Jzz_prime
    Power_perp = sqrt(Jxx**2 + Jyy**2) 
    #Power_transverse = Jxx_prime + Jyy_prime # upon recommendation from Chuck, this is the wave intensity rather than magnitude of diagonal elements
                


    ###
    ### DEFINE POLARIZATION PARAMETERS USING J MATRIX
    ###
          
    #monitor.setTaskProgress(76)
    #monitor.setProgressMessage('Calculating Degree of Polarization')
    Deg_Polarization = sqrt ( 1 - ( (4 * J_det) / ( (Jxx + Jyy)**2 ) ) )
    Deg_Polarization.putProperty ( QDataSet.VALID_MIN , 0 )

    #monitor.setTaskProgress(77)
    #monitor.setProgressMessage('Calculating Coherency')
    Coherency = sqrt( (Jxy_real*Jxy_real + Jxy_img*Jxy_img) / (Jxx * Jyy) )
    Coherency.putProperty ( QDataSet.VALID_MIN , 0 )

    #Angle_Polarization = toDegrees( 0.5 * atan((2 * Jxx) / (Jxx - Jyy)) ) # sure Jxx isn't supposed to be Jxy_real?

#    monitor.setTaskProgress(57)
    monitor.setProgressMessage('Calculating Ellipticity and Handedness')
    Handedness = ( (1 * (2 * Jxy_img) / sqrt( (Jxx + Jyy)**2 - (4 * J_det) ) ))
    Ellipticity = ( tan ( 0.5 * asin( Handedness ) ))
    Ellipticity.putProperty ( QDataSet.VALID_MIN , -1 )

#    monitor.setTaskProgress(58)
    monitor.setProgressMessage('Definining Wave-Normal angle relative to |B|')
    Angle_Normal = toDegrees( theta )
    Angle_Normal.putProperty ( QDataSet.VALID_MIN , 0 )
    
    
    del ( [ Jxx , Jyy , Jzz , Jxy_real , Jxy_img , theta ] )


    ###
    ### ONLY KEEPING TERMS WITH WAVE POWER ASSOCIATED
    ###
    
#    monitor.setTaskProgress(59)
    monitor.setProgressMessage('Throwing out Values of Low Wave Power')
    if ( wave_power_min > 0 ): # this executes a step function zero-ing out spectra where there are no waves (to make it easier to see what is happening) 
        r = where(lt(Wave_Power,wave_power_min))
        Angle_Normal[r] = -1
        Ellipticity[r]  = -2
        Coherency[r]    = -1

    
    ###
    ### SPIT OUT RESULTS
    ###
    
    return ( Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization ) 




# ############################################################################################

def Hanningfft( ds , freq_min , freq_max , window , slide ):
    """FFT routine employing sliding Hanning window function while preserving both real and imaginary components. 
    
    Parameters:
        ds = The rank1 time-series input data.
        freq_min = Lower end of frequency range to be preserved (excess thrown out to speed up subsequent processing).
        freq_max = Upper end of frequency range.
        window = Length of window to be taken measured in number of data points.
        slide = Window overlap size, expressed as a fraction of the length (1 for no slide, 2 for half steps, 4 for quarters)
        
    Returns:
        waveform_fft = The rank3 fft result of both real and imaginary components trimmed to frequency range."""
    
    ds_time = ds.property(QDataSet.DEPEND_0)
    
    ds_cadence = convertUnitsTo((ds_time[1]-ds_time[0]),Units.seconds)
    per_sec = int(1./ds_cadence)
    
    processed_ds = hanning(ds,window)

    for i in xrange( slide ):
        try:
            processed_ds = trim_it_merge_it(ds,ds_time,processed_ds,window,window*(i+1)/slide)
        except( java.lang.ArrayIndexOutOfBoundsException ):
            pass

    TEMP_waveform_fft = dblarr( len(processed_ds[:,0]) , len(processed_ds[0,:]) , 2 )

    for i in xrange( len(processed_ds[:,0]) ):
        processed_ds_fft = 2 * fft( processed_ds[i,:] )
        TEMP_waveform_fft[i,:,:] = processed_ds_fft * sqrt(float(window)/per_sec) / 1.725

    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_0 , processed_ds.property(QDataSet.DEPEND_0) )
    TEMP_waveform_fft.putProperty( QDataSet.DEPEND_1 , processed_ds_fft[:,0].property(QDataSet.DEPEND_0)*per_sec )
    TEMP_waveform_fft.property(QDataSet.DEPEND_1).putProperty( QDataSet.UNITS , Units.hertz )

    frequency_range = where( TEMP_waveform_fft.property(QDataSet.DEPEND_1).ge(freq_min).and(TEMP_waveform_fft.property(QDataSet.DEPEND_1).le(freq_max)) )
    waveform_fft = TEMP_waveform_fft[:,frequency_range,:]
    waveform_fft.putProperty( QDataSet.DEPEND_1 , TEMP_waveform_fft.property(QDataSet.DEPEND_1)[frequency_range] )
    del ( TEMP_waveform_fft )
    
    uniqueness = uniq( waveform_fft.property(QDataSet.DEPEND_0) )
    waveform_fft_time = waveform_fft.property(QDataSet.DEPEND_0)[uniqueness]
    waveform_fft = waveform_fft[uniqueness,:,:]
    waveform_fft.putProperty( QDataSet.DEPEND_0 , waveform_fft_time )
    
    return ( waveform_fft )
        

# ############################################################################################

###
### USED IN CONJUNCTION WITH Hanningfft TO CREATE SLIDING WINDOW FUNCTION
###

def trim_it_merge_it(ds,ds_time,processed_ds,window,leading_points):
    
    
    ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    
    trimmed_ds = trim(ds,int(leading_points),int(len(ds)))
    trimmed_ds.putProperty( QDataSet.DEPEND_0 , trim(ds_time,int(leading_points),int(len(ds))) )
    
    processed_ds_too = hanning( trimmed_ds , window )
    processed_ds_too.putProperty( QDataSet.DEPEND_1 , ds.property(QDataSet.DEPEND_1) )
    
    processed_ds_time = processed_ds.property( QDataSet.DEPEND_0 )
    processed_ds_time.putProperty( QDataSet.CADENCE , dataset('0s') )
    processed_ds.putProperty( QDataSet.DEPEND_0 , processed_ds_time )
    
    result = merge( processed_ds , processed_ds_too )
    return( result )


# ############################################################################################



############################################################################

############################################################################

############################################################################
tr                = '2018-11-03 19:10 to 19:20'

freq_min          = 1.
freq_max          = 8.
window            = 4096
slide             = 4

wave_power_min    = 1E-3

trend_seconds     = 10



mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
mag = trim(mag,tr)

mag_time = mag.property(QDataSet.DEPEND_0)

pos = getDataSet('http://sweap.cfa.harvard.edu/data/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
pos_time = pos.property(QDataSet.DEPEND_0)

Bx = mag[:,0]
By = mag[:,1]
Bz = mag[:,2]
Btotal = magnitude(mag)

TEMP_Rx = pos[:,0]
TEMP_Ry = pos[:,1]
TEMP_Rz = pos[:,2]

TEMP_Rx = ones(len(pos))
TEMP_Ry = zeros(len(pos))
TEMP_Rz = zeros(len(pos))
TEMP_Rx.putProperty(QDataSet.DEPEND_0,pos_time)
TEMP_Ry.putProperty(QDataSet.DEPEND_0,pos_time)
TEMP_Rz.putProperty(QDataSet.DEPEND_0,pos_time)



( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )

#B_xyz = bundle(Bx,By,Bz)
#B_npq = bundle(Bn,Bp,Bq)
#
#B_xyz.putProperty(QDataSet.DEPEND_0,mag_time)
#B_npq.putProperty(QDataSet.DEPEND_0,mag_time)
#
#
#plot(0,B_xyz,renderType='series')
#plot(1,B_npq)
#plot(2,Bn)


Bn_fft = Hanningfft( Bn , freq_min , freq_max , window , slide )
Bp_fft = Hanningfft( Bp , freq_min , freq_max , window , slide )
Bq_fft = Hanningfft( Bq , freq_min , freq_max , window , slide )




( Handedness , Ellipticity , Angle_Normal , Deg_Polarization , Coherency , Angle_polarization ) = Polarize( Bn_fft , Bp_fft , Bq_fft , Nx , Ny , Nz , wave_power_min )



plot(2,Ellipticity)



