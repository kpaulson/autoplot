
############################################################################
##################            VARIABLES          ###########################
############################################################################
############################################################################


#timerange = getParam('timerange','2018-11-01 06:00 to 08:00','Iteration Timerange')
timerange = getParam('timerange','2018-11-01 06:00 to 07:20','Iteration Timerange')
#timerange = getParam('timerange','2019-04-04 01:22 to 01:23','Iteration Timerange') #Why no Chi?
#timerange = getParam('timerange','2018-11-04 5:00 to 5:10','Iteration Timerange')
version = getParam('version','0.4.3','Version number to be appended to filenames')

separatePeaksWithL3Values = True
writeStuff = False
useVDFFluxForWeights = True
conflateAndDownsampleSpectra = True
analyzingTimeWidthComparisons = False



m_p                  = 1.6726231E-24
q                    = 1.6022E-12
#trend_seconds        = 30     # Number of seconds over which to average magField to determine background field direction
trend_seconds        = getParam('Bfield_window' , 30 , 'Number of seconds over which to average magField to determine background field direction' )
#minFluxValueForFit   = 0.5    # Throw out/Don't fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])
minFluxValueForFit   = getParam('Minimum_VDF' , 0.5 , 'Throw out/Don\'t fit data points where totalFlux is below this value (for normalized data, so choose [0,...,1])' )
#fitSeconds           = 5     # Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)
fitSeconds           = getParam('fit_window' , 8 , 'Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)')
modFits              = getParam('mod_number' , 500 , 'Number of fits performed before updating plot/time reporting')
#smoothPoints         = getParam('smoothPoints' , 5 , 'Number of spectra to average together before defining flow directions')
smoothSeconds = fitSeconds

angleBinWdith        = getParam('angleBinWidth' , 4 , 'Width of bins in degrees making up incident field angle axis of uncertainty map')
anisotropyBinNumber  = getParam('anisotropyBinNumber' , 30 , 'Number of bins making up anisotropy axis of uncertainty map')

cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/sweap/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'


plotFitsAndPauseALot_yn = getParam('FitPlots','F', 'Run the script while pausing and plotting each fit for test purposes?',['T','F'])

############################################################################
##################            IMPORTS            ###########################
############################################################################
############################################################################
    

import sys
try:

    ### IMPORT SUBPROCESSES
    field_aligner = getFile( 'https://github.com/kpaulson/autoplot/blob/master/CoreSubprocesses/Field_Aligner.jy',monitor.getSubtaskMonitor('import field_aligner()'))
    execfile( field_aligner.toString() )

    get_OS_version = getFile( 'https://github.com/kpaulson/autoplot/blob/master/CoreSubprocesses/get_os_version.jy',monitor.getSubtaskMonitor('import get_os_version()'))
    execfile( get_OS_version.toString() )

    getSPCAnisotropyUncertaintyMaps = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSPSubProcesses/getSPCAnisotropyUncertaintyMaps.jy',monitor.getSubtaskMonitor('import getSPCAnisotropyUncertaintyMaps()'))
    execfile( getSPCAnisotropyUncertaintyMaps.toString() )

    smoothSPCByVoltage = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSPSubProcesses/smoothSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothSPCByVoltage()'))
    execfile( smoothSPCByVoltage.toString() )

    smoothAndDownsampleSPCByVoltage = getFile( 'https://github.com/kpaulson/autoplot/blob/master/PSPSubProcesses/smoothAndDownsampleSPCByVoltage.jy',monitor.getSubtaskMonitor('import smoothAndDownsampleSPCByVoltage()'))
    execfile( smoothAndDownsampleSPCByVoltage.toString() )
    
except:
    print 'Unable to grab subprocess from github'
    

        
from org.apache.commons.math.optimization.fitting import CurveFitter
from org.apache.commons.math.optimization.fitting import ParametricRealFunction
from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer
from org.apache.commons.math.stat.regression      import SimpleRegression

OS = get_os_version().split()[0]
if OS == 'mac':
    googleDrive_path = 'file:///Volumes/Macintosh HD/Volumes/GoogleDrive/My Drive/'
elif OS == 'windows':
    googleDrive_path = '/Users/kpaulson/GoogleDrive/'

addToSearchPath(sys.path,googleDrive_path+'Software/Autoplot/jar/commons-math3-3.6.1.jar',monitor)

from org.apache.commons.math3.fitting import AbstractCurveFitter
from org.apache.commons.math3.fitting import SimpleCurveFitter
from org.apache.commons.math3.fitting.leastsquares import LevenbergMarquardtOptimizer as LMO
from org.apache.commons.math3.fitting.leastsquares import GaussNewtonOptimizer
from org.apache.commons.math3.analysis import ParametricUnivariateFunction

class LinFit(ParametricRealFunction):
#class LinFit(ParametricUnivariateFunction):
    def value(self, x, params):
        a = params[0]
        b = params[1]
        return (a*x + b)
    def gradient(self, x, params):
        a = params[0]
        b = params[1]
        return [x,1]

#f = LinFit()
#print f
#
#ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
#print ftr_chi
#ftr_chi = SimpleCurveFitter.create(f, [float(rand(1)[0]),float(rand(1)[0])] )
#
#for i in xrange(10):
#    ftr_chi.getProblem( float(rand(1)[0]),float(rand(1)[0]) )
#
#ftr_chi.fit()
#
#stop

############################################################################
##################            DEFINITIONS        ###########################
############################################################################
############################################################################
    
    
if analyzingTimeWidthComparisons == True:
    output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/TEMP/L0/v%s/'%(version)
elif analyzingTimeWidthComparisons == False:
    output_folder = googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
    
#output_folder = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_Files/TEMP/'
#output_folder = 'D:/Research/ParkerProbe/SWEAP/SPC/Anisotropy/Anisotropy_Files/L0/v%s/'%(version)
        
if plotFitsAndPauseALot_yn == 'T':
    plotFitsAndPauseALot = True
elif plotFitsAndPauseALot_yn == 'F':
    plotFitsAndPauseALot = False
    
    
############################################################################
#################            BEGIN SCRIPT        ###########################
############################################################################
############################################################################

import java
time_begin = TimeUtil.now()    

    
        
# Set up error/uncertainty maps
(anisotropy_deltaPlus,anisotropy_deltaMinus) = getSPCAnisotropyUncertaintyMaps(angleBinWdith,anisotropyBinNumber,OS)
   
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
anisotropy_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)


# Split analysis by day
monitor.started()
trs= generateTimeRanges('$Y-$m-$d',timerange)
for tr in trs:
    time_begin_tr = TimeUtil.now()     
    
    if lt(datumRange(timerange).width(), datumRange(tr).width()):
        tr = timerange
        
    try:
        monitor.setLabel('Downloading SPC') 
        
        monitor.setProgressMessage(tr)
        
        try:
            print cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)'
            spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
            spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
            spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
            spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)
            
            mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
            mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)
        except:
            noSPCData = None
            raise java.io.FileNotFoundException
        
            
        print 'Downloading SPC L2 data took:',TimeUtil.now()-time_begin_tr
        time_last = TimeUtil.now()
        #spc_list = [spc_a,spc_b,spc_c,spc_d]
        
        spc_a = trim(spc_a,tr)
        spc_b = trim(spc_b,tr)
        spc_c = trim(spc_c,tr)
        spc_d = trim(spc_d,tr)
        
        mv_lo = trim(mv_lo,tr)
        mv_hi = trim(mv_hi,tr)
        
        if conflateAndDownsampleSpectra == True:
            monitor.setLabel('Downsampling') 
            
            spc_a = smoothAndDownsampleSPCByVoltage(spc_a,mv_lo,smoothSeconds/3.)
            spc_b = smoothAndDownsampleSPCByVoltage(spc_b,mv_lo,smoothSeconds/3.)
            spc_c = smoothAndDownsampleSPCByVoltage(spc_c,mv_lo,smoothSeconds/3.)
            spc_d = smoothAndDownsampleSPCByVoltage(spc_d,mv_lo,smoothSeconds/3.)
            
            mv_lo = spc_a.property(QDataSet.DEPEND_1)
            mv_hi = synchronize(mv_lo,mv_hi)
            
        
        print 'Smoothing and downsampling data took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        monitor.setLabel('Flow Angles') 
        spc_list = [spc_a,spc_b,spc_c,spc_d]
        del(spc_a,spc_b,spc_c,spc_d)
        
        totalFlux = sum(spc_list)
        
        fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
        fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])
        
        U = (fluxDifference_scy/totalFlux)/0.035
        V = (fluxDifference_scx/totalFlux)/0.035
        
        U.putProperty(QDataSet.VALID_MIN,None)
        V.putProperty(QDataSet.VALID_MIN,None)
        U.putProperty(QDataSet.VALID_MAX,None)
        V.putProperty(QDataSet.VALID_MAX,None)
        

        # This part is in there to match Mike's measurement of Bulk Flow Directions, 
        # but we should pull it out for our fitting, right? - Yes, right now it filters over index for rank2 instead of DEPEND_1 so you get bad results
#        for j in xrange(len(U[0,:])):
#            try:
#                U[:,j] = medianFilter(U[:,j],3)
#            except:
#                continue
#            try:
#                V[:,j] = medianFilter(V[:,j],3)
#            except:
#                continue
        
        U.putProperty(QDataSet.UNITS,Units.degrees)
        V.putProperty(QDataSet.UNITS,Units.degrees)
        
        
        
        #Are you measuring the slope near the peak in current or near the peak in the velocity distribution function? 
        #(the VDF goes like current divided by speed time window width in speed units)
        
        print 'Calculating Flow Angles took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        
        monitor.setLabel('Defining VDF')
        vdfList = list() 
        v_z = sqrt( (2./m_p) * q*(mv_lo + (mv_hi-mv_lo)/2.) ) / 1.E5   # in km/s
        windowWidths = sqrt( (2./m_p) * q*(mv_hi-mv_lo)/2.) / 1.E5
        vdf_full = totalFlux/(v_z*windowWidths)*1.66667E3 #This factor seems arbitrary, but is necessary to line up with Mike's L3 values.
        vdf_full.putProperty(QDataSet.DEPEND_1,v_z)
        vdfList.append('vdf_full')
        del(windowWidths,mv_hi)
        
        # This step is meant to be a further step in removing full scans, but is probably not set properly
#        if manuallyRemoveFullScans == True:
#            for i in xrange(len(v_z)):
#                if gt(v_z[i,max(where(valid(v_z[i,:])))] - v_z[i,min(where(valid(v_z[i,:])))],500):
#                    vdf[i,:] = -1E38
        
        totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
        #peaks = reduceMax(totalFlux,1)
        #r = where(eq(totalFlux,peaks))
        peaks = reduceMax(vdf_full,1)
        r = where(eq(vdf_full,peaks))
        
        print 'Defining VDF took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        # If we want to use the peaks as weights in fitting, import L3 data and build model distributions
        if separatePeaksWithL3Values == True:
            sweap_spc_file = 'http://sweap.cfa.harvard.edu/data/sci/sweap/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf'
            
            DQF = getDataSet(sweap_spc_file+'?DQF',tr)
            goodFlags = where(eq(DQF[:,0],0))

            np_fit = getDataSet(sweap_spc_file+'?np_fit',tr)[goodFlags]
            wp_fit = getDataSet(sweap_spc_file+'?wp_fit',tr)[goodFlags]
            vp_fit_SC = getDataSet(sweap_spc_file+'?vp_fit_SC',tr)[goodFlags]
            vp_fit = magnitude(vp_fit_SC)
            spc_time = np_fit.property(QDataSet.DEPEND_0)
            
            np1_fit = getDataSet(sweap_spc_file+'?np1_fit',tr)[goodFlags]
            wp1_fit = getDataSet(sweap_spc_file+'?wp1_fit',tr)[goodFlags]
            vp1_fit_SC = getDataSet(sweap_spc_file+'?vp1_fit_SC',tr)[goodFlags]
            vp1_fit = magnitude(vp1_fit_SC)
            
            n3_fit = getDataSet(sweap_spc_file+'?n3_fit',tr)[goodFlags]
            w3_fit = getDataSet(sweap_spc_file+'?w3_fit',tr)[goodFlags]
            v3_fit_SC = getDataSet(sweap_spc_file+'?v3_fit_SC',tr)[goodFlags]
            v3_fit = magnitude(v3_fit_SC)
            
            na_fit = getDataSet(sweap_spc_file+'?na_fit',tr)[goodFlags]
            wa_fit = getDataSet(sweap_spc_file+'?wa_fit',tr)[goodFlags]
            va_fit_SC = getDataSet(sweap_spc_file+'?va_fit_SC',tr)[goodFlags]
            va_fit = magnitude(va_fit_SC)
            
            # Define Gaussian parameters
            cp = wp_fit            
            ap = np_fit / (cp*sqrt(PI))         
            bp = vp_fit
            
            cp1 = wp1_fit     
            ap1 = np1_fit / (cp1*sqrt(PI))                
            bp1 = vp1_fit
            
            c3 = w3_fit     
            a3 = n3_fit / (c3*sqrt(PI))                
            b3 = v3_fit
            
            ca = wa_fit    
            aa = (na_fit/2.) / (ca*sqrt(PI))                 
            ba = va_fit * sqrt(2.)
            
            (ap,bp,cp) = synchronize(v_z,[ap,bp,cp])
            (ap1,bp1,cp1) = synchronize(v_z,[ap1,bp1,cp1])
            (a3,b3,c3) = synchronize(v_z,[a3,b3,c3])
            (aa,ba,ca) = synchronize(v_z,[aa,ba,ca])
            
            
            v_space = copy(v_z)
            v_space_time = v_space.property(QDataSet.DEPEND_0)
            vdf_p  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_p1 = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_3  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            vdf_a  = dblarr(len(v_z[:,0]),len(v_z[0,:]))
            v_index = 0
            for v_index in xrange(len(v_space[0,:])):
                
                #peak_p[:,v_index]  = ap*exp(-((v_space[:,v_index] - bp)**2 / (2*cp**2)))
                #peak_p1[:,v_index] = ap1*exp(-((v_space[:,v_index] - bp1)**2 / (2*cp1**2)))
                #peak_a[:,v_index]  = aa*exp(-((v_space_a[:,v_index] - ba)**2 / (2*ca**2)))
                
                vdf_p[:,v_index]  = ap *exp(-((v_space[:,v_index]   - bp )**2 / (cp**2)))
                vdf_p1[:,v_index] = ap1*exp(-((v_space[:,v_index]   - bp1)**2 / (cp1**2)))
                vdf_3[:,v_index]  = a3 *exp(-((v_space[:,v_index]   - b3 )**2 / (c3**2)))
                vdf_a[:,v_index]  = aa *exp(-((v_space[:,v_index]   - ba )**2 / (ca**2)))
                #v_index+=1
            
            vdf_p.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_p.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_p.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_p.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_p1.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_p1.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_p1.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_p1.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_3.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_3.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_3.putProperty(QDataSet.VALID_MIN,1E-10)
            vdf_3.putProperty(QDataSet.VALID_MAX,1E10)
            
            vdf_a.putProperty(QDataSet.DEPEND_0,v_space_time)
            vdf_a.putProperty(QDataSet.DEPEND_1,v_space)
            vdf_a.putProperty(QDataSet.VALID_MIN,0)
            vdf_a.putProperty(QDataSet.VALID_MAX,1E20)
            
            plot(0,vdf_p1)
            plot(1,vdf_3)
            plot(2,vdf_a)
            
            vdfList.append('vdf_p1')
            vdfList.append('vdf_3')
            vdfList.append('vdf_a')
            #stop
            
            print 'Building Peaks took:',TimeUtil.now()-time_last
            time_last = TimeUtil.now()
        
        
        vz_tanTheta = v_z * tan(toRadians(V))     # Vx
        vz_tanPhi   = v_z * tan(toRadians(U))     # Vy
        #plot(vz_tanPhi)
        #stop
        
        # Define background flow to avoid weird slope values?
        u_x = vz_tanTheta[r]
        u_y = vz_tanPhi[r]
        u_z = v_z[r]
        
        if 'alreadyPlottedOnce' not in globals():
            #setLayoutOverplot(4) 
            load(googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/anisotropyFromMath_DayOverviewPlotter.vap')
        
        #plot(0,totalFlux)
        plot(0,vdf_full,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle='VDF (cm!U-3!N km!U-1!N s)',zlog=True)
        plot(1,v_z[r])
        alreadyPlottedOnce = True
        #stop
        #plot(0,vz_tanTheta-synchronize(vz_tanTheta,u_x))
        
        #####
        ##########
        #################
        try:
            mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/sweap/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
            mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
            print 'Used mag data from:',mag_datafile
        except:
            mag_datafile = googleDrive_path+'Research/Data/AutoplotCache/http/w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
            print 'Used mag data from:',mag_datafile
            mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
        
        #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
        mag = trim(mag,tr)
        
        mag_time = mag.property(QDataSet.DEPEND_0)
        
        pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/sweap/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
        pos_time = pos.property(QDataSet.DEPEND_0)
        
        Bx = mag[:,0]
        By = mag[:,1]
        Bz = mag[:,2]
        Btotal = magnitude(mag)
        
        # These inputs are arbitrary since we don't really care what the B_perp directions are for now. Does not affect outcome
        TEMP_Rx = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Ry = putProperty(ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        TEMP_Rz = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
        
        
        ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
        
        (Nx_temp,Ny_temp,Nz_temp) = synchronize(totalFlux,[Nx,Ny,Nz])
        #################
        ##########
        #####
        
        print 'Downloading MAG Data took:',TimeUtil.now()-time_last
        time_last = TimeUtil.now()
        
        if True:
        #for vdf in vdfList:
#            if vdf == 'vdf_full':
#                vdf = vdf_full
#                vdf_label = 'VDF!BTot.!N (cm!U-3!N km!U-1!N s)'
#            elif vdf == 'vdf_p1':
#                vdf = vdf_p1
#                vdf_label = 'VDF!BCore!N (cm!U-3!N km!U-1!N s)'
#            elif vdf == 'vdf_3':
#                vdf = vdf_3
#                vdf_label = 'VDF!BBeam!N (cm!U-3!N km!U-1!N s)'
#            elif vdf == 'vdf_a':
#                vdf = vdf_a
#                vdf_label = 'VDF!BAlpha!N (cm!U-3!N km!U-1!N s)'
#            plot(0,vdf,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle=vdf_label,zlog=True)
            
            # Now time for the real work
            inputGuessParams = [float(rand(1)[0]),float(rand(1)[0])]            
            chiline                = None
            psiline                = None
            epsilonEpoch           = None
            chiSquaredReduced_chi  = None
            chiSquaredReduced_psi  = None
            rSquared_chi           = None
            rSquared_psi           = None
            slopeError_chi         = None
            slopeError_psi         = None
            TEMP_anisotropy_chi    = None
            TEMP_anisotropy_psi    = None
            if separatePeaksWithL3Values == True:          
                chiline_p1                = None
                psiline_p1                = None
                epsilonEpoch_p1           = None
                chiSquaredReduced_p1_chi  = None
                chiSquaredReduced_p1_psi  = None
                rSquared_p1_chi           = None
                rSquared_p1_psi           = None
                slopeError_p1_chi         = None
                slopeError_p1_psi         = None          
                chiline_a                = None
                psiline_a                = None
                epsilonEpoch_a           = None
                chiSquaredReduced_a_chi  = None
                chiSquaredReduced_a_psi  = None
                rSquared_a_chi           = None
                rSquared_a_psi           = None
                slopeError_a_chi         = None
                slopeError_a_psi         = None       
                chiline_3                = None
                psiline_3                = None
                epsilonEpoch_3           = None
                chiSquaredReduced_3_chi  = None
                chiSquaredReduced_3_psi  = None
                rSquared_3_chi           = None
                rSquared_3_psi           = None
                slopeError_3_chi         = None
                slopeError_3_psi         = None
            
            if ge(fitSeconds,1.):
                dds= generateTimeRanges('$Y-$m-$d $H:$M:$(S,span=%s)'%(fitSeconds),tr)
                dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$(S,span=%s)'%(fitSeconds),tr)
            elif lt(fitSeconds,1.):
                dds= generateTimeRanges('$Y-$m-$d $H:$M:$S.$(milli,span=%s)'%int(fitSeconds*1E3),tr)
                dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$S.$(milli,span=%s)'%int(fitSeconds*1E3),tr)
            
            time_fit_begin = TimeUtil.now()
            monitor.setTaskSize(len(dds))
            for ind in xrange(len(dds)):
                monitor.setTaskProgress(ind)
                monitor.setLabel('Linear Fits') 
                
                
                if ( monitor.cancelled ):
                    print 'Canceling Process at (%s %s)'%(str(int(100.*ind/(len(dds)-1.))),'%')
                    break
                
                #try:
                #    print '----'
                if True:
                    tr_dds = dds[ind]+' to '+str( datum(dds[ind])+datum('%s s'%fitSeconds) )
                    #print tr_dds
                    
                    # Manual way to Create Event
    #                event = dblarr(1,4)
    #                event[0,0] = dataset(datumRange(tr_dds).min())
    #                event[0,1] = dataset(datumRange(tr_dds).max())
    #                event[0,2] = dataset(0x666600FF)
    #                event[0,3] = dataset('event')
    
                    # Correct way to Create Event
                    event = createEvent( None, datumRange(tr_dds), 0x666600FF, 'Selected Spectrum' )
                    
                    if mod(ind,modFits) == 0:
                        plot(3, event , renderType='eventsBar')
                    
                    v_z_dd = trim(v_z,tr_dds)
                    vz_tanPhi_dd = trim(vz_tanPhi,tr_dds)
                    vz_tanTheta_dd = trim(vz_tanTheta,tr_dds)
                    
                    u_x_dd = trim(u_x,tr_dds)
                    u_y_dd = trim(u_y,tr_dds)
                    u_z_dd = trim(u_z,tr_dds)
                    
                    totalFlux_dd = trim(totalFlux,tr_dds)
                    vdf_dd = trim(vdf_full,tr_dds)
                    
                    
                    Nx_temp_dd = trim(Nx_temp,tr_dds)
                    Ny_temp_dd = trim(Ny_temp,tr_dds)
                    Nz_temp_dd = mean(trim(Nz_temp,tr_dds))
                    
                    temp_v_z = None
                    temp_vz_tanTheta = None
                    temp_vz_tanPhi = None
                    temp_totalFlux = None
                    temp_vdf = None
                    temp_Nx_temp_dd = None
                    temp_Ny_temp_dd = None
                    for i in xrange(len(v_z_dd)):
                        #temp_v_z         = concatenate(temp_v_z,v_z_dd[i,:])
                        #temp_vz_tanTheta = concatenate(temp_vz_tanTheta,vz_tanTheta_dd[i,:])  # Vx
                        #temp_vz_tanPhi   = concatenate(temp_vz_tanPhi,vz_tanPhi_dd[i,:])      # Vy
                        temp_v_z         = concatenate(temp_v_z,v_z_dd[i,:]-u_z[i])
                        temp_vz_tanTheta = concatenate(temp_vz_tanTheta,vz_tanTheta_dd[i,:]-u_x[i])  # Vx
                        temp_vz_tanPhi   = concatenate(temp_vz_tanPhi,vz_tanPhi_dd[i,:]-u_y[i])      # Vy
                        temp_totalFlux   = concatenate(temp_totalFlux,totalFlux_dd[i,:])
                        temp_vdf         = concatenate(temp_vdf,vdf_dd[i,:])
                        temp_Nx_temp_dd  = concatenate(temp_Nx_temp_dd,ones(len(v_z_dd[i,:]))*Nx_temp_dd[i])
                        temp_Ny_temp_dd  = concatenate(temp_Ny_temp_dd,ones(len(v_z_dd[i,:]))*Ny_temp_dd[i])
                    
                    ###################
                    ###################
                    ###################
                    
                    
                    ###################
                    ###################
                    ###################
                    
                    #if mod(ind,modFits) == 0:    
                    #    print 'Rewriting each fitting parameter into rank1 array took:',TimeUtil.now()-time_last
                    #    time_last = TimeUtil.now()
                        
                    norm_temp_totalFlux = normalize(temp_totalFlux)
                    norm_temp_vdf = normalize(temp_vdf)
                    r = where(ge(temp_vdf,minFluxValueForFit).and(valid(temp_vdf)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
                    
                    if separatePeaksWithL3Values == True:
                        vdf_p1_dd = trim(vdf_p1,tr_dds)
                        vdf_3_dd = trim(vdf_3,tr_dds)
                        vdf_a_dd = trim(vdf_a,tr_dds)

                        temp_vdf_p1 = None
                        temp_vdf_3 = None
                        temp_vdf_a = None
                        for i in xrange(len(v_z_dd)):
                            temp_vdf_p1      = concatenate(temp_vdf_p1,vdf_p1_dd[i,:])
                            temp_vdf_3       = concatenate(temp_vdf_3,vdf_3_dd[i,:])
                            temp_vdf_a       = concatenate(temp_vdf_a,vdf_a_dd[i,:])

                    #elif separatePeaksWithL3Values == False:
                    # These two lines below should create a step function on the normalized weights such that anything less than 0.5 goes to 0. The idea is that this will only fit the points that are above half the max of the peak
                    blackoutNormalized = where(lt(norm_temp_vdf,0.5))
                    norm_temp_vdf[blackoutNormalized] = 0
                    temp_vdf[blackoutNormalized] = 0
                        #plot(norm_temp_vdf[r]*100,xrange=[0,600],renderType='scatter')
                
                    print '577'
                    
                    f = LinFit()
                    
                    ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                    #ftr_chi = AbstractCurveFitter(LevenbergMarquardtOptimizer())
                    ftr_psi = CurveFitter(LevenbergMarquardtOptimizer())
                    #ftr_psi = AbstractCurveFitter(LevenbergMarquardtOptimizer())
                    
                    if separatePeaksWithL3Values == True:
                        ftr_chi_p1 = CurveFitter(LevenbergMarquardtOptimizer())
                        ftr_psi_p1 = CurveFitter(LevenbergMarquardtOptimizer())
                        ftr_chi_3 = CurveFitter(LevenbergMarquardtOptimizer())
                        ftr_psi_3 = CurveFitter(LevenbergMarquardtOptimizer())
                        ftr_chi_a = CurveFitter(LevenbergMarquardtOptimizer())
                        ftr_psi_a = CurveFitter(LevenbergMarquardtOptimizer())
                    
                    for i in xrange(len(temp_v_z[r])):
                        # This weighting uses the normalized VDF data - It isn't working because it loses the weights for some reason (floats->doubles)
                        #ftr_chi.addObservedPoint( int(float(norm_temp_vdf[r][i])*100) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                        #ftr_psi.addObservedPoint( int(float(norm_temp_vdf[r][i])*100) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))
                        
                        if separatePeaksWithL3Values == True:
                            r_p1 = where(ge(temp_vdf_p1,minFluxValueForFit).and(valid(temp_vdf_p1)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
                            r_3 = where(ge(temp_vdf_3,minFluxValueForFit).and(valid(temp_vdf_3)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
                            r_a = where(ge(temp_vdf_a,minFluxValueForFit).and(valid(temp_vdf_a)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
                            
                            try:
                                ftr_chi_p1.addObservedPoint( int(float(temp_vdf_p1[r_p1][i])*1000) , float(temp_v_z[r_p1][i]*temp_Nx_temp_dd[r_p1][i]) , float(temp_vz_tanTheta[r_p1][i]))
                                ftr_psi_p1.addObservedPoint( int(float(temp_vdf_p1[r_p1][i])*1000) , float(temp_v_z[r_p1][i]*temp_Ny_temp_dd[r_p1][i]) , float(temp_vz_tanPhi[r_p1][i]))
                            except:
                                ftr_chi_p1.addObservedPoint( 0 , 0 , 0 )
                                ftr_psi_p1.addObservedPoint( 0 , 0 , 0 )
                            try:    
                                ftr_chi_3.addObservedPoint( int(float(temp_vdf_3[r_3][i]) *1000) , float(temp_v_z[r_3][i]*temp_Nx_temp_dd[r_3][i]) , float(temp_vz_tanTheta[r_3][i]))
                                ftr_psi_3.addObservedPoint( int(float(temp_vdf_3[r_3][i]) *1000) , float(temp_v_z[r_3][i]*temp_Ny_temp_dd[r_3][i]) , float(temp_vz_tanPhi[r_3][i]))
                            except:
                                ftr_chi_3.addObservedPoint( 0 , 0 , 0 )
                                ftr_psi_3.addObservedPoint( 0 , 0 , 0 )
                            try:        
                                ftr_chi_a.addObservedPoint( int(float(temp_vdf_a[r_a][i]) *1000) , float(temp_v_z[r_a][i]*temp_Nx_temp_dd[r_a][i]) , float(temp_vz_tanTheta[r_a][i]))
                                ftr_psi_a.addObservedPoint( int(float(temp_vdf_a[r_a][i]) *1000) , float(temp_v_z[r_a][i]*temp_Ny_temp_dd[r_a][i]) , float(temp_vz_tanPhi[r_a][i]))
                            except:
                                ftr_chi_a.addObservedPoint( 0 , 0 , 0 )
                                ftr_psi_a.addObservedPoint( 0 , 0 , 0 )
                            
                        #elif separatePeaksWithL3Values == False:
                        if True:
                            # This weighting uses the original vdf where we ignore any points below half of the normalized peak
                            if useVDFFluxForWeights == False: #In this case, set all values above the above-listed noise floor to one so they have the same weights
                                temp_vdf[r][i] = 1.
                            ftr_chi.addObservedPoint( int(float(temp_vdf[r][i])*1000) , float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]) , float(temp_vz_tanTheta[r][i]))
                            ftr_psi.addObservedPoint( int(float(temp_vdf[r][i])*1000) , float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]) , float(temp_vz_tanPhi[r][i]))
    
                        
                    #if mod(ind,modFits) == 0:    
                    #    print 'Adding all points into fitting function took:',TimeUtil.now()-time_last
                    #    time_last = TimeUtil.now()
                    
                    try:
                        result_chi = ftr_chi.fit(f,inputGuessParams)
                    except:
                        result_chi = [-1E38,-1E38]
                        #result_chi = ftr_chi.fit(f,[float(rand(1)[0]),float(rand(1)[0])])
                    try:
                        result_psi = ftr_psi.fit(f,inputGuessParams)
                    except:
                        result_psi = [-1E38,-1E38]
                        #result_psi = ftr_chi.fit(f,[float(rand(1)[0]),float(rand(1)[0])])
                        
                    print '648'
                    xx_x = linspace( min((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
                    xx_y = linspace( min((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
                
                    #r = where(ge(temp_vdf,minFluxValueForFit).and(valid(temp_vdf)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
                    
                    def fittingUncertainties(fitResult,tempVDF,tempvz,tempvq,tempBq):
                        r = where(ge(tempVDF,minFluxValueForFit).and(valid(tempVDF)).and(valid(tempvz)))  # Removes points from the measurement below a particular threschhold
                        VDF_fitValues = where(gt(tempVDF[r],0))
                        temp_fitValues = (fitResult[0]*(tempvz[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues]) + fitResult[1])
                        temp_residualVariance = ( tempvq[r][VDF_fitValues] - temp_fitValues )**2
                        
                        try:
                            temp_chiSquared = total( abs( temp_residualVariance / temp_fitValues ) )
                            temp_chiSquaredReduced = temp_chiSquared / (len(tempvz[r][VDF_fitValues]) - 2)
                        except:
                            temp_chiSquaredReduced = -1E38
                        try:
                            temp_totalVariance = (tempvq[r][VDF_fitValues] - mean(tempvq[r][VDF_fitValues]))**2
                            temp_rSquared = 1 - ( total(temp_residualVariance) / total(temp_totalVariance) )
                            temp_abscissaVariance = ( (tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues]) - mean((tempvz[r][VDF_fitValues]*tempBq[r][VDF_fitValues])) )**2
                            temp_slopeError = sqrt( total(temp_residualVariance) / total(temp_abscissaVariance) ) / (len(tempvz[r][VDF_fitValues]) - 2)
                        except:
                            temp_rSquared = -1E38
                            temp_slopeError = -1E38
                        
                        return(temp_chiSquaredReduced,temp_rSquared,temp_slopeError)
                        
                    (temp_chiSquaredReduced_chi,temp_rSquared_chi,temp_slopeError_chi) = fittingUncertainties(result_chi,temp_vdf,temp_v_z,temp_vz_tanTheta,temp_Nx_temp_dd)
                    (temp_chiSquaredReduced_psi,temp_rSquared_psi,temp_slopeError_psi) = fittingUncertainties(result_psi,temp_vdf,temp_v_z,temp_vz_tanPhi,temp_Ny_temp_dd)
                    
#                    # This is the chiSquared value I was using
#                    #temp_chiSquared_chi = abs(total( ( temp_vz_tanTheta[r] - (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) )**2 / (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) ) )
#                    #temp_chiSquared_psi = abs(total( ( temp_vz_tanPhi[r]   - (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) )**2 / (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) ) )
#
#                    # This chiSquared tries to only calculate it where I used the weighted values for the fit (ignoring the points with flux below 0.5*peak)
#                    VDF_fitValues = where(gt(temp_vdf[r],0))
#                    temp_fitValues_chi = (result_chi[0]*(temp_v_z[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues]) + result_chi[1])
#                    temp_fitValues_psi = (result_psi[0]*(temp_v_z[r][VDF_fitValues]*temp_Ny_temp_dd[r][VDF_fitValues]) + result_psi[1])
#                    temp_residualVariance_chi = ( temp_vz_tanTheta[r][VDF_fitValues] - temp_fitValues_chi )**2
#                    temp_residualVariance_psi = ( temp_vz_tanPhi[r][VDF_fitValues]   - temp_fitValues_psi )**2
#
#                    temp_chiSquared_chi = total( abs( temp_residualVariance_chi / temp_fitValues_chi ) )
#                    temp_chiSquared_psi = total( abs( temp_residualVariance_psi / temp_fitValues_psi ) )
#
#                    temp_chiSquaredReduced_chi = temp_chiSquared_chi / (len(temp_v_z[r][VDF_fitValues]) - 2) # Should be (n-2) degrees of freedom
#                    temp_chiSquaredReduced_psi = temp_chiSquared_psi / (len(temp_v_z[r][VDF_fitValues]) - 2)
#
#                    temp_totalVariance_chi = (temp_vz_tanTheta[r][VDF_fitValues] - mean(temp_vz_tanTheta[r][VDF_fitValues]))**2
#                    temp_totalVariance_psi = (temp_vz_tanPhi[r][VDF_fitValues]   - mean(temp_vz_tanPhi[r][VDF_fitValues]))**2
#
#                    temp_rSquared_chi = 1 - ( total(temp_residualVariance_chi) / total(temp_totalVariance_chi) )
#                    temp_rSquared_psi = 1 - ( total(temp_residualVariance_psi) / total(temp_totalVariance_psi) )
#
#                    temp_abscissaVariance_chi = ( (temp_v_z[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues]) - mean((temp_v_z[r][VDF_fitValues]*temp_Nx_temp_dd[r][VDF_fitValues])) )**2
#                    temp_abscissaVariance_psi = ( (temp_v_z[r][VDF_fitValues]*temp_Ny_temp_dd[r][VDF_fitValues]) - mean((temp_v_z[r][VDF_fitValues]*temp_Ny_temp_dd[r][VDF_fitValues])) )**2
#
#                    temp_slopeError_chi = sqrt( total(temp_residualVariance_chi) / total(temp_abscissaVariance_chi) ) / (len(temp_v_z[r][VDF_fitValues]) - 2)
#                    temp_slopeError_psi = sqrt( total(temp_residualVariance_psi) / total(temp_abscissaVariance_psi) ) / (len(temp_v_z[r][VDF_fitValues]) - 2)
                    
                    print 'line 708'
                    # Have to append everything at once since I was left with uneven dataset/epoch arrays
                    chiline = concatenate(chiline,result_chi[0])
                    psiline = concatenate(psiline,result_psi[0])
                    
                    chiSquaredReduced_chi = concatenate(chiSquaredReduced_chi,temp_chiSquaredReduced_chi)
                    chiSquaredReduced_psi = concatenate(chiSquaredReduced_psi,temp_chiSquaredReduced_psi)
                    
                    rSquared_chi = concatenate(rSquared_chi,temp_rSquared_chi)
                    rSquared_psi = concatenate(rSquared_psi,temp_rSquared_psi)
                    
                    slopeError_chi = concatenate(slopeError_chi,temp_slopeError_chi)
                    slopeError_psi = concatenate(slopeError_psi,temp_slopeError_psi)
                    
                    if mod(ind,modFits) == 0:    
                        print 'Calculating Uncertainties took:',TimeUtil.now()-time_last
                        time_last = TimeUtil.now()
                        print 'Total fitting function so far (%s %s) took:'%(str(int(100.*ind/(len(dds)-1.))),'%'),TimeUtil.now()-time_begin_tr
                    
                        
                    if separatePeaksWithL3Values == True:
                        result_p1_chi = ftr_chi_p1.fit(f,inputGuessParams)
                        result_p1_psi = ftr_psi_p1.fit(f,inputGuessParams)
                        result_3_chi = ftr_chi_3.fit(f,inputGuessParams)
                        result_3_psi = ftr_psi_3.fit(f,inputGuessParams)
                        result_a_chi = ftr_chi_a.fit(f,inputGuessParams)
                        result_a_psi = ftr_psi_a.fit(f,inputGuessParams)
                        
                        (temp_chiSquaredReduced_p1_chi,temp_rSquared_p1_chi,temp_slopeError_p1_chi) = fittingUncertainties(result_p1_chi,temp_vdf_p1,temp_v_z,temp_vz_tanTheta,temp_Nx_temp_dd)
                        (temp_chiSquaredReduced_p1_psi,temp_rSquared_p1_psi,temp_slopeError_p1_psi) = fittingUncertainties(result_p1_psi,temp_vdf_p1,temp_v_z,temp_vz_tanPhi,temp_Ny_temp_dd)
                        (temp_chiSquaredReduced_3_chi,temp_rSquared_3_chi,temp_slopeError_3_chi) = fittingUncertainties(result_3_chi,temp_vdf_3,temp_v_z,temp_vz_tanTheta,temp_Nx_temp_dd)
                        (temp_chiSquaredReduced_3_psi,temp_rSquared_3_psi,temp_slopeError_3_psi) = fittingUncertainties(result_3_psi,temp_vdf_3,temp_v_z,temp_vz_tanPhi,temp_Ny_temp_dd)
                        (temp_chiSquaredReduced_a_chi,temp_rSquared_a_chi,temp_slopeError_a_chi) = fittingUncertainties(result_a_chi,temp_vdf_a,temp_v_z,temp_vz_tanTheta,temp_Nx_temp_dd)
                        (temp_chiSquaredReduced_a_psi,temp_rSquared_a_psi,temp_slopeError_a_psi) = fittingUncertainties(result_a_psi,temp_vdf_a,temp_v_z,temp_vz_tanPhi,temp_Ny_temp_dd)
                        
                        
                        # Have to append everything at once since I was left with uneven dataset/epoch arrays
                        chiline_p1 = concatenate(chiline_p1,result_p1_chi[0])
                        psiline_p1 = concatenate(psiline_p1,result_p1_psi[0])
                        chiSquaredReduced_p1_chi = concatenate(chiSquaredReduced_p1_chi,temp_chiSquaredReduced_p1_chi)
                        chiSquaredReduced_p1_psi = concatenate(chiSquaredReduced_p1_psi,temp_chiSquaredReduced_p1_psi)
                        rSquared_p1_chi = concatenate(rSquared_p1_chi,temp_rSquared_p1_chi)
                        rSquared_p1_psi = concatenate(rSquared_p1_psi,temp_rSquared_p1_psi)
                        slopeError_p1_chi = concatenate(slopeError_p1_chi,temp_slopeError_p1_chi)
                        slopeError_p1_psi = concatenate(slopeError_p1_psi,temp_slopeError_p1_psi)
                        
                        chiline_3 = concatenate(chiline_3,result_3_chi[0])
                        psiline_3 = concatenate(psiline_3,result_3_psi[0])
                        chiSquaredReduced_3_chi = concatenate(chiSquaredReduced_3_chi,temp_chiSquaredReduced_3_chi)
                        chiSquaredReduced_3_psi = concatenate(chiSquaredReduced_3_psi,temp_chiSquaredReduced_3_psi)
                        rSquared_3_chi = concatenate(rSquared_3_chi,temp_rSquared_3_chi)
                        rSquared_3_psi = concatenate(rSquared_3_psi,temp_rSquared_3_psi)
                        slopeError_3_chi = concatenate(slopeError_3_chi,temp_slopeError_3_chi)
                        slopeError_3_psi = concatenate(slopeError_3_psi,temp_slopeError_3_psi)
                        
                        chiline_a = concatenate(chiline_a,result_a_chi[0])
                        psiline_a = concatenate(psiline_a,result_a_psi[0])
                        chiSquaredReduced_a_chi = concatenate(chiSquaredReduced_a_chi,temp_chiSquaredReduced_a_chi)
                        chiSquaredReduced_a_psi = concatenate(chiSquaredReduced_a_psi,temp_chiSquaredReduced_a_psi)
                        rSquared_a_chi = concatenate(rSquared_a_chi,temp_rSquared_a_chi)
                        rSquared_a_psi = concatenate(rSquared_a_psi,temp_rSquared_a_psi)
                        slopeError_a_chi = concatenate(slopeError_a_chi,temp_slopeError_a_chi)
                        slopeError_a_psi = concatenate(slopeError_a_psi,temp_slopeError_a_psi)
                    
                    #epsilonEpoch = concatenate(epsilonEpoch,datum(dds[ind])+(datum(dds[ind+1])-datum(dds[ind]))/2.)
                    epsilonEpoch = concatenate(epsilonEpoch,datum(dds[ind])+datum(str(fitSeconds/2.)+' sec') )
                    #plot(4,epsilonEpoch))
                    #plot(5,rSquared_psi)
                    
                    print 'line 777'
                    
                    if plotFitsAndPauseALot == True:
                        if 'vapAlreadyLoaded' not in locals():
                            load(googleDrive_path+'Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Files/L0/anisotropyFromMath_IterativeFitPlotter.vap')
                            plot(0,vdf_full,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle='VDF (cm!U-3!N km!U-1!N s)',zlog=True)
                            #plot(1,v_z[r])
                            vapAlreadyLoaded = None
                            
                        
                        temp_epsilon_chi = - result_chi[0] / ( (result_chi[0]*(1 - Nz_temp_dd**2)) + Nz_temp_dd )
                        temp_epsilon_psi = - result_psi[0] / ( (result_psi[0]*(1 - Nz_temp_dd**2)) + Nz_temp_dd )
                        plot_anisotropy_chi = sqrt(temp_epsilon_chi+1)
                        plot_anisotropy_psi = sqrt(temp_epsilon_psi+1)
                        
                        print 'plot_anisotropy_chi',plot_anisotropy_chi
                        print 'plot_anisotropy_psi',plot_anisotropy_psi
                        
                        TEMP_anisotropy_chi = concatenate(TEMP_anisotropy_chi,plot_anisotropy_chi)
                        TEMP_anisotropy_psi = concatenate(TEMP_anisotropy_psi,plot_anisotropy_chi)
                        
                        
                        # The asin() is wrong, since I don't want the total orthogonality angle, just the angle between (Nx,Ny) and Nz
                        #mappedAngleIndex_chi = imin(abs(toDegrees(asin(Nx[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                        #mappedAngleIndex_psi = imin(abs(toDegrees(asin(Ny[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                        
                        # This atan() sould account for the above issue
                        mappedAngleIndex_chi = imin(abs(toDegrees(atan(mean(Nx_temp_dd)/Nz_temp_dd))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                        mappedAngleIndex_psi = imin(abs(toDegrees(atan(mean(Ny_temp_dd)/Nz_temp_dd))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                        
                        mappedAnisotropyIndex_chi = imin(abs(plot_anisotropy_chi-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
                        mappedAnisotropyIndex_psi = imin(abs(plot_anisotropy_psi-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
                        
                        if mappedAngleIndex_chi != -1 and mappedAnisotropyIndex_chi != -1 :
                            anisotropy_chi_deltaPlus  = anisotropy_deltaPlus[ mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                            anisotropy_chi_deltaMinus = anisotropy_deltaMinus[mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                        else:
                            anisotropy_chi_deltaPlus  = -1
                            anisotropy_chi_deltaMinus = -1
                            
                        if mappedAngleIndex_psi != -1 and mappedAnisotropyIndex_psi != -1 :
                            anisotropy_psi_deltaPlus  = anisotropy_deltaPlus[ mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                            anisotropy_psi_deltaMinus = anisotropy_deltaMinus[mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                        else:
                            anisotropy_psi_deltaPlus  = -1
                            anisotropy_psi_deltaMinus = -1
                        
                        print 'line 824'
                        #plot(3,dataset([datumRange(tr_dds).min(),datumRange(tr_dds).max(),'xff00ff','event']),renderType='eventsBar',color='magenta')
                        plot(3,event,renderType='eventsBar')
                        plot(4,temp_v_z[r]*temp_Nx_temp_dd[r],temp_vz_tanTheta[r] ,norm_temp_vdf[r],renderType='colorScatter',ztitle='VDF Normalized',symbolSize=3)
                        plot(6,temp_v_z[r]*temp_Ny_temp_dd[r],temp_vz_tanPhi[r]   ,norm_temp_vdf[r],renderType='colorScatter',ztitle='VDF Normalized',symbolSize=3)
                        #plot(5,xx_x,(result_chi[0]*xx_x + result_chi[1]),color='red',xtitle=tr_dds,title='r!U2!N = '+str(round(temp_rSquared_chi,4))+'     &Chi;!U2!Bred.!N = '+str(round(temp_chiSquaredReduced_chi,4))+'     Slope = '+str(round(result_chi[0],4))+'     SlopeError = '+str(round(temp_slopeError_chi,4)),symbolSize=0,lineWidth=2,ytitle='V!Bx')
                        #plot(7,xx_y,(result_psi[0]*xx_y + result_psi[1]),color='red',xtitle='V!Bz!N!C'+tr_dds,title='r!U2!N = '+str(round(temp_rSquared_psi,4))+'     &Chi;!U2!Bred.!N = '+str(round(temp_chiSquaredReduced_psi,4))+'     Slope = '+str(round(result_psi[0],4))+'     SlopeError = '+str(round(temp_slopeError_psi,4)),symbolSize=0,lineWidth=2,ytitle='V!By')
                        plot(5,xx_x,(result_chi[0]*xx_x + result_chi[1]),color='red',xtitle='V!Bz!N*B!Bx!N (nT km s!U-1!N)!C!C'+tr_dds,title='Slope = '+str(round(result_chi[0],4))+'     SlopeError = '+str(round(temp_slopeError_chi,4))+'     Anisotropy!B&Chi;!N = '+str(round(plot_anisotropy_chi,3))+' &plusmn; ['+str(round(anisotropy_chi_deltaPlus,3))+','+str(round(anisotropy_chi_deltaMinus,3))+']',symbolSize=0,lineWidth=2,ytitle='V!Bx!N (km s!U-1!N)')
                        plot(7,xx_y,(result_psi[0]*xx_y + result_psi[1]),color='red',xtitle='V!Bz!N*B!By!N (nT km s!U-1!N)!C!C'+tr_dds,title='Slope = '+str(round(result_psi[0],4))+'     SlopeError = '+str(round(temp_slopeError_psi,4))+'     Anisotropy!B&Psi;!N = '+str(round(plot_anisotropy_psi,3))+' &plusmn; ['+str(round(anisotropy_psi_deltaPlus,3))+','+str(round(anisotropy_psi_deltaMinus,3))+']',symbolSize=0,lineWidth=2,ytitle='V!By!N (km s!U-1!N)')
                        #plot(8,trim(Nz_temp,tr_dds),title=Nz_temp_dd)
                        
    #                    psiline_temp = putProperty(copy(psiline),QDataSet.DEPEND_0,epsilonEpoch)
    #                    chiline_temp = putProperty(copy(chiline),QDataSet.DEPEND_0,epsilonEpoch)
    #
    #                    (Nx_temp,Ny_temp,Nz_temp) = synchronize(chiline_temp,[Nx,Ny,Nz])
    #                    Btotal_temp = synchronize(chiline_temp,[Btotal])[0]   # Since synchronize puts out a list of arrays, use the [0] to choose the array itself
    #
    #                    epsilon_chi_temp = - chiline_temp / ( (chiline_temp*(1 - Nz_temp**2)) + Nz_temp ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
    #                    epsilon_psi_temp = - psiline_temp / ( (psiline_temp*(1 - Nz_temp**2)) + Nz_temp )
    #
    #                    anisotropy_chi_temp = sqrt(epsilon_chi_temp+1)
    #                    anisotropy_psi_temp = sqrt(epsilon_psi_temp+1)
    
                        #plot(8,sqrt(temp_residualVariance_chi),renderType='scatter',color='red')
                        #plot(9,sqrt(temp_residualVariance_psi),renderType='scatter',color='blue')
                        #plot(10,sqrt(temp_totalVariance_chi),renderType='scatter',color='red')
                        #plot(11,sqrt(temp_totalVariance_psi),renderType='scatter',color='blue')
                        
                        sleep(5000)
                        print '----'
                        continue
                #except:
                    print 'oopsy, couldn\'t fit for some reason'
                    print '----'
                    continue
            
            #########
            #########
            #########
                
            if ( monitor.cancelled ):
                print 'Canceling Process for',timerange
                break
            
            print 'Total fitting section for day took:',TimeUtil.now()-time_fit_begin
            time_last = TimeUtil.now()
            
            
            ####### Set DEPEND_0 for datasets
            
            psiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            chiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            chiSquaredReduced_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            chiSquaredReduced_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            rSquared_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            rSquared_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            slopeError_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            slopeError_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            
            
            
            # ###
            # ### FINAL CALCULATIONS
            # ###
            
            (Nx,Ny,Nz) = synchronize(chiline,[Nx,Ny,Nz])
            Btotal = synchronize(chiline,[Btotal])[0]   # Since synchronize puts out a list of arrays, use the [0] to choose the array itself
            
            epsilon_chi = - chiline / ( (chiline*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
            epsilon_psi = - psiline / ( (psiline*(1 - Nz**2)) + Nz )
        
            anisotropy_chi = sqrt(epsilon_chi+1)
            anisotropy_psi = sqrt(epsilon_psi+1)
            
            
            if separatePeaksWithL3Values == True:
                epsilon_p1_chi = - chiline_p1 / ( (chiline_p1*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
                epsilon_p1_psi = - psiline_p1 / ( (psiline_p1*(1 - Nz**2)) + Nz )
                anisotropy_p1_chi = sqrt(epsilon_p1_chi+1)
                anisotropy_p1_psi = sqrt(epsilon_p1_psi+1)
                
                epsilon_3_chi = - chiline_3 / ( (chiline_3*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
                epsilon_3_psi = - psiline_3 / ( (psiline_3*(1 - Nz**2)) + Nz )
                anisotropy_3_chi = sqrt(epsilon_3_chi+1)
                anisotropy_3_psi = sqrt(epsilon_3_psi+1)
                
                epsilon_a_chi = - chiline_a / ( (chiline_a*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
                epsilon_a_psi = - psiline_a / ( (psiline_a*(1 - Nz**2)) + Nz )
                anisotropy_a_chi = sqrt(epsilon_a_chi+1)
                anisotropy_a_psi = sqrt(epsilon_a_psi+1)
            
            
            
            #mappedAngleIndex_chi      = dblarr(len(epsilonEpoch))
            #mappedAngleIndex_psi      = dblarr(len(epsilonEpoch))
            #mappedAnisotropyIndex_chi = dblarr(len(epsilonEpoch))
            #mappedAnisotropyIndex_psi = dblarr(len(epsilonEpoch))
            anisotropy_chi_deltaPlus  = dblarr(len(epsilonEpoch))
            anisotropy_chi_deltaMinus = dblarr(len(epsilonEpoch))
            anisotropy_psi_deltaPlus  = dblarr(len(epsilonEpoch))
            anisotropy_psi_deltaMinus = dblarr(len(epsilonEpoch))
            for i in xrange(len(epsilonEpoch)):
                # The asin() is wrong, since I don't want the total orthogonality angle, just the angle between (Nx,Ny) and Nz
                #mappedAngleIndex_chi = imin(abs(toDegrees(asin(Nx[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                #mappedAngleIndex_psi = imin(abs(toDegrees(asin(Ny[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                
                # This atan() sould account for the above issue
                mappedAngleIndex_chi = imin(abs(toDegrees(atan(Nx[i]/Nz[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                mappedAngleIndex_psi = imin(abs(toDegrees(atan(Ny[i]/Nz[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
                
                mappedAnisotropyIndex_chi = imin(abs(anisotropy_chi[i]-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
                mappedAnisotropyIndex_psi = imin(abs(anisotropy_psi[i]-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
                
                if mappedAngleIndex_chi != -1 and mappedAnisotropyIndex_chi != -1 :
                    anisotropy_chi_deltaPlus[i]  = anisotropy_deltaPlus[ mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                    anisotropy_chi_deltaMinus[i] = anisotropy_deltaMinus[mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
                else:
                    anisotropy_chi_deltaPlus[i]  = -1
                    anisotropy_chi_deltaMinus[i] = -1
                    
                if mappedAngleIndex_psi != -1 and mappedAnisotropyIndex_psi != -1 :
                    anisotropy_psi_deltaPlus[i]  = anisotropy_deltaPlus[ mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                    anisotropy_psi_deltaMinus[i] = anisotropy_deltaMinus[mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
                else:
                    anisotropy_psi_deltaPlus[i]  = -1
                    anisotropy_psi_deltaMinus[i] = -1
                
            anisotropy_chi_deltaPlus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            anisotropy_chi_deltaMinus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            anisotropy_psi_deltaPlus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            anisotropy_psi_deltaMinus.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
                
            anisotropy_chi_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
            anisotropy_chi_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
            anisotropy_chi_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
            anisotropy_chi_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
            anisotropy_psi_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
            anisotropy_psi_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
            anisotropy_psi_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
            anisotropy_psi_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
            
            anisotropy_chi.putProperty(QDataSet.DELTA_PLUS, anisotropy_chi_deltaPlus)
            anisotropy_chi.putProperty(QDataSet.DELTA_MINUS,anisotropy_chi_deltaMinus)
            anisotropy_psi.putProperty(QDataSet.DELTA_PLUS, anisotropy_psi_deltaPlus)
            anisotropy_psi.putProperty(QDataSet.DELTA_MINUS,anisotropy_psi_deltaMinus)
                
                
            Bunit = bundle(Nx,Ny,Nz)
            Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
        
        # ###
        # ### WRITE STUFF
        # ###
        
        if writeStuff == True:
            if analyzingTimeWidthComparisons == True:
                output_file = output_folder+'SPC_Anisotropy_%s_v%s_%ssec.cdf'%(tr,version,str(fitSeconds))
            elif analyzingTimeWidthComparisons == False:
                output_file = output_folder+'SPC_Anisotropy_%s_v%s.cdf'%(tr,version)


            
            Bunit.putProperty(QDataSet.NAME,'B_hat')
            Bunit.putProperty(QDataSet.TITLE,'Unit vector of background B-field direction using %s-second average'%(trend_seconds))
            Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            formatDataSet(Bunit,output_file)
            Btotal.putProperty(QDataSet.NAME,'B_total')
            Btotal.putProperty(QDataSet.TITLE,'Total B-field magnitude')
            Btotal.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
            formatDataSet(Btotal,output_file+'?append=T')
            
            
            psiline.putProperty(QDataSet.NAME,'Psi')
            psiline.putProperty(QDataSet.TITLE,'Linear fit of scan points over %s-second range in Vy/Vz space'%fitSeconds)
            psiline.putProperty(QDataSet.DESCRIPTION,'Determined from slope between Vy and Vz*B_hat_y around peak of VDF')
            chiline.putProperty(QDataSet.NAME,'Chi')
            chiline.putProperty(QDataSet.TITLE,'Linear fit of scan points over %s-second range in Vx/Vz space'%fitSeconds)
            chiline.putProperty(QDataSet.DESCRIPTION,'Determined from slope between Vx and Vz*B_hat_x around peak of VDF')
            chiSquaredReduced_chi.putProperty(QDataSet.NAME,'ChiSquared_chi')
            chiSquaredReduced_chi.putProperty(QDataSet.TITLE,'Reduced chi-squared from linear fit determining Chi')
            chiSquaredReduced_psi.putProperty(QDataSet.NAME,'ChiSquared_psi')
            chiSquaredReduced_psi.putProperty(QDataSet.TITLE,'Reduced chi-squared from linear fit determining Psi')
            rSquared_chi.putProperty(QDataSet.NAME,'rSquared_chi')
            rSquared_chi.putProperty(QDataSet.TITLE,'R-squared from linear fit determining Chi')
            rSquared_psi.putProperty(QDataSet.NAME,'rSquared_psi')
            rSquared_psi.putProperty(QDataSet.TITLE,'R-squared from linear fit determining Psi')
            slopeError_chi.putProperty(QDataSet.NAME,'slopeError_chi')
            slopeError_chi.putProperty(QDataSet.TITLE,'Uncertainty in the slope from the linear fit that is Chi')
            slopeError_psi.putProperty(QDataSet.NAME,'slopeError_psi')
            slopeError_psi.putProperty(QDataSet.TITLE,'Uncertainty in the slope from the linear fit that is Psi')
            
            
            formatDataSet(chiline,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(psiline,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(chiSquaredReduced_chi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(chiSquaredReduced_psi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(rSquared_chi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(rSquared_psi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(slopeError_chi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(slopeError_psi,output_file+'?append=T')
            
            ######
            
    #        (Nx,Ny,Nz) = synchronize(chiline,[Nx,Ny,Nz])
    #        Btotal = synchronize(chiline,[Btotal])[0]   # Since synchronize puts out a list of arrays, use the [0] to choose the array itself
    #
    #        Bunit = bundle(Nx,Ny,Nz)
    #        Bunit.putProperty(QDataSet.NAME,'B_hat')
    #        Bunit.putProperty(QDataSet.TITLE,'Unit vector of background B-field direction using %s-second average'%(trend_seconds))
    #        Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    #        formatDataSet(Bunit,output_file+'?append=T')
    #        Btotal.putProperty(QDataSet.NAME,'B_total')
    #        Btotal.putProperty(QDataSet.TITLE,'Total B-field magnitude')
    #        Btotal.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    #        formatDataSet(Btotal,output_file+'?append=T')
            
            epsilon_chi.putProperty(QDataSet.NAME,'Epsilon_chi')
            epsilon_psi.putProperty(QDataSet.NAME,'Epsilon_psi')
            waitUntilIdle()
            formatDataSet(epsilon_chi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(epsilon_psi,output_file+'?append=T')
            
            anisotropy_chi.putProperty(QDataSet.NAME,'Anisotropy_chi')
            anisotropy_chi.putProperty(QDataSet.TITLE,'Anisotropy from SPC determined from Vx/Vz fit over %s-second range with %s-second averaged background B-field direction'%(fitSeconds,trend_seconds))
            anisotropy_psi.putProperty(QDataSet.NAME,'Anisotropy_psi')
            anisotropy_psi.putProperty(QDataSet.TITLE,'Anisotropy from SPC determined from Vy/Vz fit over %s-second range with %s-second averaged background B-field direction'%(fitSeconds,trend_seconds))
            
            
            
            
            anisotropy_chi_deltaPlus.putProperty(QDataSet.NAME, 'anisotropy_chi_deltaPlus')
            anisotropy_chi_deltaPlus.putProperty(QDataSet.TITLE, 'DELTA_PLUS values for anisotropy_chi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            anisotropy_chi_deltaMinus.putProperty(QDataSet.NAME, 'anisotropy_chi_deltaMinus')
            anisotropy_chi_deltaMinus.putProperty(QDataSet.TITLE, 'DELTA_MINUS values for anisotropy_chi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            anisotropy_psi_deltaPlus.putProperty(QDataSet.NAME, 'anisotropy_psi_deltaPlus')
            anisotropy_psi_deltaPlus.putProperty(QDataSet.TITLE, 'DELTA_PLUS values for anisotropy_psi determined from ideal model (ie best we can do even assuming perfect data input)')
            
            anisotropy_psi_deltaMinus.putProperty(QDataSet.NAME, 'anisotropy_psi_deltaMinus')
            anisotropy_psi_deltaMinus.putProperty(QDataSet.TITLE, 'DELTA_MINUS values for anisotropy_psi determined from ideal model (ie best we can do even assuming perfect data input)')
                        
            waitUntilIdle()
            formatDataSet(anisotropy_chi,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(anisotropy_psi,output_file+'?append=T')
            
            waitUntilIdle()
            formatDataSet(anisotropy_chi_deltaPlus, output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(anisotropy_chi_deltaMinus,output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(anisotropy_psi_deltaPlus, output_file+'?append=T')
            waitUntilIdle()
            formatDataSet(anisotropy_psi_deltaMinus,output_file+'?append=T')
        
        
        
            print 'Writing Data to CDF took:',TimeUtil.now()-time_fit_begin
            time_last = TimeUtil.now()
        
                
        #if separatePeaksWithL3Values == True:
        #    continue
        
        
        # TODO: Add other peak writing stuff here (copy all from above but with p1 and alphas
        
        
        
        
        #plot(4,epsilonEpoch,epsilon_chi,color='red')
        #plot(5,epsilonEpoch,epsilon_psi,color='blue',ytitle='(&omega;!B&perp;!N/&omega;!B||!N)!U2!N - 1')
        
        plot(4,epsilonEpoch,bundle(anisotropy_chi,anisotropy_psi),symbol='none',ytitle='&omega;!B&perp;!N/&omega;!B||!N')
        
        #plot(5,epsilonEpoch,bundle(slopeError_chi,slopeError_psi),symbol='none',ytitle='Slope Error of Fit')
        plot(5,epsilonEpoch,bundle(anisotropy_a_chi,anisotropy_a_psi),symbol='none',ytitle='anisotropy_a')
        
        
        #plot(6,epsilonEpoch,anisotropy_chi_deltaPlus)
        #plot(6,epsilonEpoch,bundle(toDegrees(atan(Nx/Nz)),toDegrees(atan(Ny/Nz))),ytitle='&#x2220;B!Bincident!N')
        plot(6,epsilonEpoch,bundle(anisotropy_3_chi,anisotropy_3_psi),symbol='none',ytitle='anisotropy_beam')
        
        #plot(6,epsilonEpoch,sqrt(1-(1./(1-(Nz**2)))+((Nx*Nz)/((1-(Nz**2))**2))),ytitle='just Bz factor')
        #plot(6,epsilonEpoch,psiline_a,ytitle='chiline-a')
        
        
        #stop
        #
        #epsilon_chi.putProperty(QDataSet.DEPEND_1,mv_lo)
        #epsilon_psi.putProperty(QDataSet.DEPEND_1,mv_lo)
        #
        ##reset()
        #plot(0,totalFlux)
        #plot(3,epsilon_chi,ytitle='&epsilon;&Chi;')
        #plot(4,epsilon_psi,ytitle='&epsilon;&Psi;')
        
    
    except(java.io.FileNotFoundException):
        #if 'noSPCData' in locals():
        print 'DATA FOR %s COULD NOT BE FOUND'%(tr)
        continue

monitor.finished()
