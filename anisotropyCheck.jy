


#randomSeed(30)
generatingTotalErrorMap = False
generatingDeltaPlusMinusMaps = False
RunningSingleCase = True
RunningDoubleCase = True

plotVzObservedVDF = True
UseRealisticGaussians = True

goodPeakFactor = 0.5     # Fraction of values normalized to peak that should be considered in fitting

length = 500#0#00#000         # Number of points in each maxwellian distribution
numberOfPoints = 50000    # Number of points over which iteration is done (TODO: change this to time with timeUtil().Now)
numberIterations = 4     # Number of times to iterate each set slope and anisotropy measurement in TotalErrorMap
pauseAndPlotCounter = 5  # Number of points to run through before generating each plot

angleMin = -90
angleMax = 90
angleBinNumber = 90       # Number of bins in incident mag angle space

anisotropyMin = 0.03
anisotropyMax = 15
anisotropyBinNumber = 50  # Number of bins in anisotropy space

timeToStopProcessing = '2019-10-06 19:30'   # Time in UT until which the process will run and aggregate data before writing the result (EDT = UT-4)

# Mac
temp_outputMap = '/home/kpaulson/Research/PSP/Anisotropy/TEMP_Anisotropy_DELTA_PLUS-MINUS.cdf'
#outputMap      = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_DELTA_PLUS-MINUS.cdf'
temp_outputMap_googleDrive = '/home/kpaulson/Google Drive File Stream/My Drive/Research/PSP/SPC/SPC Anisotropy/TEMP_Anisotropy_DELTA_PLUS-MINUS.cdf'
outputMap      = '/home/kpaulson/Google Drive File Stream/My Drive/Research/PSP/SPC/SPC Anisotropy/Anisotropy_DELTA_PLUS-MINUS.cdf'

# PC
#temp_outputMap = 'C:/Users/kpaulson/Google Drive/SPC Anisotropy/Anisotropy_Files/TEMP_Anisotropy_DELTA_PLUS-MINUS.cdf'
#outputMap = 'C:/Users/kpaulson/Google Drive/SPC Anisotropy/Anisotropy_Files/Anisotropy_DELTA_PLUS-MINUS.cdf'



if RunningSingleCase == True or UseRealisticGaussians == True or RunningDoubleCase == True:
    angle = getParam('Bfield_angle',30,'Incident magnetic field angle relative to z_hat')
    aniso = getParam('Anisotropy',3,'Input distribution anisotropy')
    
    
    vz_min = 200   # Taken from bin averages around 2018-11-01 7:52 UT (arbitrarily chosen)
    vz_max = 740
    # Nt sure if this is the right way to think about it... let's just increase this arbitrarily to 1000
    #vx_min = -vz_max*cos(toRadians(28.5))  # Using the maximum measurable incoming flow direction of 28.5 degrees
    #vx_max = abs(vx_min)
    vx_min = -1000
    vx_max = abs(vx_min)

    factorBulk = 1.
    thermalSpeed_parallel = 50 # Taken from bin averages around 2018-11-01 7:52 UT (time arbitrarily chosen)
    velocity_parallel = 325
    density_parallel = 220 # This is the total density of the entire distribution, not the density of the observed v_z component. This causes trouble for extremely anisotropic distributions.
    density_parallel = 500
    
    thermalSpeed_perp = thermalSpeed_parallel*aniso
    velocity_perp = 130
    density_perp = density_parallel
    
    BackgroundNoiseFactor = 0.4#.1
    
    aniso_beam = 0.7
    factorBeam = 0.4
    
    thermalSpeed_parallel_beam = 40 # Taken from bin averages around 2018-11-01 7:52 UT (arbitrarily chosen)
    beamSeparationSpeed = 80
    velocity_parallel_beam = velocity_parallel + (beamSeparationSpeed*cos(toRadians(angle)))#460
    density_parallel_beam = 100
    
    thermalSpeed_perp_beam = thermalSpeed_parallel_beam*aniso_beam
    velocity_perp_beam = velocity_perp + (beamSeparationSpeed*sin(toRadians(angle)))   #200
    density_perp_beam = density_parallel
            
magSlopes = linspace(angleMin,angleMax,angleBinNumber)
anisotropyList = logspace(anisotropyMin,anisotropyMax,anisotropyBinNumber)


from org.apache.commons.math.optimization.fitting import CurveFitter
from org.apache.commons.math.optimization.fitting import ParametricRealFunction
from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer

class LinFit(ParametricRealFunction):
    def value(self, x, params):
        a = params[0]
        b = params[1]
        return (a*x + b)
    def gradient(self, x, params):
        a = params[0]
        b = params[1]
        return [x,1]

#############################
#############################
#############################
#############################

outputMagSlopes              = None
outputAnisotropiesInput      = None
outputAnisotropiesMeasured   = None
outputMagSlopes_beam              = None
outputAnisotropiesInput_beam      = None
outputAnisotropiesMeasured_beam   = None
chiSquaredMap                   = None
outputMagSlopesMap              = None
outputAnisotropiesInputMap      = None
outputAnisotropiesMeasuredMap   = None

deltaPlus              = None
deltaPlus_dep0         = None
deltaPlus_dep1         = None
deltaMinus             = None
deltaMinus_dep0        = None
deltaMinus_dep1        = None

monitor.started()

counter = 0
if generatingTotalErrorMap == True:
    monitor.setTaskSize(len(magSlopes)*len(anisotropyList)*numberIterations)
    for angle in magSlopes:
        slope = toRadians(angle)
        
        for anisotropy in anisotropyList:
            aniso = anisotropy
            
            clusterUncertainty               = None
            temp_outputAnisotropiesMeasured  = None
            iteration = 0
            while iteration < numberIterations:
                monitor.setTaskProgress(counter)
                try:
                
                    p1 = randomn(long(rand(1)[0]*1E6),length)
                    p2 = randomn(long(rand(1)[0]*1E6),length)*aniso
                    
                    Nz = cos(slope)
                    Nx = sin(slope)
                    
                    p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[70,70],dataset([-5,5]),dataset([-5,5]))\
                    
                    peaks = None
                    peaks1 = None
                    peaks2 = None
                    for i in xrange(len(p1p2_hist)):
                        temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                        temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                        
                        peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                        peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                        
                    
                    
                            
                    inputGuessParams = [0.5,0.5]
                    f = LinFit()
                    ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                    peaks1 = normalize(peaks1)
                    
                    for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0))):
                        ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                        #ftr_chi.addObservedPoint(float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))#,float(ones(len((peaks1)))[i]))
                        
                    result_chi = ftr_chi.fit(f,inputGuessParams)
                       
                    
                    
                    chiline = result_chi[0]
                    print 'chiline:',chiline
                    #print result_chi[1] 
                    
                    
                    epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                    
                    phi = atan(chiline)
                    #print 'ecc:',(tan((slope - phi)/slope))
                    
                    #print '1/epsilon:',1./sqrt(epsilon_chi+1)
                    print 'measured_anisotropy:',sqrt(epsilon_chi+1)
                    print 'input_anisotropy:',aniso
                    
#                    anisotropyDifference = sqrt(epsilon_chi+1) - aniso
#                    if ge(anisotropyDifference.value(),0):
#                        deltaPlus_dep0 = concatenate(deltaPlus_dep0,angle)
#                        deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
#                        deltaPlus = concatenate( deltaPlus , anisotropyDifference )
#                        deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
#                        deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
#                    else:
#                        deltaMinus_dep0 = concatenate(deltaMinus_dep0,angle)
#                        deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
#                        deltaMinus = concatenate( deltaMinus , anisotropyDifference )
#                        deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
#                        deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
                except:
                    continue
                
                
    
                outputMagSlopes = concatenate(outputMagSlopes,angle)
                outputAnisotropiesInput = concatenate(outputAnisotropiesInput,aniso)
                outputAnisotropiesMeasured = concatenate(outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
                temp_outputAnisotropiesMeasured = concatenate(temp_outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
                temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MIN,0)
                temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MAX,1E10)
                
                iteration   = iteration+1  
                counter     = counter+1  
                
            r=where(valid(temp_outputAnisotropiesMeasured))
            chiSquared = total((temp_outputAnisotropiesMeasured[r]-aniso)**2/aniso)/numberIterations
            chiSquaredMap = concatenate(chiSquaredMap,chiSquared)
            outputMagSlopesMap = concatenate(outputMagSlopesMap,angle)
            outputAnisotropiesInputMap = concatenate(outputAnisotropiesInputMap,aniso)
    
    
    ##setLayoutOverplot(5)
    #plot(0,p1p2_hist,colorTable='apl_rainbow_white0',zlog=True,zrange=[1E-2,1E6])
    #plot(1,p1p2_hist.property(QDataSet.DEPEND_0),peaks2,renderType='scatter',symbolSize=7,color='black')
    #
    #line = p1p2_hist.property(QDataSet.DEPEND_0)*tan(slope)
    #plot(2,p1p2_hist.property(QDataSet.DEPEND_0),line,color='red',xrange=[-5,5],yrange=[-5,5],xtitle='Vz',ytitle='Vx',lineWidth=4)
    #plot(3,p1p2_hist.property(QDataSet.DEPEND_0),p1p2_hist.property(QDataSet.DEPEND_0)*result_chi[0],color='blue',lineWidth=4)
    
    outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MIN,0)
    outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MAX,1E10)
    plot(outputAnisotropiesMeasured)
    
    #plot(5,outputMagSlopes,outputAnisotropiesMeasured,outputAnisotropiesMeasured/outputAnisotropiesInput)
    plot(0,outputMagSlopes,outputAnisotropiesMeasured,renderType='scatter',xlog=False,ylog=True,xrange=[-1,91],yrange=[0.08,11])
    plot(1,outputMagSlopesMap,outputAnisotropiesInputMap,chiSquaredMap,renderType='colorScatter',xlog=False,ylog=True,xrange=[-1,91],yrange=[0.08,11])

            
elif generatingDeltaPlusMinusMaps == True:
    monitor.setTaskSize(numberOfPoints)
    monitor.setLabel('Generating Uncertainty Maps')   
    #while counter <= numberOfPoints:
    #while lt(TimeUtil.now(),TimeUtil.parseTime('2019-06-25 13:00')):
    while lt(TimeUtil.now(),datum(timeToStopProcessing)):
        for slopeBin in magSlopes:
            angleMinBin = slopeBin
            angleMaxBin = slopeBin+((angleMax-angleMin)/angleBinNumber)
            
            for anisotropyBin in anisotropyList:
                anisotropyMinBin = anisotropyBin
                anisotropyMaxBin = anisotropyBin+((log10(anisotropyMax)-log10(anisotropyMin))/anisotropyBinNumber)
                
                if UseRealisticGaussians == True:
                    # Originally was generating a random point over the whole map
                    #randAngle = (angleMin + (angleMax-angleMin) * rand(1))
                    #randAnisotropy = 10.**(log10(anisotropyMin) + (log10(anisotropyMax)-log10(anisotropyMin)) * rand(1))
                    
                    # Now generating a random point within each bin and progressing through them over and over
                    randAngle = (angleMinBin + (angleMaxBin-angleMinBin) * rand(1))
                    randAnisotropy = 10.**(log10(anisotropyMinBin) + (log10(anisotropyMaxBin)-log10(anisotropyMinBin)) * rand(1))
                    
                    
                    slope = toRadians(randAngle)[0]
                    aniso = randAnisotropy[0]
                    
                    monitor.setTaskProgress(counter)
                    try: 
                        vz_axis = linspace(vz_min,vz_max,length)
                        vx_axis = linspace(vx_min,vx_max,length)
            
                        c1 = thermalSpeed_parallel
                        a1 = density_parallel / (c1*sqrt(PI))
                        b1 = 0#velocity_parallel
            
                        thermalSpeed_perp = thermalSpeed_parallel*aniso
                        c2 = thermalSpeed_perp
                        a2 = density_perp / (c2*sqrt(PI))
                        b2 = 0#velocity_perp
                        
                        #These are realistic individually, but need to be centered on same peak if the histogram is to work
                        #p1_curve = (a1 * exp( -((vz_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
                        #p2_curve = (a2 * exp( -((vx_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
            
                        p1_axis = linspace(-800,800,length)
                        p2_axis = linspace(-800,800,length)
                        p1_curve = (a1 * exp( -((p1_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
                        p2_curve = (a2 * exp( -((p2_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
                        
                        mapNormal = dblarr(p1_curve.length(),p2_curve.length())
                        mapNormal_Depend0 = dblarr(p1_curve.length(),p2_curve.length())
                        mapNormal_Depend1 = dblarr(p1_curve.length(),p2_curve.length())
                        for i in xrange(p1_curve.length()):
                            mapNormal[i,:] = p1_curve[i]*p2_curve
                            for j in xrange(p2_curve.length()):
                                #mapNormal_Depend0[i,j] = (i-(p1_curve.length()/2.))*cos(slope) - (j-(p2_curve.length()/2.))*sin(slope)
                                #mapNormal_Depend1[i,j] = (i-(p1_curve.length()/2.))*sin(slope) + (j-(p2_curve.length()/2.))*cos(slope)
                                mapNormal_Depend0[i,j] = p1_axis[i]*cos(slope) - p2_axis[j]*sin(slope)
                                mapNormal_Depend1[i,j] = p1_axis[i]*sin(slope) + p2_axis[j]*cos(slope)
            
                        
                        mapNormal_rebin  = rebin( link(mapNormal_Depend0+velocity_parallel,mapNormal_Depend1+velocity_perp,mapNormal) , linspace(vz_min,vz_max,30) , linspace(vx_min,vx_max,250) )
                        backgroundNoise = rand(mapNormal_rebin[:,0].length(),mapNormal_rebin[0,:].length())*BackgroundNoiseFactor
                        mapNormal_rebin = mapNormal_rebin+backgroundNoise
                        
                        #plot(1,mapNormal_rebin)
                        p1p2_hist = copy(mapNormal_rebin)
                        
                        p1p2_hist.putProperty(QDataSet.VALID_MIN,0)
                        #print p1p2_hist[28,10]
                        invalidPoints = where(eq(valid(p1p2_hist),0))
                        validPoints = where(valid(p1p2_hist))
                        p1p2_hist[invalidPoints] = 0#1E-30
            
                
                        Nz = cos(slope)
                        Nx = sin(slope)
            
                        
                        #
                        # Peak Identification part:
                        #
                        
                        peaks = None
                        peaks1 = None
                        peaks2 = None
                        for i in xrange(len(p1p2_hist)):
                            temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                            temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                            
                            peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                            peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                            
                        
                        
                                
                        inputGuessParams = [0.5,0.5]
                        f = LinFit()
                        ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                        peaks1 = normalize(peaks1)
                        
                        goodData = where(ge(peaks1,0.3*max(peaks1)))
                        
                        for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0)[goodData])):
                            #print float(peaks1[goodData][i])
                            #ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                            ftr_chi.addObservedPoint(float(peaks1[goodData][i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[goodData][i]),float(peaks2[goodData][i]))
                            
                        result_chi = ftr_chi.fit(f,inputGuessParams)
                           
                        
                        
                        chiline = result_chi[0]
                        #print 'chiline:',chiline
                        #print result_chi[1] 
                        
                        
                        epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                        #epsilon_chi =  + chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                        
                        phi = atan(chiline)
                        
                        #print 'measured_anisotropy:',sqrt(epsilon_chi+1)
                        #print 'input_anisotropy:',aniso
                        
                        
                        anisotropyDifference = sqrt(epsilon_chi+1) - aniso
                        if le(anisotropyDifference.value(),0):
                            deltaPlus_dep0 = concatenate(deltaPlus_dep0,randAngle[0])
                            deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
                            deltaPlus = concatenate( deltaPlus , -anisotropyDifference )
                            deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
                            deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
                        else:
                            deltaMinus_dep0 = concatenate(deltaMinus_dep0,randAngle[0])
                            deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
                            deltaMinus = concatenate( deltaMinus , anisotropyDifference )
                            deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
                            deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
                        counter     = counter+1  
                        
                    except:
                        counter     = counter+1  
                        continue
                    
                    
                elif UseRealisticGaussians == False:
            
                    randAngle = (angleMin + (angleMax-angleMin) * rand(1))
                    randAnisotropy = 10.**(log10(anisotropyMin) + (log10(anisotropyMax)-log10(anisotropyMin)) * rand(1))
                    
                    slope = toRadians(randAngle)[0]
                    aniso = randAnisotropy[0]
                    
                    monitor.setTaskProgress(counter)
                    try:
                    
                        p1 = randomn(long(rand(1)[0]*1E6),length)
                        p2 = randomn(long(rand(1)[0]*1E6),length)*aniso
                        
                        Nz = cos(slope)
                        Nx = sin(slope)
                        
                        p1p2_hist = histogram2d(p1*cos(slope)-p2*sin(slope),p2*cos(slope)+p1*sin(slope),[70,70],dataset([-5,5]),dataset([-5,5]))
                        
                        peaks = None
                        peaks1 = None
                        peaks2 = None
                        for i in xrange(len(p1p2_hist)):
                            temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                            temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                            
                            peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                            peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                            
                        
                        
                                
                        inputGuessParams = [0.5,0.5]
                        f = LinFit()
                        ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                        peaks1 = normalize(peaks1)
                        
                        for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0))):
                            ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                            #ftr_chi.addObservedPoint(float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))#,float(ones(len((peaks1)))[i]))
                            
                        result_chi = ftr_chi.fit(f,inputGuessParams)
                           
                        
                        
                        chiline = result_chi[0]
                        #print 'chiline:',chiline
                        #print result_chi[1] 
                        
                        
                        epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                        
                        phi = atan(chiline)
                        #print 'ecc:',(tan((slope - phi)/slope))
                        
                        #print '1/epsilon:',1./sqrt(epsilon_chi+1)
                        #print 'measured_anisotropy:',sqrt(epsilon_chi+1)
                        #print 'input_anisotropy:',aniso
                        
                        anisotropyDifference = sqrt(epsilon_chi+1) - aniso
                        if le(anisotropyDifference.value(),0):
                            deltaPlus_dep0 = concatenate(deltaPlus_dep0,randAngle[0])
                            deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
                            deltaPlus = concatenate( deltaPlus , -anisotropyDifference )
                            deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
                            deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
                        else:
                            deltaMinus_dep0 = concatenate(deltaMinus_dep0,randAngle[0])
                            deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
                            deltaMinus = concatenate( deltaMinus , anisotropyDifference )
                            deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
                            deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
                        counter     = counter+1  
                        
                    except:
                        counter     = counter+1  
                        continue
                            
                if mod(counter,pauseAndPlotCounter) == 0 and deltaPlus!=None and deltaMinus!=None :     
                    monitor.setProgressMessage('Remaining: '+str(datum(timeToStopProcessing) - TimeUtil.now()))    
                         
                    deltaPlus.putProperty(QDataSet.VALID_MIN,0)
                    deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
                    deltaPlus.putProperty(QDataSet.NAME,'DELTA_PLUS')
                    deltaPlus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
                    deltaPlus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
                    deltaMinus.putProperty(QDataSet.VALID_MIN,0)
                    deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
                    deltaMinus.putProperty(QDataSet.NAME,'DELTA_MINUS')
                    deltaMinus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
                    deltaMinus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
                    
                    deltaPlusLink  = link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus)
                    deltaMinusLink = link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus)
                    deltaPlusLink.putProperty( QDataSet.NAME,'Anisotropy_DELTA_PLUS')
                    deltaMinusLink.putProperty(QDataSet.NAME,'Anisotropy_DELTA_MINUS')
                    
                    # This commented section is left over from plotting the results as a spectrogram before the rebinning was fixed
                    #plot(0,link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus),renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_PLUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
                    #plot(1,link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus),xtitle='Incident MAG Angle',renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_MINUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
                    
                    
                    deltaPlusRebin  = rebin(deltaPlusLink,magSlopes,anisotropyList)
                    deltaMinusRebin = rebin(deltaMinusLink,magSlopes,anisotropyList)
                    
                    deltaPlusRebin.putProperty( QDataSet.NAME,'DELTA_PLUS_UncertaintyMap')
                    deltaMinusRebin.putProperty(QDataSet.NAME,'DELTA_MINUS_UncertaintyMap')
                    
                    anisotropyArray = dblarr(len(deltaPlusRebin[:,0]),len(deltaPlusRebin[0,:]))
                    for i in xrange(len(deltaPlusRebin[:,0])):
                        anisotropyArray[i,:] = anisotropyList
                        
                    plot(0,100*deltaPlusRebin/anisotropyArray,colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E0,1E2],ztitle='DELTA_PLUS Percentage',zlog=True)
                    plot(1,100*deltaMinusRebin/anisotropyArray,xtitle='Incident MAG Angle',colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E0,1E2],ztitle='DELTA_MINUS Percentage',zlog=True)
                    #plot(1,anisotropyArray)
                    
                    try:
                        formatDataSet( deltaPlusLink   , temp_outputMap_googleDrive )
                        formatDataSet( deltaMinusLink  , temp_outputMap_googleDrive+'?append=T' )
                        formatDataSet( deltaPlusRebin  , temp_outputMap_googleDrive+'?append=T' )
                        formatDataSet( deltaMinusRebin , temp_outputMap_googleDrive+'?append=T' )
                    except:
                        try:
                            formatDataSet( deltaPlusLink   , temp_outputMap )
                            formatDataSet( deltaMinusLink  , temp_outputMap+'?append=T' )
                            formatDataSet( deltaPlusRebin  , temp_outputMap+'?append=T' )
                            formatDataSet( deltaMinusRebin , temp_outputMap+'?append=T' )
                        except:
                            continue
      
    deltaPlus.putProperty(QDataSet.VALID_MIN,0)
    deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
    deltaPlus.putProperty(QDataSet.NAME,'DELTA_PLUS')
    deltaPlus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
    deltaPlus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
    deltaMinus.putProperty(QDataSet.VALID_MIN,0)
    deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
    deltaMinus.putProperty(QDataSet.NAME,'Anisotropy DELTA_MINUS')
    deltaMinus.putProperty(QDataSet.NAME,'DELTA_MINUS')
    deltaMinus_dep0.putProperty(QDataSet.NAME,'Incident Mag Angle')
    deltaMinus_dep1.putProperty(QDataSet.NAME,'Anisotropy')
            
    deltaPlusLink  = link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus)
    deltaMinusLink = link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus)
    deltaPlusLink.putProperty(QDataSet.NAME,'Anisotropy DELTA_PLUS')
    deltaMinusLink.putProperty(QDataSet.NAME,'Anisotropy DELTA_MINUS')
    
    # This commented section is left over from plotting the results as a spectrogram before the rebinning was fixed
    #plot(0,link(deltaPlus_dep0,deltaPlus_dep1,deltaPlus),renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_PLUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
    #plot(1,link(deltaMinus_dep0,deltaMinus_dep1,deltaMinus),xtitle='Incident MAG Angle',renderType='spectrogram',colorTable='apl_rainbow_white0',ytitle='Anisotropy DELTA_MINUS',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-4,1E1],zlog=True)
    
    deltaPlusRebin  = rebin(deltaPlusLink ,magSlopes,anisotropyList)
    deltaMinusRebin = rebin(deltaMinusLink,magSlopes,anisotropyList)
            
    anisotropyArray = dblarr(len(deltaPlusRebin[:,0]),len(deltaPlusRebin[0,:]))
    for i in xrange(len(deltaPlusRebin[:,0])):
        anisotropyArray[i,:] = anisotropyList
    
    deltaPlusRebin.putProperty(QDataSet.VALID_MIN,0)
    deltaPlusRebin.putProperty(QDataSet.VALID_MAX,1E10)
    deltaPlusRebin.putProperty(QDataSet.NAME,'UncertaintyMap DELTA_PLUS')
    deltaMinusRebin.putProperty(QDataSet.VALID_MIN,0)
    deltaMinusRebin.putProperty(QDataSet.VALID_MAX,1E10)
    deltaMinusRebin.putProperty(QDataSet.NAME,'UncertaintyMap DELTA_MINUS')
    
    plot(0,100*deltaPlusRebin/anisotropyArray,colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-1,1E2],ztitle='DELTA_PLUS Percentage',zlog=True)
    plot(1,100*deltaMinusRebin/anisotropyArray,xtitle='Incident MAG Angle',colorTable='apl_rainbow_black0',ytitle='Anisotropy  T!B&perp;!N/T!B||!N',yrange=[anisotropyMin,anisotropyMax],ylog=True,zrange=[1E-1,1E2],ztitle='DELTA_MINUS Percentage',zlog=True)
        
  
    formatDataSet( deltaPlusLink   , outputMap )
    formatDataSet( deltaMinusLink  , outputMap+'?append=T' )
    formatDataSet( deltaPlusRebin  , outputMap+'?append=T' )
    formatDataSet( deltaMinusRebin , outputMap+'?append=T' )
    
    
elif RunningSingleCase == True:
    #monitor.setTaskSize(len(magSlopes)*len(anisotropyList)*numberIterations)
    #for angle in magSlopes:
        
    
    slope = toRadians(angle)
    
    clusterUncertainty               = None
    temp_outputAnisotropiesMeasured  = None
    iteration = 0
    while iteration < numberIterations:
        monitor.setTaskProgress(counter)
        #try:
        if True:
            
            def buildBiMaxwellian(vz_min, vz_max, vx_min, vx_max, length, thermalSpeed_parallel, density_parallel, density_perp, velocity_parallel, velocity_perp, angle, aniso):
                slope = toRadians(angle)
                thermalSpeed_perp = thermalSpeed_parallel*aniso
            
                vz_axis = linspace(vz_min,vz_max,length)
                vx_axis = linspace(vx_min,vx_max,length)
    
                c1 = thermalSpeed_parallel
                a1 = density_parallel / (c1*sqrt(PI))
                b1 = 0#velocity_parallel
    
                c2 = thermalSpeed_perp
                a2 = density_perp / (c2*sqrt(PI))
                b2 = 0#velocity_perp
                
                #These are realistic individually, but need to be centered on same peak if the histogram is to work
                #p1_curve = (a1 * exp( -((vz_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
                #p2_curve = (a2 * exp( -((vx_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
    
                p1_axis = linspace(-800,800,length)
                p2_axis = linspace(-800,800,length)
                p1_curve = (a1 * exp( -((p1_axis - b1)**2) / (c1**2) ))#+(rand(length)*0.1)
                p2_curve = (a2 * exp( -((p2_axis - b2)**2) / (c2**2) ))#+(rand(length)*0.1)
                
                mapNormal = dblarr(p1_curve.length(),p2_curve.length())
                mapNormal_Depend0 = dblarr(p1_curve.length(),p2_curve.length())
                mapNormal_Depend1 = dblarr(p1_curve.length(),p2_curve.length())
                for i in xrange(p1_curve.length()):
                    mapNormal[i,:] = p1_curve[i]*p2_curve
                    for j in xrange(p2_curve.length()):
                        #mapNormal_Depend0[i,j] = (i-(p1_curve.length()/2.))*cos(slope) - (j-(p2_curve.length()/2.))*sin(slope)
                        #mapNormal_Depend1[i,j] = (i-(p1_curve.length()/2.))*sin(slope) + (j-(p2_curve.length()/2.))*cos(slope)
                        mapNormal_Depend0[i,j] = p1_axis[i]*cos(slope) - p2_axis[j]*sin(slope)
                        mapNormal_Depend1[i,j] = p1_axis[i]*sin(slope) + p2_axis[j]*cos(slope)
                #plot(mapNormal)
                
                #slope = toRadians(24)
                #mapNormal.putProperty(QDataSet.DEPEND_0,mapNormal_Depend0)
                #mapNormal.putProperty(QDataSet.DEPEND_1,mapNormal_Depend1)
                #mapNormal = transpose(mapNormal)
                #mapNormal.putProperty(QDataSet.DEPEND_1,mapNormal_Depend0)
                #mapNormal = transpose(mapNormal)
                #print mapNormal.property(QDataSet.DEPEND_0)
                
                mapNormal_rebin  = rebin( link(mapNormal_Depend0+velocity_parallel,mapNormal_Depend1+velocity_perp,mapNormal) , linspace(vz_min,vz_max,30) , linspace(vx_min,vx_max,250) )
                backgroundNoise = rand(mapNormal_rebin[:,0].length(),mapNormal_rebin[0,:].length())*BackgroundNoiseFactor
                mapNormal_rebin = mapNormal_rebin+backgroundNoise
                
                #plot(1,mapNormal_rebin)
                p1p2_hist = copy(mapNormal_rebin)
                
                p1p2_hist.putProperty(QDataSet.VALID_MIN,0)
                #print p1p2_hist[28,10]
                invalidPoints = where(eq(valid(p1p2_hist),0))
                validPoints = where(valid(p1p2_hist))
                p1p2_hist[invalidPoints] = 0#1E-30
                #print p1p2_hist[28,10]
                
                return(p1p2_hist)
            
            p1p2_hist = buildBiMaxwellian(vz_min, vz_max, vx_min, vx_max, length, thermalSpeed_parallel, density_parallel, density_perp, velocity_parallel, velocity_perp, angle, aniso)
            
            if RunningDoubleCase == True:
                p3p4_hist = buildBiMaxwellian(vz_min, vz_max, vx_min, vx_max, length, thermalSpeed_parallel_beam, density_parallel_beam, density_perp_beam, velocity_parallel_beam, velocity_perp_beam, angle, aniso_beam)
                
                plot(p1p2_hist)
                plot(p1p2_hist+p3p4_hist, zlog=True)
                #STOP
                p1p2_hist = p1p2_hist+p3p4_hist
            
            Nz = cos(slope)
            Nx = sin(slope)
#
            
            #
            # Peak Identification part:
            #
            
            peaks = None
            peaks1 = None
            peaks2 = None
            for i in xrange(len(p1p2_hist)):
                temp_slice_peak_dep0 = p1p2_hist[i,:][imax(slice0(p1p2_hist,i))]
                temp_slice_peak_dep1 = p1p2_hist.property(QDataSet.DEPEND_1)[imax(slice0(p1p2_hist,i))]
                
                peaks1 = concatenate(peaks1,temp_slice_peak_dep0)
                peaks2 = concatenate(peaks2,temp_slice_peak_dep1)
                
            
            
                    
            inputGuessParams = [0.5,0.5]
            f = LinFit()
            def fittingPart(peaks1, peaks2, p1p2_hist):
                ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
                peaks1 = normalize(peaks1)
                
                goodData = where(ge(peaks1,goodPeakFactor*max(peaks1)))
                
                for i in xrange(len(p1p2_hist.property(QDataSet.DEPEND_0)[goodData])):
                    print float(peaks1[goodData][i])
                    #ftr_chi.addObservedPoint(float(peaks1[i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[i]),float(peaks2[i]))
                    ftr_chi.addObservedPoint(float(peaks1[goodData][i]),float(p1p2_hist.property(QDataSet.DEPEND_0)[goodData][i]),float(peaks2[goodData][i]))
                    
                result_chi = ftr_chi.fit(f,inputGuessParams)
                   
                
                chiline = result_chi[0]
                #print 'chiline:',chiline
                #print result_chi[1] 
                
                
                epsilon_chi =  - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                #epsilon_chi =  + chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
                
                phi = atan(chiline)
                #print 'ecc:',(tan((slope - phi)/slope))
            
                return(epsilon_chi, result_chi)
                
            if RunningDoubleCase == False:
                (epsilon_chi, result_chi) = fittingPart(peaks1, peaks2, p1p2_hist)
                
            elif RunningDoubleCase == True:
                corePeakVz = 324
                corePeakVzIndex = imin(abs(corePeakVz-p1p2_hist.property(QDataSet.DEPEND_0)))
                peaks1_core = dblarr(len(peaks1))
                fitindices = linspace(corePeakVzIndex-2, corePeakVzIndex+2, 5)
                peaks1_core[fitindices] = peaks1[fitindices]
                (epsilon_chi, result_chi) = fittingPart(peaks1_core, peaks2, p1p2_hist)
                
                beamPeakVz = 447
                beamPeakVzIndex = imin(abs(beamPeakVz-p1p2_hist.property(QDataSet.DEPEND_0)))
                peaks1_beam = dblarr(len(peaks1))
                fitindices = linspace(beamPeakVzIndex-2, beamPeakVzIndex+2, 5)
                peaks1_beam[fitindices] = peaks1[fitindices]
                (epsilon_chi_beam, result_chi_beam) = fittingPart(peaks1_beam, peaks2, p1p2_hist)
            
            #print '1/epsilon:',1./sqrt(epsilon_chi+1)
            print 'measured_anisotropy:',sqrt(epsilon_chi+1)
            print 'input_anisotropy:',aniso
            
#                    anisotropyDifference = sqrt(epsilon_chi+1) - aniso
#                    if ge(anisotropyDifference.value(),0):
#                        deltaPlus_dep0 = concatenate(deltaPlus_dep0,angle)
#                        deltaPlus_dep1 = concatenate(deltaPlus_dep1,sqrt(epsilon_chi+1))
#                        deltaPlus = concatenate( deltaPlus , anisotropyDifference )
#                        deltaPlus.putProperty(QDataSet.DEPEND_0,deltaPlus_dep0)
#                        deltaPlus.putProperty(QDataSet.DEPEND_1,deltaPlus_dep1)
#                    else:
#                        deltaMinus_dep0 = concatenate(deltaMinus_dep0,angle)
#                        deltaMinus_dep1 = concatenate(deltaMinus_dep1,sqrt(epsilon_chi+1))
#                        deltaMinus = concatenate( deltaMinus , anisotropyDifference )
#                        deltaMinus.putProperty(QDataSet.DEPEND_0,deltaMinus_dep0)
#                        deltaMinus.putProperty(QDataSet.DEPEND_1,deltaMinus_dep1)
        #except:
        #    iteration   = iteration+1  
        #    continue
        
        

        outputMagSlopes = concatenate(outputMagSlopes,angle)
        outputAnisotropiesInput = concatenate(outputAnisotropiesInput,aniso)
        outputAnisotropiesMeasured = concatenate(outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
        temp_outputAnisotropiesMeasured = concatenate(temp_outputAnisotropiesMeasured,sqrt(epsilon_chi+1))
        temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MIN,0)
        temp_outputAnisotropiesMeasured.putProperty(QDataSet.VALID_MAX,1E10)
        
        if RunningDoubleCase == True:
            outputMagSlopes_beam = concatenate(outputMagSlopes_beam,angle)
            outputAnisotropiesInput_beam = concatenate(outputAnisotropiesInput_beam,aniso_beam)
            outputAnisotropiesMeasured_beam = concatenate(outputAnisotropiesMeasured_beam,sqrt(epsilon_chi_beam+1))
            
        
        iteration   = iteration+1  
        counter     = counter+1  
        
    r=where(valid(temp_outputAnisotropiesMeasured))
    chiSquared = total((temp_outputAnisotropiesMeasured[r]-aniso)**2/aniso)/numberIterations
    #chiSquaredMap = concatenate(chiSquaredMap,chiSquared)
    #outputMagSlopesMap = concatenate(outputMagSlopesMap,angle)
    #outputAnisotropiesInputMap = concatenate(outputAnisotropiesInputMap,aniso)
    
    
#    setLayoutOverplot(5)
#    plot(0,p1p2_hist.property(QDataSet.DEPEND_0),peaks2, normalize(peaks1), xtitle='v!Bz!N (km/s)', ytitle='v!Bx!N (km/s)', renderType='colorScatter',symbolSize=9)
#
#    plot(3,p1p2_hist.property(QDataSet.DEPEND_0)[corePeakVzIndex-4:corePeakVzIndex+4],p1p2_hist.property(QDataSet.DEPEND_0)[corePeakVzIndex-4:corePeakVzIndex+4]*result_chi[0]+result_chi[1],color='blue',lineWidth=3, lineStyle='dashes')
#
#    if RunningDoubleCase == True:
#        plot(4,p1p2_hist.property(QDataSet.DEPEND_0)[beamPeakVzIndex-1:beamPeakVzIndex+4],p1p2_hist.property(QDataSet.DEPEND_0)[beamPeakVzIndex-1:beamPeakVzIndex+4]*result_chi_beam[0]+result_chi_beam[1],color='purple',lineWidth=3, lineStyle='dashes')
#    STOP
    
    load('G:/My Drive/Research/PSP/SPC/SPC_Anisotropy/Anisotropy_Description/SPC_Anisotropy_anisotropyCheck_modelPlot.vap')
    #plot(0,p1p2_hist,colorTable='apl_rainbow_white0',zlog=True,zrange=[1E-2,1E1],title='measured_anisotropy: %s   input_anisotropy: %s'%(sqrt(epsilon_chi+1),aniso))
    plot(0,p1p2_hist,colorTable='apl_rainbow_black0',ztitle='VDF',zlog=True,zrange=[1E-2,1E1],title='measured anisotropy: %s, %s, %s!cinput anisotropy: %s'%(round(outputAnisotropiesMeasured[0],1),round(outputAnisotropiesMeasured[1],1),round(outputAnisotropiesMeasured[2],1),aniso))
    plot(1,p1p2_hist.property(QDataSet.DEPEND_0),peaks2,renderType='scatter',symbolSize=7,color='white')
    #plot(1,p1p2_hist.property(QDataSet.DEPEND_0),peaks2,p1p2_hist[:,peaks2],renderType='colorScatter',symbolSize=7)
    
    # measured_anisotropy: 0.6 , 0.7 , 0.6 !cinput_coreAnisotropy: 3 !cinput_beamAnisotropy: 0.7
    
    line = p1p2_hist.property(QDataSet.DEPEND_0)*tan(slope)
    if RunningSingleCase == True:
        line = p1p2_hist.property(QDataSet.DEPEND_0)*tan(slope)-((velocity_parallel*tan(slope))-velocity_perp)
        
    #plot(2,p1p2_hist.property(QDataSet.DEPEND_0),line,color='red',xrange=[vz_min,vz_max],yrange=[vx_min,vx_max],xtitle='Vz',ytitle='Vx',lineWidth=4)
    plot(2,p1p2_hist.property(QDataSet.DEPEND_0),line,color='red',xtitle='V!Bz!N (km/s)',ytitle='V!Bx!N (km/s)',lineWidth=4)
    plot(3,p1p2_hist.property(QDataSet.DEPEND_0),p1p2_hist.property(QDataSet.DEPEND_0)*result_chi[0]+result_chi[1],color='blue',lineWidth=4)
    
    if plotVzObservedVDF == True:
        tempTotals = dblarr(len(p1p2_hist))
        for i in xrange(p1p2_hist[:,0].length()):
            #print p1p2_hist[i,0]
            tempTotals[i] = total(p1p2_hist[i,:])
        plot(5,p1p2_hist.property(QDataSet.DEPEND_0),tempTotals,xtitle='V!Bz!N (km/s)',ytitle='Collapsed VDF')
        #plot(5,total(p1p2_hist,1))
        
    if RunningDoubleCase == True:
        plot(4,p1p2_hist.property(QDataSet.DEPEND_0),p1p2_hist.property(QDataSet.DEPEND_0)*result_chi_beam[0]+result_chi_beam[1],color='green',lineWidth=4,title='measured core anisotropy: %s, %s, %s!cinput core anisotropy: %s!cmeasured beam anisotropy: %s, %s, %s!cinput beam anisotropy: %s'%(round(outputAnisotropiesMeasured[0],1),round(outputAnisotropiesMeasured[1],1),round(outputAnisotropiesMeasured[2],1),aniso,round(outputAnisotropiesMeasured_beam[0],1),round(outputAnisotropiesMeasured_beam[1],1),round(outputAnisotropiesMeasured_beam[2],1),aniso_beam))
    
monitor.finished()

###############################
###############################
###############################
