

# ############################################################################################ 


def field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds ):
    """Routine used to define field-aligned coordinate system by smoothing over given magnetic field data.
	
	Parameters:
	    Bx = rank1 X component of magnetic field
		By = rank1 Y component of magnetic field
		Bz = rank1 Z component of magnetic field
		TEMP_Rx = rank1 X component of radial s/c position (in same coord system as B)
		TEMP_Ry = rank1 Y component of radial s/c position (in same coord system as B)
		TEMP_Rz = rank1 Z component of radial s/c position (in same coord system as B)
		trend_seconds = rank0 number of seconds over which to average B to define as background
		
    Returns:
	    (Bn , Bp , Bq) = rank1 collection of Magnetic Field components in field-aligned system.
		(Nx , Ny , Nz) = rank1 collection of Magnetic Field direction components in original coord system.
		(Px , Py , Pz) = rank1 collection of Quasi-Radial direction components in original coord system.
		(Qx , Qy , Qz) = rank1 collection of Quasi-Azimuthal direction components in original coord system.
	
	"""
    monitor.setLabel('Field Aligner')    
    # ###
    # ### BOXCAR SMOOTH RAW MAG DATA TO DEFINE FIELD-ALIGNED VECTOR
    # ###    
    
    mag_time = Btotal.property(QDataSet.DEPEND_0)
            #mag_time.putProperty(QDataSet.NAME,'B-field Time')
            
            #print mag_time[1]-mag_time[0]
            #for i in xrange(len(mag_time)):
            #    if( mag_time[i]-mag_time[0] > detrend_time ):
            #        raise getmeouttahere
            #print mag_time.property(QDataSet.UNITS)
    
    smooth_points = int(round(trend_seconds*1./convertUnitsTo(mag_time[1]-mag_time[0],Units.seconds),0))
    
    Bx_smooth = smooth(Bx,smooth_points)
    By_smooth = smooth(By,smooth_points)
    Bz_smooth = smooth(Bz,smooth_points)
    Btotal_smooth = smooth(Btotal,smooth_points)
    
    Nx = Bx_smooth / Btotal_smooth
    Ny = By_smooth / Btotal_smooth
    Nz = Bz_smooth / Btotal_smooth
    
    
    # ###
    # ### PULL RADIAL VECTOR DATA AND DEFINE PERPENDICULAR VECTOR DIRECTIONS
    # ###
    
    ephem_time = TEMP_Rx.property(QDataSet.DEPEND_0)
    ephem_to_mag_ratio = findex(ephem_time,mag_time)
    
    TEMP_Rx = interpolate( TEMP_Rx, ephem_to_mag_ratio )
    TEMP_Ry = interpolate( TEMP_Ry , ephem_to_mag_ratio )
    TEMP_Rz = interpolate( TEMP_Rz , ephem_to_mag_ratio )
    
    TEMP_Rmag = sqrt(TEMP_Rx**2 + TEMP_Ry**2 + TEMP_Rz**2)
    
    Rx = -(TEMP_Rx/TEMP_Rmag) #Negate R so that NxR is westwards (need this for right-handedness)
    Ry = -(TEMP_Ry/TEMP_Rmag) 
    Rz = -(TEMP_Rz/TEMP_Rmag) 
    
    TEMP_Px = ( Ny * Rz ) - ( Nz * Ry )
    TEMP_Py = ( Nz * Rx ) - ( Nx * Rz )
    TEMP_Pz = ( Nx * Ry ) - ( Ny * Rx )
    
    Pmag = sqrt( TEMP_Px**2 + TEMP_Py**2 + TEMP_Pz**2 ) #Have to normalize, since previous definition does not imply unitarity, just orthogonality
        
    Px = TEMP_Px / Pmag # ~azimuthal - positive is in Westward direction
    Py = TEMP_Py / Pmag
    Pz = TEMP_Pz / Pmag
    
    del( [ TEMP_Px , TEMP_Py , TEMP_Pz , Pmag ] )
        
    Qx = -( Py * Nz ) + ( Pz * Ny ) # N x P ~radial - positive is outward
    Qy = -( Pz * Nx ) + ( Px * Nz )
    Qz = -( Px * Ny ) + ( Py * Nx )
    
    
    # ###
    # ### TRANSFORM MAG DATA INTO FIELD-ALIGNED COORDINATES
    # ###
    
    Bn = (Bx * Nx) + (By * Ny) + (Bz * Nz)
    Bp = (Bx * Px) + (By * Py) + (Bz * Pz)
    Bq = (Bx * Qx) + (By * Qy) + (Bz * Qz)
   
    Nx = round(Nx,3)
    Ny = round(Ny,3)
    Nz = round(Nz,3)     
    
    Px = round(Px,3)
    Py = round(Py,3)
    Pz = round(Pz,3) 
    
    Qx = round(Qx,3)
    Qy = round(Qy,3)
    Qz = round(Qz,3)           
                    
    ###
    ### ADD LABELS AND UNITS AND STUFF, RETURN RESULTS
    ###
    
    Bn.putProperty(QDataSet.LABEL,'B!B||!N')
    Bn.putProperty(QDataSet.NAME,'B!B||!N')
#    Bp.putProperty(QDataSet.LABEL,'B!B&perp;east!N')
#    Bp.putProperty(QDataSet.NAME,'B!B&perp;east!N')
#    Bq.putProperty(QDataSet.LABEL,'B!B&perp;rad!N')
#    Bq.putProperty(QDataSet.NAME,'B!B&perp;rad!N')
    Bp.putProperty(QDataSet.LABEL,'B!B&perp;x!N')
    Bp.putProperty(QDataSet.NAME,'B!B&perp;x!N')
    Bq.putProperty(QDataSet.LABEL,'B!B&perp;y!N')
    Bq.putProperty(QDataSet.NAME,'B!B&perp;y!N')
    Btotal.putProperty(QDataSet.LABEL,'|B|')
    Btotal.putProperty(QDataSet.NAME,'|B|')
    
    
    return( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz )
    
    



############################################################################

timerange = getParam('timerange','2018-11-02 11:00 to 11:30','Iteration Timerange')
version = '0.2'
plotFitsAndPauseALot = False

monitor.started()
trs= generateTimeRanges('$Y-$m-$d',timerange)
for tr in trs:
    monitor.setProgressMessage(tr)

        
    #tr = '2018-11-03 18:33 to 18:39'
    #tr = '2018-11-02 16:45 to 17:20'
    #tr = '2019-04-01 07:00 to 10:00'
    #tr = '2019-04-05 17:30 to 22:30'
    #tr = '2019-04-05 18:30 to 18:40'
    #tr = '2018-11-12'
    #tr = '2018-11-04 04:40 to 06:20'
    #tr = '2019-04-01 08:00 to 08:15'
    #tr = '2018-10-30 16:10 to 20:40'
    
    
    m_p                  = 1.6726231E-24
    q                    = 1.6022E-12
    trend_seconds        = 30     # Number of seconds over which to average magField to determine background field direction
    minFluxValueForFit   = 0.5    # Throw out/Don't fit data points where totalFlux is below this value
    fitSeconds           = 5     # Number of seconds over which to do the linear fitting between (vx,vy) and vz*(bx,by)
    
    cfa_sweap_file = 'http://w3sweap.cfa.harvard.edu/data/sci/spc/L2/$Y/$m/spp_swp_spc_l2_$Y$m$d_v$v.cdf'
        
    spc_a = getDataSet(cfa_sweap_file+'?a_current&where=MODE_FLAG.eq(0)',tr)
    spc_b = getDataSet(cfa_sweap_file+'?b_current&where=MODE_FLAG.eq(0)',tr)
    spc_c = getDataSet(cfa_sweap_file+'?c_current&where=MODE_FLAG.eq(0)',tr)
    spc_d = getDataSet(cfa_sweap_file+'?d_current&where=MODE_FLAG.eq(0)',tr)
    
    mv_lo = getDataSet(cfa_sweap_file+'?mv_lo&where=MODE_FLAG.eq(0)',tr)
    mv_hi = getDataSet(cfa_sweap_file+'?mv_hi&where=MODE_FLAG.eq(0)',tr)
    
    
    #spc_list = [spc_a,spc_b,spc_c,spc_d]
    
    spc_a = trim(spc_a,tr)
    spc_b = trim(spc_b,tr)
    spc_c = trim(spc_c,tr)
    spc_d = trim(spc_d,tr)
    
    mv_lo = trim(mv_lo,tr)
    mv_hi = trim(mv_hi,tr)
    #print spc_a
    
    
    #spc_a = putProperty(spc_a/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
    #spc_b = putProperty(spc_b/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
    #spc_c = putProperty(spc_c/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
    #spc_d = putProperty(spc_d/(mv_hi-mv_lo),QDataSet.DEPEND_1,mv_lo)
    spc_list = [spc_a,spc_b,spc_c,spc_d]
    del(spc_a,spc_b,spc_c,spc_d)
    
    totalFlux = sum(spc_list)
    #totalFlux = totalFlux/((mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo))
    
    fluxDifference_scx = (spc_list[0]+spc_list[3]) - (spc_list[1]+spc_list[2])
    fluxDifference_scy = (spc_list[0]+spc_list[1]) - (spc_list[2]+spc_list[3])
    
    U = (fluxDifference_scy/totalFlux)/0.035
    V = (fluxDifference_scx/totalFlux)/0.035
    
    U.putProperty(QDataSet.VALID_MIN,None)
    V.putProperty(QDataSet.VALID_MIN,None)
    U.putProperty(QDataSet.VALID_MAX,None)
    V.putProperty(QDataSet.VALID_MAX,None)
    
    #r0 = where(valid(U)) *(-1) + 1
    #U[r0] = -180
    #r0 = where(valid(V)) *(-1) + 1
    #V[r0] = -180
    
    for j in xrange(len(U[0,:])):
        try:
            U[:,j] = medianFilter(U[:,j],3)
        except:
            continue
        try:
            V[:,j] = medianFilter(V[:,j],3)
        except:
            continue
    
    U.putProperty(QDataSet.UNITS,Units.degrees)
    V.putProperty(QDataSet.UNITS,Units.degrees)
    
    #plot(0,totalFlux)
    #plot(1,U)
    #plot(2,V)
    
    
    #Are you measuring the slope near the peak in current or near the peak in the velocity distribution function? 
    #(the VDF goes like current divided by speed time window width in speed units)
    
    
    v_z = sqrt( (2./m_p) * q*(mv_lo + (mv_hi-mv_lo)/2.) ) / 1.E5   # in km/s
    windowWidths = sqrt( (2./m_p) * q*(mv_hi-mv_lo)/2.) / 1.E5
    vdf = totalFlux/v_z*windowWidths
    vdf.putProperty(QDataSet.DEPEND_1,v_z)
    del(windowWidths,mv_hi)
    
    #totalFlux = totalFlux / (mv_lo + (mv_hi-mv_lo)/2) * (mv_hi-mv_lo)
    #totalFlux = totalFlux/( (mv_hi-mv_lo))
    totalFlux.putProperty(QDataSet.DEPEND_1,mv_lo)
    peaks = reduceMax(totalFlux,1)
    r = where(eq(totalFlux,peaks))
    
    #mainFlowYsc = U[r]  # Mike's routine calls this azimuth (and is negative)
    #mainFlowXsc = V[r]  # Mike's routine calls this elevation
    
    #mainFlowU = smooth1(U,3)[r]
    #mainFlowV = smooth1(V,3)[r]
    
    #plot(3,mainFlowYsc,ytitle='Ysc Deflection')
    #plot(4,mainFlowXsc,ytitle='Xsc Deflection')
    
    
    ###
    
    #fluxDifference_agyro = (spc_list[0]+spc_list[2]) - (spc_list[1]+spc_list[3])
    #W = (fluxDifference_agyro/totalFlux)/0.035
    #
    #W.putProperty(QDataSet.VALID_MIN,None)
    #W.putProperty(QDataSet.VALID_MAX,None)
    #for j in xrange(len(W[0,:])):
    #    try:
    #        W[:,j] = medianFilter(W[:,j],3)
    #    except:
    #        continue
            
    #plot(5,W)
    
    ####
    
    # chi = (v_z2-v_z1) / (v_z2*tan(phi2) - v_z1*tan(phi1))
    # V_lo < 0.5*m*v^2 < V_hi
    
    #v_z2 = mv_hi
    #v_z1 = mv_lo 
    #v_z = sqrt( (2/m_p) * (mv_lo + (mv_hi-mv_lo)/2) )    # in cm/s
    #v_z = sqrt( (2/m_p) * (mv_lo + (mv_hi-mv_lo)/2) ) / 1.E5   # in km/s
    #plot(v_z)
    #stop
    
    vz_tanPhi   = v_z * tan(toRadians(U))     # Vy
    vz_tanTheta = v_z * tan(toRadians(V))     # Vx
    #plot(vz_tanPhi)
    #stop
    
    
    #chi = zeros(len(U[:,0]),len(U[0,:]))
    #psi = zeros(len(U[:,0]),len(U[0,:]))
    #for i in xrange(len(U[:,0])):
    #    chi[i] = diff(v_z[i,:]) / diff(vz_tanPhi[i,:])
    #    psi[i] = diff(v_z[i,:]) / diff(vz_tanTheta[i,:])
    
    #v_z.putProperty(QDataSet.DEPEND_1,mv_lo)  
    
    ###
    # Define upper point
    r_lower = copy(r)
    r_lower[:,1] = r[:,1]-2
    r_upper = copy(r)
    r_upper[:,1] = r[:,1]+2
    #plot(chi)
    
    setLayoutOverplot(4) 
    
    #plot(0,totalFlux)
    plot(0,vdf,colorTable='apl_rainbow_black0',ytitle='v!Bz!N (km/s)',ztitle='vdf')
    #upperBound = dblarr(len(vdf))
    #upperBound = vdf[r_upper]
    #lowerBound = dblarr(len(vdf))
    #lowerBound = vdf[r_lower]
    #plot(1,upperBound)
    #plot(2,lowerBound)
    
    
    from org.apache.commons.math.optimization.fitting import CurveFitter
    from org.apache.commons.math.optimization.fitting import ParametricRealFunction
    from org.apache.commons.math.optimization.general import LevenbergMarquardtOptimizer
    from org.apache.commons.math.stat.regression      import SimpleRegression
    
    class LinFit(ParametricRealFunction):
        def value(self, x, params):
            a = params[0]
            b = params[1]
            return (a*x + b)
        def gradient(self, x, params):
            a = params[0]
            b = params[1]
            return [x,1]
    
    #####
    ##########
    #################
    mag_datafile = 'http://w3sweap.cfa.harvard.edu/data/sci/mag/l2_draft/$Y/$m/psp_fld_l2_mag_$Y$m$d_v$v.cdf'
    mag = getDataSet(mag_datafile+'?psp_fld_mag_sc',tr)
    
    #mag = getDataSet('file:/home/kpaulson/data/remote/spp_swp_spc_magosurvey_20181103_v00.cdf?B_SC')
    mag = trim(mag,tr)
    
    mag_time = mag.property(QDataSet.DEPEND_0)
    
    pos = getDataSet('http://sweap.cfa.harvard.edu/data/sci/spc/L3/$Y/$m/spp_swp_spc_l3i_$Y$m$d_v$v.cdf?sc_pos_HCI',tr)
    pos_time = pos.property(QDataSet.DEPEND_0)
    
    Bx = mag[:,0]
    By = mag[:,1]
    Bz = mag[:,2]
    Btotal = magnitude(mag)
    
    TEMP_Rx = putProperty(ones(len(Btotal)),QDataSet.DEPEND_0,mag_time)
    TEMP_Ry = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
    TEMP_Rz = putProperty(zeros(len(Btotal)),QDataSet.DEPEND_0,mag_time)
    
    
    ( Bn , Bp , Bq , Nx , Ny , Nz , Px , Py , Pz , Qx , Qy , Qz ) = field_aligner( Bx , By, Bz , Btotal , TEMP_Rx , TEMP_Ry , TEMP_Rz , trend_seconds )
    
    (Nx_temp,Ny_temp,Nz_temp) = synchronize(totalFlux,[Nx,Ny,Nz])
    #################
    ##########
    #####
    
    
    inputGuessParams = [float(rand(1)[0]),float(rand(1)[0])]            
    chiline                = None
    psiline                = None
    epsilonEpoch           = None
    chiSquaredReduced_chi  = None
    chiSquaredReduced_psi  = None
    rSquared_chi           = None
    rSquared_psi           = None
    
    if ge(fitSeconds,1.):
        dds= generateTimeRanges('$Y-$m-$d $H:$M:$(S,span=%s)'%(fitSeconds),tr)
        dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$(S,span=%s)'%(fitSeconds),tr)
    elif lt(fitSeconds,1.):
        dds= generateTimeRanges('$Y-$m-$d $H:$M:$S.$(milli,span=%s)'%int(fitSeconds*1E3),tr)
        dds_title= generateTimeRanges('$Y-$m-$d_$H-$M-$S.$(milli,span=%s)'%int(fitSeconds*1E3),tr)
    
    monitor.setTaskSize(len(dds)-1)
    for ind in xrange(len(dds)-1):
        monitor.setTaskProgress(ind)
        monitor.setLabel('Linear Fits') 
        #mappedAngleIndex = None
        
        try:
            tr_dds = dds[ind]+' to '+dds[ind+1]
            if mod(ind,20) == 0:
                plot(3,datumRange(tr_dds),renderType='eventsBar',color='magenta')
            
            epsilonEpoch = concatenate(epsilonEpoch,datum(dds[ind])+(datum(dds[ind+1])-datum(dds[ind]))/2.)
            
            v_z_dd = trim(v_z,tr_dds)
            vz_tanPhi_dd = trim(vz_tanPhi,tr_dds)
            vz_tanTheta_dd = trim(vz_tanTheta,tr_dds)
            #vz_tanTheta_dd = trim(vz_tanTheta,'%s to %s'%())
            totalFlux_dd = trim(totalFlux,tr_dds)
            vdf_dd = trim(vdf,tr_dds)
            
            Nx_temp_dd = trim(Nx_temp,tr_dds)
            Ny_temp_dd = trim(Ny_temp,tr_dds)
            
            temp_v_z = None
            temp_vz_tanTheta = None
            temp_vz_tanPhi = None
            temp_totalFlux = None
            temp_vdf = None
            temp_Nx_temp_dd = None
            temp_Ny_temp_dd = None
            for i in xrange(len(v_z_dd)):
                temp_v_z         = concatenate(temp_v_z,v_z_dd[i,:])
                temp_vz_tanPhi   = concatenate(temp_vz_tanPhi,vz_tanPhi_dd[i,:])      # Vy
                temp_vz_tanTheta = concatenate(temp_vz_tanTheta,vz_tanTheta_dd[i,:])  # Vx
                temp_totalFlux   = concatenate(temp_totalFlux,totalFlux_dd[i,:])
                temp_vdf         = concatenate(temp_vdf,vdf_dd[i,:])
                temp_Nx_temp_dd  = concatenate(temp_Nx_temp_dd,ones(len(v_z_dd[i,:]))*Nx_temp_dd[i])
                temp_Ny_temp_dd  = concatenate(temp_Ny_temp_dd,ones(len(v_z_dd[i,:]))*Ny_temp_dd[i])
            #plot(8,temp_Nx_temp_dd[where(valid(temp_v_z))])
            #plot(9,indgen(341),temp_v_z[where(valid(temp_v_z))]),temp_Nx_temp_dd[where(valid(temp_v_z))])
                
            norm_temp_totalFlux = normalize(temp_totalFlux)
            norm_temp_vdf = normalize(temp_vdf)
            r = where(ge(temp_totalFlux,0.5).and(valid(temp_totalFlux)))  # Removes points from the measurement below a particular threschhold
            r = where(ge(temp_totalFlux,minFluxValueForFit).and(valid(temp_totalFlux)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
            r = where(ge(temp_vdf,minFluxValueForFit).and(valid(temp_vdf)).and(valid(temp_v_z)))  # Removes points from the measurement below a particular threschhold
            
            # These two lines below should create a step function on the normalized weights such that anything less than 0.5 goes to 0. The idea is that this will only fit the points that are above half the max of the peak
            blackoutNormalized = where(lt(norm_temp_vdf,0.5))
            norm_temp_vdf[blackoutNormalized] = 0
        
            f = LinFit()
            ftr_chi = CurveFitter(LevenbergMarquardtOptimizer())
            ftr_psi = CurveFitter(LevenbergMarquardtOptimizer())
            
            regr_chi = SimpleRegression()
            regr_psi = SimpleRegression()
            
            for i in xrange(len(temp_v_z[r])):
                #ftr_chi.addObservedPoint(float(norm_temp_vdf[r][i]),float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]),float(temp_vz_tanPhi[r][i]))
                #ftr_psi.addObservedPoint(float(norm_temp_vdf[r][i]),float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]),float(temp_vz_tanTheta[r][i]))
                ftr_chi.addObservedPoint(float(norm_temp_vdf[r][i]),float(temp_v_z[r][i]*temp_Nx_temp_dd[r][i]),float(temp_vz_tanTheta[r][i]))
                ftr_psi.addObservedPoint(float(norm_temp_vdf[r][i]),float(temp_v_z[r][i]*temp_Ny_temp_dd[r][i]),float(temp_vz_tanPhi[r][i]))
                
                # This line below is the start of attempting to find the uncertainty value all along the fitting length .It might be easier to do it in bulk at the end
                #mappedAngleIndex = concatenate( mappedAngleIndex , imin(toDegrees(asin(temp_Nx_temp_dd[r][i]))-abs(anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) )
                
            result_chi = ftr_chi.fit(f,inputGuessParams)
            result_psi = ftr_psi.fit(f,inputGuessParams)
        #    print 'slope:',result[0]
        #    print 'offset:',result[1]
            
            #xx = linspace( min(temp_v_z[r][where(valid(temp_v_z[r]))]) , max(temp_v_z[r][where(valid(temp_v_z[r]))]) , 100)
            xx_x = linspace( min((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Nx_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
            xx_y = linspace( min((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , max((temp_v_z[r]*temp_Ny_temp_dd[r])[where(valid(temp_v_z[r]))]) , 100)
        
            
            psiline = concatenate(psiline,result_psi[0])
            chiline = concatenate(chiline,result_chi[0])
            
            #temp_chiSquaredReduced_chi = abs(total( ( temp_vz_tanPhi[r] - (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) )**2 / (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) ) ) / len(temp_v_z[r])
            #temp_chiSquaredReduced_psi = abs(total( ( temp_vz_tanTheta[r] - (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) )**2 / (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) ) ) / len(temp_v_z[r])
            temp_chiSquared_chi = abs(total( ( temp_vz_tanTheta[r] - (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) )**2 / (result_chi[0]*(temp_v_z[r]*temp_Nx_temp_dd[r]) + result_chi[1]) ) )
            temp_chiSquared_psi = abs(total( ( temp_vz_tanPhi[r]   - (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) )**2 / (result_psi[0]*(temp_v_z[r]*temp_Ny_temp_dd[r]) + result_psi[1]) ) )
            temp_chiSquaredReduced_chi = temp_chiSquared_chi / len(temp_v_z[r])
            temp_chiSquaredReduced_psi = temp_chiSquared_psi / len(temp_v_z[r])
            chiSquaredReduced_chi = concatenate(chiSquaredReduced_chi,temp_chiSquaredReduced_chi)
            chiSquaredReduced_psi = concatenate(chiSquaredReduced_psi,temp_chiSquaredReduced_psi)
            
            temp_rSquared_chi = 1 - (temp_chiSquared_chi / total(abs(temp_vz_tanTheta[r] - mean(temp_vz_tanTheta[r]))**2))
            temp_rSquared_psi = 1 - (temp_chiSquared_psi / total(abs(temp_vz_tanPhi[r]   - mean(temp_vz_tanPhi[r]))**2))
            rSquared_chi = concatenate(rSquared_chi,temp_rSquared_chi)
            rSquared_psi = concatenate(rSquared_psi,temp_rSquared_psi)
            
            if plotFitsAndPauseALot == True:
                plot(4,temp_v_z[r]*temp_Nx_temp_dd[r],temp_vz_tanTheta[r] ,norm_temp_totalFlux[r],renderType='colorScatter',ztitle='Normalized Flux',symbolSize=3)
                plot(6,temp_v_z[r]*temp_Ny_temp_dd[r],temp_vz_tanPhi[r]   ,norm_temp_totalFlux[r],renderType='colorScatter',ztitle='Normalized Flux',symbolSize=3)
                plot(5,xx_x,(result_psi[0]*xx_x + result_chi[1]),color='red',xtitle=tr_dds,title=str(mean(Nx_temp_dd)),symbolSize=0,lineWidth=2)
                plot(7,xx_y,(result_chi[0]*xx_y + result_psi[1]),color='red',xtitle='V!Bz!N!C'+tr_dds,title=str(mean(Ny_temp_dd)),symbolSize=0,lineWidth=2)
                sleep(3000)
        except:
            print 'oopsy, couldn\'t fit for some reason'
            continue
    #        psiline = concatenate(psiline,-1E36)
    #        chiline = concatenate(chiline,-1E36)
    #        chiSquaredReduced_chi = concatenate(chiSquaredReduced_chi,-1E36)
    #        chiSquaredReduced_psi = concatenate(chiSquaredReduced_psi,-1E36)
    
    psiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    chiline.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    chiSquaredReduced_chi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    chiSquaredReduced_psi.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    
    
    output_file = '/home/kpaulson/Research/PSP/Anisotropy/TEMPfits_fromMath_%s.cdf'%(dds_title[0]+'_to_'+dds_title[-1])
    output_file = '/home/kpaulson/Research/PSP/Anisotropy/Anisotropy_Files/SPC_Anisotropy_%s_v%s.cdf'%(tr,version)
    #output_file = 'D:/Research/ParkerProbe/SWEAP/SPC/Anisotropy/TEMPfits_fromMath_%s.cdf'%(dds_title[0]+'_to_'+dds_title[-1])
    
    psiline.putProperty(QDataSet.NAME,'Psi')
    psiline.putProperty(QDataSet.TITLE,'Linear fit of scan points over %s-second range in Vy/Vz space'%fitSeconds)
    psiline.property(QDataSet.DESCRIPTION)
    chiline.putProperty(QDataSet.TITLE,'Chi')
    chiline.putProperty(QDataSet.DESCRIPTION,'Linear fit of scan points over %s-second range in Vx/Vz space'%fitSeconds)
    chiSquaredReduced_chi.putProperty(QDataSet.NAME,'ChiSquared_chi')
    chiSquaredReduced_chi.putProperty(QDataSet.TITLE,'Reduced chi-squared from linear fit determining Chi')
    chiSquaredReduced_psi.putProperty(QDataSet.NAME,'ChiSquared_psi')
    chiSquaredReduced_psi.putProperty(QDataSet.TITLE,'Reduced chi-squared from linear fit determining Psi')
    rSquared_chi.putProperty(QDataSet.NAME,'rSquared_chi')
    rSquared_chi.putProperty(QDataSet.TITLE,'R-squared from linear fit determining Chi')
    rSquared_psi.putProperty(QDataSet.NAME,'rSquared_psi')
    rSquared_psi.putProperty(QDataSet.TITLE,'R-squared from linear fit determining Psi')
    
    formatDataSet(chiline,output_file)
    formatDataSet(psiline,output_file+'?append=T')
    formatDataSet(chiSquaredReduced_chi,output_file+'?append=T')
    formatDataSet(chiSquaredReduced_psi,output_file+'?append=T')
    formatDataSet(rSquared_chi,output_file+'?append=T')
    formatDataSet(rSquared_psi,output_file+'?append=T')
    
    
    
    (Nx,Ny,Nz) = synchronize(chiline,[Nx,Ny,Nz])
    
    Bunit = bundle(Nx,Ny,Nz)
    Bunit.putProperty(QDataSet.NAME,'B_hat')
    Bunit.putProperty(QDataSet.TITLE,'Unit vector of background B-field direction using %s-second average'%(trend_seconds))
    Bunit.putProperty(QDataSet.DEPEND_0,epsilonEpoch)
    formatDataSet(Bunit,output_file+'?append=T')
    
    #epsilon_chi = - chiline / ( (chiline*(1 - Nz**2)) + Nz*Nx )
    #epsilon_psi = - psiline / ( (psiline*(1 - Nz**2)) + Nz*Ny )
    epsilon_chi = - chiline / ( (chiline*(1 - Nz**2)) + Nz ) # By including the Nx and Ny factors in the linear fitting above, these variables become independent of perp mag field
    epsilon_psi = - psiline / ( (psiline*(1 - Nz**2)) + Nz )
    epsilon_chi.putProperty(QDataSet.NAME,'Epsilon_chi')
    epsilon_psi.putProperty(QDataSet.NAME,'Epsilon_psi')
    formatDataSet(epsilon_chi,output_file+'?append=T')
    formatDataSet(epsilon_psi,output_file+'?append=T')
    
    anisotropy_chi = sqrt(epsilon_chi+1)
    anisotropy_psi = sqrt(epsilon_psi+1)
    anisotropy_chi.putProperty(QDataSet.NAME,'Anisotropy_chi')
    anisotropy_chi.putProperty(QDataSet.TITLE,'Anisotropy from SPC determined from Vx/Vz fit over %s-second range with %s-second averaged background B-field direction'%(fitSeconds,trend_seconds))
    anisotropy_psi.putProperty(QDataSet.NAME,'Anisotropy_psi')
    anisotropy_psi.putProperty(QDataSet.TITLE,'Anisotropy from SPC determined from Vy/Vz fit over %s-second range with %s-second averaged background B-field direction'%(fitSeconds,trend_seconds))
    
    
    
    #####
    ##########
    #################
    anisotropy_deltaPlusMinusFile = 'file:/home/kpaulson/Research/PSP/Anisotropy/TEMP_Anisotropy_DELTA_PLUS-MINUS copy.cdf'
    
    anisotropy_deltaPlus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_PLUS')
    anisotropy_deltaMinus = getDataSet(anisotropy_deltaPlusMinusFile+'?UncertaintyMap DELTA_MINUS')
    anisotropy_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
    anisotropy_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
    anisotropy_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
    anisotropy_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
    #################
    ##########
    #####
    
    
    
    #mappedAngleIndex_chi      = dblarr(len(epsilonEpoch))
    #mappedAngleIndex_psi      = dblarr(len(epsilonEpoch))
    #mappedAnisotropyIndex_chi = dblarr(len(epsilonEpoch))
    #mappedAnisotropyIndex_psi = dblarr(len(epsilonEpoch))
    anisotropy_chi_deltaPlus  = dblarr(len(epsilonEpoch))
    anisotropy_chi_deltaMinus = dblarr(len(epsilonEpoch))
    anisotropy_psi_deltaPlus  = dblarr(len(epsilonEpoch))
    anisotropy_psi_deltaMinus = dblarr(len(epsilonEpoch))
    for i in xrange(len(epsilonEpoch)):
        # The asin() is wrong, since I don't want the total orthogonality angle, just the angle between (Nx,Ny) and Nz
        #mappedAngleIndex_chi = imin(abs(toDegrees(asin(Nx[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
        #mappedAngleIndex_psi = imin(abs(toDegrees(asin(Ny[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
        
        # This atan() sould account for the above issue
        mappedAngleIndex_chi = imin(abs(toDegrees(atan(Nx[i]/Nz[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
        mappedAngleIndex_psi = imin(abs(toDegrees(atan(Ny[i]/Nz[i]))-anisotropy_deltaPlus.property(QDataSet.DEPEND_0))) 
        
        mappedAnisotropyIndex_chi = imin(abs(anisotropy_chi[i]-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
        mappedAnisotropyIndex_psi = imin(abs(anisotropy_psi[i]-anisotropy_deltaPlus.property(QDataSet.DEPEND_1))) 
        
        if mappedAngleIndex_chi != -1 and mappedAnisotropyIndex_chi != -1 :
            anisotropy_chi_deltaPlus[i]  = anisotropy_deltaPlus[ mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
            anisotropy_chi_deltaMinus[i] = anisotropy_deltaMinus[mappedAngleIndex_chi,mappedAnisotropyIndex_chi]
        else:
            anisotropy_chi_deltaPlus[i]  = -1
            anisotropy_chi_deltaMinus[i] = -1
            
        if mappedAngleIndex_psi != -1 and mappedAnisotropyIndex_psi != -1 :
            anisotropy_psi_deltaPlus[i]  = anisotropy_deltaPlus[ mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
            anisotropy_psi_deltaMinus[i] = anisotropy_deltaMinus[mappedAngleIndex_psi,mappedAnisotropyIndex_psi]
        else:
            anisotropy_psi_deltaPlus[i]  = -1
            anisotropy_psi_deltaMinus[i] = -1
        
    anisotropy_chi_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
    anisotropy_chi_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
    anisotropy_chi_deltaPlus.putProperty(QDataSet.NAME, 'anisotropy_chi_deltaPlus')
    anisotropy_chi_deltaPlus.putProperty(QDataSet.TITLE, 'DELTA_PLUS values for anisotropy_chi determined from ideal model (ie best we can do even assuming perfect data input)')
    anisotropy_chi_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
    anisotropy_chi_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
    anisotropy_chi_deltaMinus.putProperty(QDataSet.NAME, 'anisotropy_chi_deltaMinus')
    anisotropy_chi_deltaMinus.putProperty(QDataSet.TITLE, 'DELTA_MINUS values for anisotropy_chi determined from ideal model (ie best we can do even assuming perfect data input)')
    anisotropy_psi_deltaPlus.putProperty(QDataSet.VALID_MIN,0)
    anisotropy_psi_deltaPlus.putProperty(QDataSet.VALID_MAX,1E10)
    anisotropy_psi_deltaPlus.putProperty(QDataSet.NAME, 'anisotropy_psi_deltaPlus')
    anisotropy_psi_deltaPlus.putProperty(QDataSet.TITLE, 'DELTA_PLUS values for anisotropy_psi determined from ideal model (ie best we can do even assuming perfect data input)')
    anisotropy_psi_deltaMinus.putProperty(QDataSet.VALID_MIN,0)
    anisotropy_psi_deltaMinus.putProperty(QDataSet.VALID_MAX,1E10)
    anisotropy_psi_deltaMinus.putProperty(QDataSet.NAME, 'anisotropy_psi_deltaMinus')
    anisotropy_psi_deltaMinus.putProperty(QDataSet.TITLE, 'DELTA_MINUS values for anisotropy_psi determined from ideal model (ie best we can do even assuming perfect data input)')
    
    anisotropy_chi.putProperty(QDataSet.DELTA_PLUS, anisotropy_chi_deltaPlus)
    anisotropy_chi.putProperty(QDataSet.DELTA_MINUS,anisotropy_chi_deltaMinus)
    anisotropy_psi.putProperty(QDataSet.DELTA_PLUS, anisotropy_psi_deltaPlus)
    anisotropy_psi.putProperty(QDataSet.DELTA_MINUS,anisotropy_psi_deltaMinus)
    formatDataSet(anisotropy_chi,output_file+'?append=T')
    formatDataSet(anisotropy_psi,output_file+'?append=T')
    
    formatDataSet(anisotropy_chi_deltaPlus,output_file+'?append=T')
    formatDataSet(anisotropy_chi_deltaMinus,output_file+'?append=T')
    formatDataSet(anisotropy_psi_deltaPlus,output_file+'?append=T')
    formatDataSet(anisotropy_psi_deltaMinus,output_file+'?append=T')
    
    #plot(4,epsilonEpoch,epsilon_chi,color='red')
    #plot(5,epsilonEpoch,epsilon_psi,color='blue',ytitle='(&omega;!B&perp;!N/&omega;!B||!N)!U2!N - 1')
    plot(4,epsilonEpoch,anisotropy_chi,color='red',symbol='none')
    plot(5,epsilonEpoch,anisotropy_psi,color='blue',symbol='none',ytitle='&omega;!B&perp;!N/&omega;!B||!N')
    plot(6,epsilonEpoch,rSquared_chi,color='red',symbol='none')
    plot(7,epsilonEpoch,rSquared_psi,color='blue',symbol='none',ytitle='R!U2!N of Fit')
    #plot(6,epsilonEpoch,anisotropy_chi,chiSquaredReduced_chi,symbolSize=4)
    #plot(7,epsilonEpoch,anisotropy_psi,chiSquaredReduced_psi,symbolSize=4)
    
    
    #plot(6,epsilonEpoch,anisotropy_chi_deltaPlus)
    
    
    
    
    #stop
    #
    #epsilon_chi.putProperty(QDataSet.DEPEND_1,mv_lo)
    #epsilon_psi.putProperty(QDataSet.DEPEND_1,mv_lo)
    #
    ##reset()
    #plot(0,totalFlux)
    #plot(3,epsilon_chi,ytitle='&epsilon;&Chi;')
    #plot(4,epsilon_psi,ytitle='&epsilon;&Psi;')

monitor.finished()
